/*
 * Copyright (c) 2011,2012 Oracle and/or its affiliates.  All rights reserved.
 * Use is subject to license terms.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT
 */

#ifndef	_PSIF_HW_DATA_H
#define	_PSIF_HW_DATA_H

#ifdef __cplusplus
extern "C" {
#endif

#include "./psif_api.h"
#include <stdint.h>
#define u8 uint8_t
#define u16 uint16_t
#define u32 uint32_t
#define u64 uint64_t
/* Extent of all psif enums */
typedef enum {
	PSIF_MMU_TRANSLATION_EXTENT	 = 0x8,
	PSIF_PAGE_SIZE_EXTENT	 = 0xf,
	PSIF_QP_COMMAND_EXTENT	 = 0x4,
	PSIF_PORT_EXTENT	 = 0x2,
	PSIF_QP_STATE_EXTENT	 = 0x8,
	PSIF_MODIFY_STATUS_EXTENT	 = 0x7,
	PSIF_EVENT_STATUS_EXTENT	 = 0x15,
	PSIF_EVENT_TYPE_EXTENT	 = 0x7,
	PSIF_PATH_MTU_EXTENT	 = 0x7,
	PSIF_PORT_SAMPLECOUNTER_TYPE_EXTENT	 = 0x48,
	IB_OPCODE_EXTENT	 = 0xc6,
	PSIF_VLINK_STATE_EXTENT	 = 0x11,
	PSIF_HEADER_SPLIT_CONTROL_EXTENT	 = 0x8,
	PSIF_TRACE_SAMPLE_SOURCE_EXTENT	 = 0x4,
	PSIF_TRACE_BUFFER_ALLOCATION_EXTENT	 = 0x4,
	PSIF_TRACE_BUFFER_MODE_EXTENT	 = 0x2,
	PSIF_TRACE_BUFFER_STATUS_EXTENT	 = 0x4,
	PSIF_TSU_ERROR_TYPES_EXTENT	 = 0x7c,
	PSIF_WR_TYPE_EXTENT	 = 0x93,
	PSIF_USE_AH_EXTENT	 = 0x2,
	PSIF_TSU_QOS_EXTENT	 = 0x2,
	PSIF_WC_STATUS_EXTENT	 = 0x16,
	PSIF_WC_OPCODE_EXTENT	 = 0x82,
	PSIF_TABLE_LEVEL_EXTENT	 = 0x6,
	PSIF_RB_TYPE_EXTENT	 = 0x7,
	PSIF_EPS_A_CORE_EXTENT	 = 0x4,
	PSIF_CMPL_OUTSTANDING_ERROR_EXTENT	 = 0x8,
	PSIF_EXPECTED_OP_EXTENT	 = 0x4,
	PSIF_MIGRATION_EXTENT	 = 0x4,
	PSIF_QP_TRANS_EXTENT	 = 0x8,
	PSIF_COMM_LIVE_EXTENT	 = 0x2,
	PSIF_BOOL_EXTENT	 = 0x2,
	PSIF_USE_GRH_EXTENT	 = 0x2,
	PSIF_LOOPBACK_EXTENT	 = 0x2,
	PSIF_PCIE_WR_OFFS_EXTENT	 = 0x1000,
	PSIF_MBOX_TYPE_EXTENT	 = 0x6,
	PSIF_DMA_VT_KEY_STATES_EXTENT	 = 0x4,
	PSIF_FLASH_IMAGE_TYPE_EXTENT	 = 0x5,
	PSIF_PORT_FLAGS_EXTENT	 = 0x9,
	PSIF_EPS_CORE_ID_EXTENT	 = 0x5,
	PSIF_EPSC_LOG_MODE_EXTENT	 = 0x11,
	PSIF_EPSC_LOG_LEVEL_EXTENT	 = 0x8,
	PSIF_EPSC_PORT_STATE_EXTENT	 = 0x6,
	PSIF_EPSC_PATH_MTU_EXTENT	 = 0x7,
	PSIF_EPSC_MONITOR_EXTENT	 = 0x5,
	PSIF_EPSC_INTERRUPT_SOURCE_EXTENT	 = 0x14,
	PSIF_EPSC_INTERRUPT_PRI_EXTENT	 = 0x4,
	PSIF_EPSC_ATOMIC_CAP_EXTENT	 = 0x3,
	PSIF_EPSC_CSR_STATUS_EXTENT	 = 0x100,
	PSIF_EPSC_CSR_OPCODE_EXTENT	 = 0x39,
	PSIF_EPSC_CSR_FLAGS_EXTENT	 = 0x2,
	PSIF_EPSC_CSR_MODIFY_DEVICE_FLAGS_EXTENT	 = 0x3,
	PSIF_EPSC_CSR_MODIFY_PORT_FLAGS_EXTENT	 = 0x11,
	PSIF_EPSC_CSR_TRACE_CONTROL_EXTENT	 = 0x20,
	PSIF_IB_LINK_SPEED_EXTENT	 = 0x4,
	PSIF_IB_LINK_WIDTH_EXTENT	 = 0x2,
	PSIF_EPSC_CSR_EPSA_COMMAND_EXTENT	 = 0x4,
	PSIF_CQ_STATE_EXTENT	 = 0x4,
	PSIF_RSS_HASH_SOURCE_EXTENT	 = 0x2
}psif_enum_extent_t; /* psif_enum_extent_t [16 bits] */

/* MMU operation modes. *//* Extent 3 bit */
typedef enum {
	MMU_PASS_THROUGH0,
	MMU_PASS_THROUGH_PAD,
	MMU_GVA2GPA_MODE,
	MMU_GVA2GPA_MODE_PAD,
	MMU_PRETRANSLATED,
	MMU_PRETRANSLATED_PAD,
	MMU_EPSA_MODE,
	MMU_EPSC_MODE
}psif_mmu_translation_t; /* enum psif_mmu_translation [ 3 bits] */

/*
 * Enumeration for the different supported page sizes. XXX: Define the page
 * sizes
 *//* Extent 4 bit */
typedef enum {
	PAGE_SIZE_IA32E_4KB	 = 0,
	PAGE_SIZE_IA32E_2MB	 = 0x1,
	PAGE_SIZE_IA32E_1GB	 = 0x2,
	PAGE_SIZE_S64_8KB	 = 0x8,
	PAGE_SIZE_S64_64KB	 = 0x9,
	PAGE_SIZE_S64_512KB	 = 0xa,
	PAGE_SIZE_S64_4MB	 = 0xb,
	PAGE_SIZE_S64_32MB	 = 0xc,
	PAGE_SIZE_S64_2GB	 = 0xd,
	PAGE_SIZE_S64_16GB	 = 0xe
}psif_page_size_t; /* enum psif_page_size [ 4 bits] */

/* Commands used for modify/query QP. *//* Extent 2 bit */
typedef enum {
	QP_CMD_INVALID	 = 0,
	QP_CMD_MODIFY	 = 0x1,
	QP_CMD_QUERY	 = 0x2,
	QP_CMD_CHECK_TIMEOUT	 = 0x3
}psif_qp_command_t; /* enum psif_qp_command [ 2 bits] */

/* Port number the IB packet is transimitted on. *//* Extent 1 bit */
typedef enum {
	PORT_1	 = 0,
	PORT_2	 = 0x1
}psif_port_t; /* enum psif_port [ 1 bits] */

/* This is the state this QP is in. *//* Extent 3 bit */
typedef enum {
	PSIF_QP_STATE_RESET	 = 0,
	PSIF_QP_STATE_INIT	 = 0x1,
	PSIF_QP_STATE_RTR	 = 0x2,
	PSIF_QP_STATE_RTS	 = 0x3,
	PSIF_QP_STATE_SQERR	 = 0x5,
	PSIF_QP_STATE_ERROR	 = 0x6,
	PSIF_QP_STATE_INVALID	 = 0x7
}psif_qp_state_t; /* enum psif_qp_state [ 3 bits] */

/*
 * Hardware status enumerations for modify and query. It is explicitly
 * indicated when status applies to query. MODIFY_SUCCESS - used for both
 * query and modify. MODIFY_QP_OUT_OF_RANGE - used for both query and modify.
 * MODIFY_QP_INVALID - used for both query and modify.
 * MODIFY_CANNOT_CHANGE_QP_ATTR, MODIFY_INVALID_QP_STATE,
 * MODIFY_INVALID_MIG_STATE, MODIFY_OPERATION_IN_PROGRESS
 *//* Extent 3 bit */
typedef enum {
	MODIFY_SUCCESS,
	MODIFY_QP_OUT_OF_RANGE,
	MODIFY_QP_INVALID,
	MODIFY_CANNOT_CHANGE_QP_ATTR,
	MODIFY_INVALID_QP_STATE,
	MODIFY_INVALID_MIG_STATE,
	MODIFY_OPERATION_IN_PROGRESS
}psif_modify_status_t; /* enum psif_modify_status [ 3 bits] */

/*
 * What is the status of an event. // affiliated async
 * PSIF_EVENT_PATH_MIGRATED PSIF_EVENT_COMMUNICATION_ESTABLISHED
 * PSIF_EVENT_SRQ_LIMIT_REACHED PSIF_EVENT_LAST_WQE_REACHED // affiliated
 * async error PSIF_EVENT_CQ_ERROR PSIF_EVENT_INVALID_REQUEST_LOCAL_WQ_ERROR
 * PSIF_EVENT_LOCAL_ACCESS_VIOLATION_WORK_QUEUE_ERROR
 * PSIF_EVENT_PATH_MIGRATION_REQUEST_ERROR PSIF_EVENT_XRC_DOMAIN_VIOLATION
 * PSIF_EVENT_INVALID_XRCETH PSIF_EVENT_SRQ_CATASTROPHIC_ERROR
 * PSIF_EVENT_LOCAL_WORK_QUEUE_CATASTROPHIC_ERROR // unaffiliated async
 * PSIF_EVENT_PORT_ACTIVE PSIF_EVENT_CLIENT_REGISTRATION
 * PSIF_EVENT_PORT_CHANGED // unaffiliated async error
 * PSIF_EVENT_LOCAL_CATASTROPHIC_ERROR PSIF_EVENT_PORT_ERROR //Completion
 * events PSIF_EVENT_CMPL_NOTIFY, PSIF_EVENT_RB_NOTIFY // EPS events
 * PSIF_EVENT_EPS_C PSIF_EVENT_EPS_A
 *//* Extent 8 bit */
typedef enum {
	PSIF_EVENT_PATH_MIGRATED,
	PSIF_EVENT_COMMUNICATION_ESTABLISHED,
	PSIF_EVENT_SRQ_LIMIT_REACHED,
	PSIF_EVENT_LAST_WQE_REACHED,
	PSIF_EVENT_CQ_ERROR,
	PSIF_EVENT_INVALID_REQUEST_LOCAL_WQ_ERROR,
	PSIF_EVENT_LOCAL_ACCESS_VIOLATION_WORK_QUEUE_ERROR,
	PSIF_EVENT_PATH_MIGRATION_REQUEST_ERROR,
	PSIF_EVENT_XRC_DOMAIN_VIOLATION,
	PSIF_EVENT_INVALID_XRCETH,
	PSIF_EVENT_SRQ_CATASTROPHIC_ERROR,
	PSIF_EVENT_LOCAL_WORK_QUEUE_CATASTROPHIC_ERROR,
	PSIF_EVENT_PORT_ACTIVE,
	PSIF_EVENT_CLIENT_REGISTRATION,
	PSIF_EVENT_PORT_CHANGED,
	PSIF_EVENT_LOCAL_CATASTROPHIC_ERROR,
	PSIF_EVENT_PORT_ERROR,
	PSIF_EVENT_CMPL_NOTIFY,
	PSIF_EVENT_RB_NOTIFY,
	PSIF_EVENT_EPS_C,
	PSIF_EVENT_EPS_A,
	/* Padding out to required bits allocated */
	PSIF_EVENT_STATUS_FIELD_MAX	 = 0xff
}psif_event_status_t; /* enum psif_event_status [ 8 bits] */

/* What type of event is this. *//* Extent 4 bit */
typedef enum {
	PSIF_EVENT_AFFILIATED_ASYNC,
	PSIF_EVENT_UNAFFILIATED_ASYNC,
	PSIF_EVENT_AFFILIATED_ASYNC_ERROR,
	PSIF_EVENT_UNAFFILIATED_ASYNC_ERROR,
	PSIF_EVENT_COMPLETION,
	PSIF_EVENT_COMPLETION_ERROR,
	PSIF_EVENT_MAILBOX,
	/* Padding out to required bits allocated */
	PSIF_EVENT_TYPE_FIELD_MAX	 = 0xf
}psif_event_type_t; /* enum psif_event_type [ 4 bits] */

/* Definitions for the different supported MTU sizes. *//* Extent 3 bit */
typedef enum {
	MTU_INVALID	 = 0,
	MTU_256B	 = 0x1,
	MTU_512B	 = 0x2,
	MTU_1024B	 = 0x3,
	MTU_2048B	 = 0x4,
	MTU_4096B	 = 0x5,
	MTU_XXX	 = 0x6
}psif_path_mtu_t; /* enum psif_path_mtu [ 3 bits] */

/* Enumeration for the different supported portsample counter types *//* Extent 7 bit */
typedef enum {
	SAMPLE_XMIT_DATA	 = 0x1,
	SAMPLE_RCV_DATA	 = 0x2,
	SAMPLE_XMIT_PKTS	 = 0x3,
	SAMPLE_RCV_PKTS	 = 0x4,
	SAMPLE_XMIT_WAIT	 = 0x5,
	SAMPLE_XMIT_DATA_VL_N	 = 0x21,
	SAMPLE_OP_RCV_PKTS	 = 0x2f,
	SAMPLE_OP_RCV_DATA	 = 0x30,
	SAMPLE_VL_OP_RCV_DATA_N	 = 0x34,
	SAMPLE_XMIT_PKTS_DROP_NOTACTIVE	 = 0x40,
	SAMPLE_XMIT_PKTS_DROP_BAD	 = 0x41,
	SAMPLE_RCV_PKTS_DROP_FWDERR	 = 0x42,
	SAMPLE_RCV_PKTS_DROP_SMP_NOTALWD	 = 0x43,
	SAMPLE_RCV_PKTS_DROP_NOTACTIVE	 = 0x44,
	SAMPLE_RCV_PKTS_DROP_BAD	 = 0x45,
	SAMPLE_RCV_MCAST_ERR	 = 0x46,
	SAMPLE_RCV_MCAST_OVF	 = 0x47
}psif_port_samplecounter_type_t; /* enum psif_port_samplecounter_type [ 7 bits] */

/* Extent 8 bit */
typedef enum {
	RC_SEND_First	 = 0,
	RC_SEND_Middle	 = 0x1,
	RC_SEND_Last	 = 0x2,
	RC_SEND_Last_Imm	 = 0x3,
	RC_SEND_Only	 = 0x4,
	RC_SEND_Only_Imm	 = 0x5,
	RC_RDMA_WR_First	 = 0x6,
	RC_RDMA_WR_Middle	 = 0x7,
	RC_RDMA_WR_Last	 = 0x8,
	RC_RDMA_WR_Last_Imm	 = 0x9,
	RC_RDMA_WR_Only	 = 0xa,
	RC_RDMA_WR_Only_Imm	 = 0xb,
	RC_RDMA_RD_Req	 = 0xc,
	RC_RDMA_RD_Resp_First	 = 0xd,
	RC_RDMA_RD_Resp_Middle	 = 0xe,
	RC_RDMA_RD_Resp_Last	 = 0xf,
	RC_RDMA_RD_Resp_Only	 = 0x10,
	RC_ACK	 = 0x11,
	RC_Atomic_ACK	 = 0x12,
	RC_CmpSwap	 = 0x13,
	RC_FetchAdd	 = 0x14,
	RC_Reserved	 = 0x15,
	RC_SEND_Last_Invalid	 = 0x16,
	RC_SEND_Only_Invalid	 = 0x17,
	RC_MaskCmpSwap	 = 0x18,
	RC_MaskFetchAdd	 = 0x19,
	UC_SEND_First	 = 0x20,
	UC_SEND_Middle	 = 0x21,
	UC_SEND_Last	 = 0x22,
	UC_SEND_Last_Imm	 = 0x23,
	UC_SEND_Only	 = 0x24,
	UC_SEND_Only_Imm	 = 0x25,
	UC_RDMA_WR_First	 = 0x26,
	UC_RDMA_WR_Middle	 = 0x27,
	UC_RDMA_WR_Last	 = 0x28,
	UC_RDMA_WR_Last_Imm	 = 0x29,
	UC_RDMA_WR_Only	 = 0x2a,
	UC_RDMA_WR_Only_Imm	 = 0x2b,
	RD_SEND_First	 = 0x40,
	RD_SEND_Middle	 = 0x41,
	RD_SEND_Last	 = 0x42,
	RD_SEND_Last_Imm	 = 0x43,
	RD_SEND_Only	 = 0x44,
	RD_SEND_Only_Imm	 = 0x45,
	RD_RDMA_WR_First	 = 0x46,
	RD_RDMA_WR_Middle	 = 0x47,
	RD_RDMA_WR_Last	 = 0x48,
	RD_RDMA_WR_Last_Imm	 = 0x49,
	RD_RDMA_WR_Only	 = 0x4a,
	RD_RDMA_WR_Only_Imm	 = 0x4b,
	RD_RDMA_RD_Req	 = 0x4c,
	RD_RDMA_RD_Resp_First	 = 0x4d,
	RD_RDMA_RD_Resp_Middle	 = 0x4e,
	RD_RDMA_RD_Resp_Last	 = 0x4f,
	RD_RDMA_RD_Resp_Only	 = 0x50,
	RD_ACK	 = 0x51,
	RD_Atomic_ACK	 = 0x52,
	RD_CmpSwap	 = 0x53,
	RD_FetchAdd	 = 0x54,
	RD_RESYNC	 = 0x55,
	UD_SEND_Only	 = 0x64,
	UD_SEND_Only_Imm	 = 0x65,
	CNP	 = 0x80,
	XRC_SEND_First	 = 0xa0,
	XRC_SEND_Middle	 = 0xa1,
	XRC_SEND_Last	 = 0xa2,
	XRC_SEND_Last_Imm	 = 0xa3,
	XRC_SEND_Only	 = 0xa4,
	XRC_SEND_Only_Imm	 = 0xa5,
	XRC_RDMA_WR_First	 = 0xa6,
	XRC_RDMA_WR_Middle	 = 0xa7,
	XRC_RDMA_WR_Last	 = 0xa8,
	XRC_RDMA_WR_Last_Imm	 = 0xa9,
	XRC_RDMA_WR_Only	 = 0xaa,
	XRC_RDMA_WR_Only_Imm	 = 0xab,
	XRC_RDMA_RD_Req	 = 0xac,
	XRC_RDMA_RD_Resp_First	 = 0xad,
	XRC_RDMA_RD_Resp_Middle	 = 0xae,
	XRC_RDMA_RD_Resp_Last	 = 0xaf,
	XRC_RDMA_RD_Resp_Only	 = 0xb0,
	XRC_ACK	 = 0xb1,
	XRC_Atomic_ACK	 = 0xb2,
	XRC_CmpSwap	 = 0xb3,
	XRC_FetchAdd	 = 0xb4,
	XRC_Reserved	 = 0xb5,
	XRC_SEND_Last_Invalid	 = 0xb6,
	XRC_SEND_Only_Invalid	 = 0xb7,
	XRC_MaskCmpSwap	 = 0xb8,
	XRC_MaskFetchAdd	 = 0xb9,
	MANSP1_INVALID	 = 0xc0,
	MANSP1_HOST_READ	 = 0xc1,
	MANSP1_HOST_WRITE	 = 0xc2,
	MANSP1_INTERNAL_TYPE	 = 0xc3,
	MANSP1_HOST_CMP_SWAP	 = 0xc4,
	MANSP1_DR_LOOPBACK	 = 0xc5
}ib_opcode_t; /* enum ib_opcode [ 8 bits] */

/*
 * Link states for the virtual HCA and switch. The following onehot encoded
 * states exist: PSIF_LINK_DISABLED = 1 PSIF_LINK_DOWN = 2 PSIF_LINK_INIT = 4
 * PSIF_LINK_ARM = 8 PSIF_LINK_ACTIVE = 16
 *//* Extent 5 bit */
typedef enum {
	PSIF_LINK_DISABLED	 = 0x1,
	PSIF_LINK_DOWN	 = 0x2,
	PSIF_LINK_INIT	 = 0x4,
	PSIF_LINK_ARM	 = 0x8,
	PSIF_LINK_ACTIVE	 = 0x10
}psif_vlink_state_t; /* enum psif_vlink_state [ 5 bits] */

/*
 * 0x0 HDR_SPLIT_NONE No Header Data Split enabled 0x4 HDR_SPLIT_ENCAP
 * Attempt to split after Encapsulation header 0x5 HDR_SPLIT_L2 Attempt to
 * split after L2 header 0x6 HDR_SPLIT_L3 Attempt to split after IPv4 / IPv6
 * header 0x7 HDR_SPLIT_L4 Attempt to split after TCP / UDP header.
 *//* Extent 3 bit */
typedef enum {
	HDR_SPLIT_NONE,
	HDR_SPLIT_ENCAP	 = 0x4,
	HDR_SPLIT_L2,
	HDR_SPLIT_L3,
	HDR_SPLIT_L4
}psif_header_split_control_t; /* enum psif_header_split_control [ 3 bits] */

/* Extent 2 bit */
typedef enum {
	RCV0	 = 0,
	RCV1	 = 0x1,
	XMIT0	 = 0x2,
	XMIT1	 = 0x3
}psif_trace_sample_source_t; /* enum psif_trace_sample_source [ 2 bits] */

/* Extent 2 bit */
typedef enum {
	POST_STORE_0	 = 0,
	POST_STORE_25	 = 0x1,
	POST_STORE_50	 = 0x2,
	POST_STORE_75	 = 0x3
}psif_trace_buffer_allocation_t; /* enum psif_trace_buffer_allocation [ 2 bits] */

/* Extent 1 bit */
typedef enum {
	NORMAL_MODE	 = 0,
	TRACE_MODE	 = 0x1
}psif_trace_buffer_mode_t; /* enum psif_trace_buffer_mode [ 1 bits] */

/* Extent 2 bit */
typedef enum {
	TRACE_IDLE	 = 0,
	WAIT_TRIGGER	 = 0x1,
	POST_STORE	 = 0x2,
	TRACE_DONE	 = 0x3
}psif_trace_buffer_status_t; /* enum psif_trace_buffer_status [ 2 bits] */

/*
 * Enumerations of error types. The following error types are defined for the
 * TSU: TSU_NO_ERROR = 8'h0 TSU_IBPR_ICRC_ERR TSU_IBPR_PARITY_ERR
 * TSU_IBPR_INVALID_PKEY_ERR TSU_IBPR_INVALID_QP_ERR TSU_IBPR_VSWITCH_UF_ERR
 * TSU_IBPR_UNDEFINED_OPCODE_ERR TSU_IBPR_ILLEGAL_MAC_ERR
 * TSU_IBPR_ILLEGAL_VLAN_TAG_ERR TSU_IBPR_MCAST_NO_GRH_ERR
 * TSU_IBPR_MCAST_NO_TARGET_ERR TSU_IBPR_INVALID_DGID_ERR TSU_IBPR_BADPKT_ERR
 * TSU_RCV_QP_CAP_DM_PUT_ENABLE_ERR TSU_RCV_QP_CAP_RSS_ENABLE_ERR
 * TSU_RCV_QP_CAP_MASKED_ATOMIC_ENABLE_ERR TSU_RCV_QP_CAP_RDMA_RD_ENABLE_ERR
 * TSU_RCV_QP_CAP_RDMA_WR_ENABLE_ERR TSU_RCV_QP_CAP_ATOMIC_ENABLE_ERR
 * TSU_RCV_QP_INVALID_ERR TSU_RCV_HDR_BTH_TVER_ERR TSU_RCV_HDR_BTH_QP_ERR
 * TSU_RCV_HDR_RD_EE_ERR TSU_RCV_HDR_BTH_RD_QP_ERR TSU_RCV_HDR_GRH_ERR
 * TSU_RCV_HDR_PKEY_ERR TSU_RCV_HDR_QKEY_ERR TSU_RCV_HDR_LID_ERR
 * TSU_RCV_HDR_MCAST_ERR TSU_RCV_HDR_MAD_ERR TSU_RCV_EOIB_MCAST_ERR
 * TSU_RCV_EOIB_BCAST_ERR TSU_RCV_EOIB_UCAST_ERR TSU_RCV_EOIB_FRAGMENT_ERR
 * TSU_RCV_EOIB_RUNTS_ERR TSU_RCV_EOIB_OUTER_VLAN_ERR
 * TSU_RCV_EOIB_VLAN_TAG_ERR TSU_RCV_EOIB_VID_ERR
 * TSU_DSCR_RESPONDER_RC_PSN_ERR TSU_DSCR_RESPONDER_RC_DUPLICATE
 * TSU_DSCR_RESPONDER_RC_OPCODE_SEQ_ERR TSU_DSCR_RESPONDER_RC_OPCODE_VAL_ERR
 * TSU_DSCR_RESPONDER_RC_OPCODE_LEN_ERR TSU_DSCR_RESPONDER_RC_DMALEN_ERR
 * TSU_DSCR_RESPONDER_XRC_PSN_ERR TSU_DSCR_RESPONDER_XRC_DUPLICATE
 * TSU_DSCR_RESPONDER_XRC_OPCODE_SEQ_ERR
 * TSU_DSCR_RESPONDER_XRC_OPCODE_VAL_ERR
 * TSU_DSCR_RESPONDER_XRC_OPCODE_LEN_ERR TSU_DSCR_RESPONDER_XRC_DMALEN_ERR
 * TSU_DSCR_RESPONDER_UC_PSN_ERR TSU_DSCR_RESPONDER_UC_OPCODE_SEQ_ERR
 * TSU_DSCR_RESPONDER_UC_OPCODE_VAL_ERR TSU_DSCR_RESPONDER_UC_OPCODE_LEN_ERR
 * TSU_DSCR_RESPONDER_UC_DMALEN_ERR TSU_DSCR_RESPONDER_UD_OPCODE_LEN_ERR
 * TSU_DSCR_CQ_INVALID_ERR TSU_DSCR_CQ_FULL_ERR TSU_DSCR_CQ_IS_PROXY_ERR
 * TSU_DSCR_XRC_DOMAIN_VIOLATION_ERR TSU_DSCR_XRCETH_ERR
 * TSU_DSCR_RQ_INVALID_ERR TSU_DSCR_RQ_PD_CHECK_ERR TSU_DSCR_RQ_EMPTY_ERR
 * TSU_DSCR_PCIE_ERR TSU_DSCR_NO_RQE_IN_PROGRESS TSU_RQH_PCIE_ERR
 * TSU_RQH_SGL_LENGTH_ERR TSU_RQH_SGL_LKEY_ERR
 * TSU_RQH_NOT_ENOUGH_RQ_SPACE_ERR TSU_RQH_NO_RQE_IN_PROGRESS
 * TSU_VAL_RKEY_VLD_ERR TSU_VAL_RKEY_ADDR_RANGE_ERR TSU_VAL_RKEY_ACCESS_ERR
 * TSU_VAL_RKEY_PD_ERR TSU_VAL_RKEY_RANGE_ERR TSU_VAL_LKEY_VLD_ERR
 * TSU_VAL_LKEY_ADDR_RANGE_ERR TSU_VAL_LKEY_ACCESS_ERR TSU_VAL_LKEY_PD_ERR
 * TSU_VAL_LKEY_RANGE_ERR TSU_VAL_PCIE_ERR TSU_MMU_PTW_ERR TSU_MMU_UF_ERR
 * TSU_MMU_AC_ERR TSU_RQS_QP_CONSISTENCY_ERR TSU_RQS_CHECKSUM_ERR
 * TSU_RQS_SEQNUM_ERR TSU_RQS_INVALID_REQUEST_ERR
 * TSU_RQS_QP_IN_WRONG_STATE_ERR TSU_RQS_CMD_FROM_EPS_ERR
 * TSU_RQS_SQ_FLUSH_ERR TSU_RQS_LSO_EOIB_ERR TSU_RQS_SMP_NOT_AUTH_ERR
 * TSU_RQS_REQUEST_FENCED_ERR TSU_RQS_MAX_OUTSTANDING_REACHED_ERR
 * TSU_DMA_SGL_RD_ERR TSU_DMA_PYLD_RD_ERR TSU_DMA_SGL_LENGTH_ERR
 * TSU_DMA_LKEY_ERR TSU_DMA_RKEY_ERR TSU_DMA_LSO_PKTLEN_ERR
 * TSU_DMA_LSO_ILLEGAL_CLASSIFICATION_ERR TSU_DMA_PCIE_ERR
 * TSU_CMPL_REQUESTER_PSN_ERR TSU_CMPL_REQUESTER_SYNDROME_ERR
 * TSU_CMPL_REQUESTER_OUTSTANDING_MATCH_ERR TSU_CMPL_REQUESTER_LEN_ERR
 * TSU_CMPL_REQUESTER_UNEXP_OPCODE_ERR TSU_CMPL_REQUESTER_DUPLICATE
 * TSU_CMPL_RC_IN_ERROR_ERR TSU_CMPL_NAK_RNR_ERR TSU_CMPL_NAK_SEQUENCE_ERR
 * TSU_CMPL_NAK_INVALID_REQUEST_ERR TSU_CMPL_NAK_REMOTE_ACCESS_ERR
 * TSU_CMPL_NAK_REMOTE_OPS_ERR TSU_CMPL_NAK_INVALID_RD_REQUEST_ERR
 * TSU_CMPL_TIMEOUT_ERR TSU_CMPL_IMPLIED_NAK TSU_CMPL_GHOST_RESP_ERR
 *//* Extent 8 bit */
typedef enum {
	TSU_NO_ERROR	 = 0,
	TSU_IBPR_ICRC_ERR,
	TSU_IBPR_PARITY_ERR,
	TSU_IBPR_INVALID_PKEY_ERR,
	TSU_IBPR_INVALID_QP_ERR,
	TSU_IBPR_VSWITCH_UF_ERR,
	TSU_IBPR_UNDEFINED_OPCODE_ERR,
	TSU_IBPR_ILLEGAL_MAC_ERR,
	TSU_IBPR_ILLEGAL_VLAN_TAG_ERR,
	TSU_IBPR_MCAST_NO_GRH_ERR,
	TSU_IBPR_MCAST_NO_TARGET_ERR,
	TSU_IBPR_INVALID_DGID_ERR,
	TSU_IBPR_BADPKT_ERR,
	TSU_RCV_QP_CAP_DM_PUT_ENABLE_ERR,
	TSU_RCV_QP_CAP_RSS_ENABLE_ERR,
	TSU_RCV_QP_CAP_MASKED_ATOMIC_ENABLE_ERR,
	TSU_RCV_QP_CAP_RDMA_RD_ENABLE_ERR,
	TSU_RCV_QP_CAP_RDMA_WR_ENABLE_ERR,
	TSU_RCV_QP_CAP_ATOMIC_ENABLE_ERR,
	TSU_RCV_QP_INVALID_ERR,
	TSU_RCV_HDR_BTH_TVER_ERR,
	TSU_RCV_HDR_BTH_QP_ERR,
	TSU_RCV_HDR_GRH_ERR,
	TSU_RCV_HDR_PKEY_ERR,
	TSU_RCV_HDR_QKEY_ERR,
	TSU_RCV_HDR_LID_ERR,
	TSU_RCV_HDR_MAD_ERR,
	TSU_RCV_EOIB_MCAST_ERR,
	TSU_RCV_EOIB_BCAST_ERR,
	TSU_RCV_EOIB_UCAST_ERR,
	TSU_RCV_EOIB_FRAGMENT_ERR,
	TSU_RCV_EOIB_RUNTS_ERR,
	TSU_RCV_EOIB_OUTER_VLAN_ERR,
	TSU_RCV_EOIB_VLAN_TAG_ERR,
	TSU_RCV_EOIB_VID_ERR,
	TSU_RCV_MCAST_DUP_ERR,
	TSU_DSCR_RESPONDER_RC_PSN_ERR,
	TSU_DSCR_RESPONDER_RC_DUPLICATE,
	TSU_DSCR_RESPONDER_RC_OPCODE_SEQ_ERR,
	TSU_DSCR_RESPONDER_RC_OPCODE_VAL_ERR,
	TSU_DSCR_RESPONDER_RC_OPCODE_LEN_ERR,
	TSU_DSCR_RESPONDER_RC_DMALEN_ERR,
	TSU_DSCR_RESPONDER_XRC_PSN_ERR,
	TSU_DSCR_RESPONDER_XRC_DUPLICATE,
	TSU_DSCR_RESPONDER_XRC_OPCODE_SEQ_ERR,
	TSU_DSCR_RESPONDER_XRC_OPCODE_VAL_ERR,
	TSU_DSCR_RESPONDER_XRC_OPCODE_LEN_ERR,
	TSU_DSCR_RESPONDER_XRC_DMALEN_ERR,
	TSU_DSCR_RESPONDER_UC_PSN_ERR,
	TSU_DSCR_RESPONDER_UC_OPCODE_SEQ_ERR,
	TSU_DSCR_RESPONDER_UC_OPCODE_VAL_ERR,
	TSU_DSCR_RESPONDER_UC_OPCODE_LEN_ERR,
	TSU_DSCR_RESPONDER_UC_DMALEN_ERR,
	TSU_DSCR_RESPONDER_UD_OPCODE_LEN_ERR,
	TSU_DSCR_RESPONDER_DUPLICATE_WITH_ERR,
	TSU_DSCR_CQ_INVALID_ERR,
	TSU_DSCR_CQ_FULL_ERR,
	TSU_DSCR_CQ_IS_PROXY_ERR,
	TSU_DSCR_XRC_DOMAIN_VIOLATION_ERR,
	TSU_DSCR_XRCETH_ERR,
	TSU_DSCR_RQ_INVALID_ERR,
	TSU_DSCR_RQ_PD_CHECK_ERR,
	TSU_DSCR_RQ_EMPTY_ERR,
	TSU_DSCR_RQ_IN_ERROR_ERR,
	TSU_DSCR_PCIE_ERR,
	TSU_DSCR_NO_RQE_IN_PROGRESS,
	TSU_RQH_PCIE_ERR,
	TSU_RQH_SGL_LENGTH_ERR,
	TSU_RQH_SGL_LKEY_ERR,
	TSU_RQH_NOT_ENOUGH_RQ_SPACE_ERR,
	TSU_RQH_NO_RQE_IN_PROGRESS,
	TSU_VAL_DUPLICATE_WITH_ERR,
	TSU_VAL_RKEY_VLD_ERR,
	TSU_VAL_RKEY_ADDR_RANGE_ERR,
	TSU_VAL_RKEY_ACCESS_ERR,
	TSU_VAL_RKEY_PD_ERR,
	TSU_VAL_RKEY_RANGE_ERR,
	TSU_VAL_LKEY_VLD_ERR,
	TSU_VAL_LKEY_ADDR_RANGE_ERR,
	TSU_VAL_LKEY_ACCESS_ERR,
	TSU_VAL_LKEY_PD_ERR,
	TSU_VAL_LKEY_RANGE_ERR,
	TSU_VAL_PCIE_ERR,
	TSU_MMU_DUPLICATE_WITH_ERR,
	TSU_MMU_PTW_ERR,
	TSU_MMU_UF_ERR,
	TSU_MMU_AC_ERR,
	TSU_HOST_DUPLICATE_WITH_ERR,
	TSU_RQS_QP_CONSISTENCY_ERR,
	TSU_RQS_CHECKSUM_ERR,
	TSU_RQS_SEQNUM_ERR,
	TSU_RQS_INVALID_REQUEST_ERR,
	TSU_RQS_QP_IN_WRONG_STATE_ERR,
	TSU_RQS_CMD_FROM_EPS_ERR,
	TSU_RQS_SQ_FLUSH_ERR,
	TSU_RQS_LSO_EOIB_ERR,
	TSU_RQS_SMP_NOT_AUTH_ERR,
	TSU_RQS_REQUEST_FENCED_ERR,
	TSU_RQS_MAX_OUTSTANDING_REACHED_ERR,
	TSU_DMA_SGL_RD_ERR,
	TSU_DMA_PYLD_RD_ERR,
	TSU_DMA_SGL_LENGTH_ERR,
	TSU_DMA_LKEY_ERR,
	TSU_DMA_RKEY_ERR,
	TSU_DMA_LSO_PKTLEN_ERR,
	TSU_DMA_LSO_ILLEGAL_CLASSIFICATION_ERR,
	TSU_DMA_PCIE_ERR,
	TSU_CMPL_PCIE_ERR,
	TSU_CMPL_REQUESTER_PSN_ERR,
	TSU_CMPL_REQUESTER_SYNDROME_ERR,
	TSU_CMPL_REQUESTER_OUTSTANDING_MATCH_ERR,
	TSU_CMPL_REQUESTER_LEN_ERR,
	TSU_CMPL_REQUESTER_UNEXP_OPCODE_ERR,
	TSU_CMPL_REQUESTER_DUPLICATE,
	TSU_CMPL_RC_IN_ERROR_ERR,
	TSU_CMPL_NAK_RNR_ERR,
	TSU_CMPL_NAK_SEQUENCE_ERR,
	TSU_CMPL_NAK_INVALID_REQUEST_ERR,
	TSU_CMPL_NAK_REMOTE_ACCESS_ERR,
	TSU_CMPL_NAK_REMOTE_OPS_ERR,
	TSU_CMPL_NAK_INVALID_RD_REQUEST_ERR,
	TSU_CMPL_TIMEOUT_ERR,
	TSU_CMPL_IMPLIED_NAK,
	TSU_CMPL_GHOST_RESP_ERR,
	/* Padding out to required bits allocated */
	PSIF_TSU_ERROR_TYPES_FIELD_MAX	 = 0xff
}psif_tsu_error_types_t; /* enum psif_tsu_error_types [ 8 bits] */

/*
 * These are the different work request opcodes supported by PSIF.
 * PSIF_WR_ENTER_SQ_MODE and PSIF_WR_CANCEL_CMD are special opcodes only used
 * when writing to a special offset of the VCBs. RQS must check that the
 * PSIF_WR_SEND_EPS and PSIF_WR_SEND_EPS_DR really comes from the EPS. CBU
 * must report the source of a WR to RQS.
 *//* Extent 8 bit */
typedef enum {
	PSIF_WR_SEND,
	PSIF_WR_SEND_IMM,
	PSIF_WR_SPECIAL_QP_SEND,
	PSIF_WR_QP0_SEND_DR_XMIT,
	PSIF_WR_QP0_SEND_DR_LOOPBACK,
	PSIF_WR_EPS_SPECIAL_QP_SEND,
	PSIF_WR_EPS_QP0_SEND_DR_XMIT,
	PSIF_WR_EPS_QP0_SEND_DR_LOOPBACK,
	PSIF_WR_RDMA_WR,
	PSIF_WR_RDMA_WR_IMM,
	PSIF_WR_RDMA_RD,
	PSIF_WR_CMP_SWAP,
	PSIF_WR_FETCH_ADD,
	PSIF_WR_MASK_CMP_SWAP,
	PSIF_WR_MASK_FETCH_ADD,
	PSIF_WR_LSO,
	PSIF_WR_DM_PUT,
	PSIF_WR_DM_GET,
	PSIF_WR_INVALIDATE_RKEY	 = 0x80,
	PSIF_WR_INVALIDATE_LKEY,
	PSIF_WR_INVALIDATE_BOTH_KEYS,
	PSIF_WR_INVALIDATE_TLB,
	PSIF_WR_RESIZE_CQ,
	PSIF_WR_SET_SRQ_LIM,
	PSIF_WR_SET_XRCSRQ_LIM,
	PSIF_WR_REQ_CMPL_NOTIFY,
	PSIF_WR_CMPL_NOTIFY_RCVD,
	PSIF_WR_REARM_CMPL_EVENT,
	PSIF_WR_REQ_RB_NOTIFY,
	PSIF_WR_RB_NOTIFY_RCVD,
	PSIF_WR_REARM_RB_EVENT,
	PSIF_WR_GENERATE_COMPLETION,
	PSIF_WR_INVALIDATE_RQ,
	PSIF_WR_INVALIDATE_CQ,
	PSIF_WR_INVALIDATE_RB,
	PSIF_WR_INVALIDATE_XRCSRQ,
	PSIF_WR_INVALIDATE_SGL_CACHE
}psif_wr_type_t; /* enum psif_wr_type [ 8 bits] */

/*
 * Enumeration for using AHA or not. When set, AHA should be used instead of
 * information from the QP state in appropriate places.
 *//* Extent 1 bit */
typedef enum {
	NO_AHA	 = 0,
	USE_AHA	 = 0x1
}psif_use_ah_t; /* enum psif_use_ah [ 1 bits] */

/*
 * Indicating if this QP is configured as a high bandwidth or a low latency
 * QP.
 *//* Extent 1 bit */
typedef enum {
	QOSL_HIGH_BANDWIDTH	 = 0,
	QOSL_LOW_LATENCY	 = 0x1
}psif_tsu_qos_t; /* enum psif_tsu_qos [ 1 bits] */

/* Completion status for this completion. *//* Extent 8 bit */
typedef enum {
	PSIF_WC_STATUS_SUCCESS,
	PSIF_WC_STATUS_LOC_LEN_ERR,
	PSIF_WC_STATUS_LOC_QP_OP_ERR,
	PSIF_WC_STATUS_LOC_EEC_OP_ERR,
	PSIF_WC_STATUS_LOC_PROT_ERR,
	PSIF_WC_STATUS_WR_FLUSH_ERR,
	PSIF_WC_STATUS_MW_BIND_ERR,
	PSIF_WC_STATUS_BAD_RESP_ERR,
	PSIF_WC_STATUS_LOC_ACCESS_ERR,
	PSIF_WC_STATUS_REM_INV_REQ_ERR,
	PSIF_WC_STATUS_REM_ACCESS_ERR,
	PSIF_WC_STATUS_REM_OP_ERR,
	PSIF_WC_STATUS_RETRY_EXC_ERR,
	PSIF_WC_STATUS_RNR_RETRY_EXC_ERR,
	PSIF_WC_STATUS_LOC_RDD_VIOL_ERR,
	PSIF_WC_STATUS_REM_INV_RD_REQ_ERR,
	PSIF_WC_STATUS_REM_ABORT_ERR,
	PSIF_WC_STATUS_INV_EECN_ERR,
	PSIF_WC_STATUS_INV_EEC_STATE_ERR,
	PSIF_WC_STATUS_FATAL_ERR,
	PSIF_WC_STATUS_RESP_TIMEOUT_ERR,
	PSIF_WC_STATUS_GENERAL_ERR,
	/* Padding out to required bits allocated */
	PSIF_WC_STATUS_FIELD_MAX	 = 0xff
}psif_wc_status_t; /* enum psif_wc_status [ 8 bits] */

/*
 * Completion entry opcode indicating what type of request this completion
 * entry is completed.
 *//* Extent 8 bit */
typedef enum {
	PSIF_WC_OPCODE_SEND	 = 0,
	PSIF_WC_OPCODE_RDMA_WR	 = 0x1,
	PSIF_WC_OPCODE_RDMA_READ	 = 0x2,
	PSIF_WC_OPCODE_CMP_SWAP	 = 0x3,
	PSIF_WC_OPCODE_FETCH_ADD	 = 0x4,
	PSIF_WC_OPCODE_LSO	 = 0x6,
	PSIF_WC_OPCODE_MASKED_CMP_SWAP	 = 0x9,
	PSIF_WC_OPCODE_MASKED_FETCH_ADD,
	PSIF_WC_OPCODE_DM_PUT	 = 0x20,
	PSIF_WC_OPCODE_DM_GET,
	PSIF_WC_OPCODE_INVALIDATE_RKEY	 = 0x40,
	PSIF_WC_OPCODE_INVALIDATE_LKEY,
	PSIF_WC_OPCODE_INVALIDATE_BOTH_KEYS,
	PSIF_WC_OPCODE_INVALIDATE_TLB,
	PSIF_WC_OPCODE_RESIZE_CQ,
	PSIF_WC_OPCODE_SET_SRQ_LIM,
	PSIF_WC_OPCODE_SET_XRCSRQ_LIM,
	PSIF_WC_OPCODE_REQ_CMPL_NOTIFY,
	PSIF_WC_OPCODE_CMPL_NOTIFY_RCVD,
	PSIF_WC_OPCODE_REARM_CMPL_EVENT,
	PSIF_WC_OPCODE_REQ_RB_NOTIFY,
	PSIF_WC_OPCODE_RB_NOTIFY_RCVD,
	PSIF_WC_OPCODE_REARM_RB_EVENT,
	PSIF_WC_OPCODE_NO_OPERATION,
	PSIF_WC_OPCODE_INVALIDATE_RQ,
	PSIF_WC_OPCODE_INVALIDATE_CQ,
	PSIF_WC_OPCODE_INVALIDATE_RB,
	PSIF_WC_OPCODE_INVALIDATE_XRCSRQ,
	PSIF_WC_OPCODE_INVALIDATE_SGL_CACHE,
	PSIF_WC_OPCODE_RECEIVE_SEND	 = 0x80,
	PSIF_WC_OPCODE_RECEIVE_RDMA_WR_IMM
}psif_wc_opcode_t; /* enum psif_wc_opcode [ 8 bits] */

/* MMU table level definition
 *  If page level is not applicable it should be set to  PAGE_LEVEL0
 *  Values beyond PAGE_LEVEL4 (5-7) are reserved by HW
 *//* Extent 3 bit */
typedef enum {
	/* */
	PAGE_LEVEL0	 = 0,
	PAGE_LEVEL1,
	PAGE_LEVEL2,
	PAGE_LEVEL3,
	/* PAGE_LEVEL4 is SPARC only ? */
	PAGE_LEVEL4,
	PAGE_LEVEL_RESERVED
}psif_table_level_t; /* enum psif_table_level [ 3 bits] */

/*
 * This is a ring buffer type defining the type of transaction this
 * represents.
 *//* Extent 3 bit */
typedef enum {
	PSIF_RB_TYPE_INVALID,
	PSIF_RB_TYPE_DM_PUT,
	PSIF_RB_TYPE_DM_GET_RESP,
	PSIF_RB_TYPE_RCV_PROXY_COMPLETION,
	PSIF_RB_TYPE_RCV_PROXY_COMPLETION_AND_DATA,
	PSIF_RB_TYPE_SEND_PROXY_COMPLETION,
	PSIF_RB_TYPE_SEND_COMPLETION
}psif_rb_type_t; /* enum psif_rb_type [ 3 bits] */

/*
 * Core number for EPS-A.1 PSIF_EPS_A_1 PSIF_EPS_A_2 PSIF_EPS_A_3
 * PSIF_EPS_A_4
 *//* Extent 2 bit */
typedef enum {
	PSIF_EPS_A_1,
	PSIF_EPS_A_2,
	PSIF_EPS_A_3,
	PSIF_EPS_A_4
}psif_eps_a_core_t; /* enum psif_eps_a_core [ 2 bits] */

/*
 * CMPL_NO_ERROR CMPL_RQS_INVALID_REQUEST_ERR CMPL_RQS_QP_IN_WRONG_STATE_ERR
 * CMPL_RQS_CMD_FROM_EPS_ERR CMPL_DMA_SGL_RD_ERR CMPL_DMA_PYLD_RD_ERR
 * CMPL_DMA_SGL_LENGTH_ERR CMPL_DMA_LKEY_ERR
 *//* Extent 4 bit */
typedef enum {
	CMPL_NO_ERROR,
	CMPL_RQS_INVALID_REQUEST_ERR,
	CMPL_RQS_QP_IN_WRONG_STATE_ERR,
	CMPL_RQS_CMD_FROM_EPS_ERR,
	CMPL_DMA_SGL_RD_ERR,
	CMPL_DMA_PYLD_RD_ERR,
	CMPL_DMA_SGL_LENGTH_ERR,
	CMPL_DMA_LKEY_ERR,
	/* Padding out to required bits allocated */
	PSIF_CMPL_OUTSTANDING_ERROR_FIELD_MAX	 = 0xf
}psif_cmpl_outstanding_error_t; /* enum psif_cmpl_outstanding_error [ 4 bits] */

/*
 * 2 bits (next_opcode) 0x0: No operation in progress 0x1: Expect SEND middle
 * or last 0x2: Expect RDMA_WR middle or last 0x3: Expect DM_PUT middle or
 * last
 *//* Extent 2 bit */
typedef enum {
	NO_OPERATION_IN_PROGRESS	 = 0,
	EXPECT_SEND_MIDDLE_LAST	 = 0x1,
	EXPECT_RDMA_WR_MIDDLE_LAST	 = 0x2,
	EXPECT_DM_PUT_MIDDLE_LAST	 = 0x3
}psif_expected_op_t; /* enum psif_expected_op [ 2 bits] */

/*
 * Migration state (migrated, re-arm and armed). XXX: Assign values to the
 * states.
 *//* Extent 2 bit */
typedef enum {
	APM_OFF,
	APM_MIGRATED,
	APM_REARM,
	APM_ARMED
}psif_migration_t; /* enum psif_migration [ 2 bits] */

/*
 * 3 bits (transport) 0x0: RC - Reliable connection. 0x1: UC - Unreliable
 * connection. 0x2: RD - Reliable datagram - not supported. 0x3: UD -
 * Unreliable datagram. 0x4: RSVD1 0x5: XRC - Extended reliable connection.
 * 0x6: MANSP1 - manufacturer specific opcodes. 0x7: MANSP2 - manufacturer
 * specific opcodes.
 *//* Extent 3 bit */
typedef enum {
	PSIF_QP_TRANSPORT_RC	 = 0,
	PSIF_QP_TRANSPORT_UC	 = 0x1,
	PSIF_QP_TRANSPORT_RD	 = 0x2,
	PSIF_QP_TRANSPORT_UD	 = 0x3,
	PSIF_QP_TRANSPORT_RSVD1	 = 0x4,
	PSIF_QP_TRANSPORT_XRC	 = 0x5,
	PSIF_QP_TRANSPORT_MANSP1	 = 0x6,
	PSIF_QP_TRANSPORT_MANSP2	 = 0x7
}psif_qp_trans_t; /* enum psif_qp_trans [ 3 bits] */

/*
 * Communication established state. This gets set when a packet is received
 * error free when in RTR state.
 *//* Extent 1 bit */
typedef enum {
	NO_COMM_ESTABLISHED	 = 0,
	COMM_ESTABLISHED	 = 0x1
}psif_comm_live_t; /* enum psif_comm_live [ 1 bits] */

/* Extent 1 bit */
typedef enum {
	FALSE	 = 0,
	TRUE	 = 0x1
}psif_bool_t; /* enum psif_bool [ 1 bits] */

/* Enumeration for using GRH or not. When set GRH should be used. *//* Extent 1 bit */
typedef enum {
	NO_GRH	 = 0,
	USE_GRH	 = 0x1
}psif_use_grh_t; /* enum psif_use_grh [ 1 bits] */

/* Enumeration for loopback indication NO_LOOPBACK = 0 LOOPBACK = 1. *//* Extent 1 bit */
typedef enum {
	NO_LOOPBACK	 = 0,
	LOOPBACK	 = 0x1
}psif_loopback_t; /* enum psif_loopback [ 1 bits] */

/* Extent 12 bit */
typedef enum {
	WR_CB_START_OFFS	 = 0,
	WR_CB_LAST_OFFS	 = 0x140,
	WR_SQS_DOORBELL_OFFS	 = 0xfc0,
	WR_CB_CLEAR_OFFS	 = 0xff8,
	WR_MAX_BAR_OFFS	 = 0xfff
}psif_pcie_wr_offs_t; /* enum psif_pcie_wr_offs [12 bits] */

/* Extent 8 bit */
typedef enum {
	MBOX_EPSA0,
	MBOX_EPSA1,
	MBOX_EPSA2,
	MBOX_EPSA3,
	MBOX_EPSC,
	MBOX_EPS_MAX,
	/* Padding out to required bits allocated */
	PSIF_MBOX_TYPE_FIELD_MAX	 = 0xff
}psif_mbox_type_t; /* enum psif_mbox_type [ 8 bits] */

/*
 * DMA Validation Key states. The valid states are: PSIF_DMA_KEY_INVALID=0
 * PSIF_DMA_KEY_FREE = 1 PSIF_DMA_KEY_VALID = 2 PSIF_DMA_KEY_MMU_VALID
 *//* Extent 2 bit */
typedef enum {
	PSIF_DMA_KEY_INVALID	 = 0,
	PSIF_DMA_KEY_FREE	 = 0x1,
	PSIF_DMA_KEY_VALID	 = 0x2,
	PSIF_DMA_KEY_MMU_VALID	 = 0x3
}psif_dma_vt_key_states_t; /* enum psif_dma_vt_key_states [ 2 bits] */

/*
 * Flash image types. More comming...
 *//* Extent 32 bit */
typedef enum {
	PSIF_IMAGE_INVALID	 = 0,
	PSIF_IMAGE_BOOT_LOADER	 = 0x1,
	PSIF_IMAGE_EPS_C_APPLICATION	 = 0x2,
	PSIF_IMAGE_EPS_A_APPLICATION	 = 0x3,
	PSIF_IMAGE_DIAGNOSTICS	 = 0x4,
	/* Padding out to required bits allocated */
	PSIF_FLASH_IMAGE_TYPE_FIELD_MAX	 = 0x7fffffff
}psif_flash_image_type_t; /* enum psif_flash_image_type [32 bits] */

/*
 * Port flags can take one of the following values:
 * PSIF_EVENT_SGID_TABLE_CHANGED PSIF_EVENT_PKEY_TABLE_CHANGED
 * PSIF_EVENT_MASTER_SM_LID_CHANGED PSIF_EVENT_MASTER_SM_SL_CHANGED
 * PSIF_EVENT_SUBNET_TIMEOUT_CHANGED PSIF_EVENT_IS_SM_DISABLED_CHANGED
 * PSIF_EVENT_IS_CLIENT_REREGISTRATION_SUPPORTED_CHANGED
 *//* Extent 4 bit */
typedef enum {
	PSIF_EVENT_SGID_TABLE_CHANGED,
	PSIF_EVENT_PKEY_TABLE_CHANGED,
	PSIF_EVENT_MASTER_SM_LID_CHANGED,
	PSIF_EVENT_MASTER_SM_SL_CHANGED,
	PSIF_EVENT_SUBNET_TIMEOUT_CHANGED,
	PSIF_EVENT_IS_SM_DISABLED_CHANGED,
	PSIF_EVENT_IS_CLIENT_REREGISTRATION_SUPPORTED_CHANGED,
	PSIF_EVENT_LID_TABLE_CHANGED,
	PSIF_EVENT_EPSC_COMPLETION
}psif_port_flags_t; /* enum psif_port_flags [ 4 bits] */

/*
 * Here are the different EPS core IDs: PSIF_EVENT_EPS_A_1 PSIF_EVENT_EPS_A_2
 * PSIF_EVENT_EPS_A_3 PSIF_EVENT_EPS_A_4 PSIF_EVENT_EPS_C
 *//* Extent 4 bit */
typedef enum {
	PSIF_EVENT_CORE_EPS_A_1,
	PSIF_EVENT_CORE_EPS_A_2,
	PSIF_EVENT_CORE_EPS_A_3,
	PSIF_EVENT_CORE_EPS_A_4,
	PSIF_EVENT_CORE_EPS_C,
	/* Padding out to required bits allocated */
	PSIF_EPS_CORE_ID_FIELD_MAX	 = 0xf
}psif_eps_core_id_t; /* enum psif_eps_core_id [ 4 bits] */

/* Extent 32 bit */
typedef enum {
/* Logging completely disabled */

	EPSC_LOG_MODE_OFF	 = 0,
/* See epsfw/src/include/logging.h */

	EPSC_LOG_MODE_SCAT	 = 0x1,
	EPSC_LOG_MODE_MALLOC	 = 0x2,
	EPSC_LOG_MODE_LOCAL	 = 0x3,
/* Redirect logging to host (dma) */

	EPSC_LOG_MODE_HOST	 = 0x4,
/* Save the set log mode in the flash */

	EPSC_LOG_MODE_SAVE	 = 0x10,
	/* Padding out to required bits allocated */
	PSIF_EPSC_LOG_MODE_FIELD_MAX	 = 0x7fffffff
}psif_epsc_log_mode_t; /* enum psif_epsc_log_mode [32 bits] */

/*
 * EPSC_LOG_CTRL
 *//* Extent 32 bit */
typedef enum {
	EPS_LOG_OFF	 = 0,
	EPS_LOG_FATAL	 = 0x1,
	EPS_LOG_ERROR	 = 0x2,
	EPS_LOG_WARN	 = 0x3,
	EPS_LOG_INFO	 = 0x4,
	EPS_LOG_DEBUG	 = 0x5,
	EPS_LOG_TRACE	 = 0x6,
	EPS_LOG_ALL	 = 0x7,
	/* Padding out to required bits allocated */
	PSIF_EPSC_LOG_LEVEL_FIELD_MAX	 = 0x7fffffff
}psif_epsc_log_level_t; /* enum psif_epsc_log_level [32 bits] */

/*
 *  Version fixed copy of psif_ib_port_state
 *//* Extent 32 bit */
typedef enum {
	EPSC_PORT_NOP	 = 0,
	EPSC_PORT_DOWN	 = 0x1,
	EPSC_PORT_INIT	 = 0x2,
	EPSC_PORT_ARMED	 = 0x3,
	EPSC_PORT_ACTIVE	 = 0x4,
	EPSC_PORT_ACTIVE_DEFER	 = 0x5,
	/* Padding out to required bits allocated */
	PSIF_EPSC_PORT_STATE_FIELD_MAX	 = 0x7fffffff
}psif_epsc_port_state_t; /* enum psif_epsc_port_state [32 bits] */

/* 
 *  Version fixed copy of psif_path_mtu
 *//* Extent 32 bit */
typedef enum {
	EPSC_MTU_INVALID	 = 0,
	EPSC_MTU_256B	 = 0x1,
	EPSC_MTU_512B	 = 0x2,
	EPSC_MTU_1024B	 = 0x3,
	EPSC_MTU_2048B	 = 0x4,
	EPSC_MTU_4096B	 = 0x5,
	EPSC_MTU_XXX	 = 0x6,
	/* Padding out to required bits allocated */
	PSIF_EPSC_PATH_MTU_FIELD_MAX	 = 0x7fffffff
}psif_epsc_path_mtu_t; /* enum psif_epsc_path_mtu [32 bits] */

/*
 * Monitors handling asynchronous event
 *//* Extent 4 bit */
typedef enum {
	PSIF_MONITOR_ARM,
	PSIF_MONITOR_TRIG,
	PSIF_MONITOR_REARM,
	PSIF_MONITOR_INACTIVE,
	PSIF_MONITOR_ERROR,
	/* Padding out to required bits allocated */
	PSIF_EPSC_MONITOR_FIELD_MAX	 = 0xf
}psif_epsc_monitor_t; /* enum psif_epsc_monitor [ 4 bits] */

/*
 * Sources with interrupts active - bit (1 << EPSC_INTR_*) in mask
 *//* Extent 5 bit */
typedef enum {
	EPSC_INTR_MMU,
	EPSC_INTR_HOST,
	EPSC_INTR_CBU,
	EPSC_INTR_IBPR,
	EPSC_INTR_RCV,
	EPSC_INTR_DSCR,
	EPSC_INTR_RQH,
	EPSC_INTR_VAL,
	EPSC_INTR_CMPL,
	EPSC_INTR_ERR,
	EPSC_INTR_SQS,
	EPSC_INTR_QPS,
	EPSC_INTR_RQS,
	EPSC_INTR_DMA,
	EPSC_INTR_IBPB,
	EPSC_INTR_NCSI,
	/* low priority only */
	EPSC_INTR_IBU1,
	EPSC_INTR_IBU0,
	EPSC_INTR_XIU,
	EPSC_INTR_LCSR
}psif_epsc_interrupt_source_t; /* enum psif_epsc_interrupt_source [ 5 bits] */

/*
 * Interrupt severity levels
 *//* Extent 2 bit */
typedef enum {
	EPSC_INTR_RESERVED,
	EPSC_INTR_LOW,
	EPSC_INTR_HIGH,
	EPSC_INTR_FATAL
}psif_epsc_interrupt_pri_t; /* enum psif_epsc_interrupt_pri [ 2 bits] */

/*
 * Version fixed copy of psif_ib_atomic_cap
 *//* Extent 32 bit */
typedef enum {
	EPSC_ATOMIC_NONE,
	EPSC_ATOMIC_HCA,
	EPSC_ATOMIC_GLOB,
	/* Padding out to required bits allocated */
	PSIF_EPSC_ATOMIC_CAP_FIELD_MAX	 = 0x7fffffff
}psif_epsc_atomic_cap_t; /* enum psif_epsc_atomic_cap [32 bits] */

/*
 * The eps-c fw csr status
 *//* Extent 8 bit */
typedef enum {
	/* Successful exit status. */
	EPSC_SUCCESS,
	/* Key was rejected by service */
	EPSC_EKEYREJECTED,
	/* Cannot assign requested address */
	EPSC_EADDRNOTAVAIL,
	/* Operation not supported on transport endpoint */
	EPSC_EOPNOTSUPP,
	/* Out of memory */
	EPSC_ENOMEM,
	/* No data available */
	EPSC_ENODATA,
	/* Try again */
	EPSC_EAGAIN,
	/* Operation Canceled */
	EPSC_ECANCELED,
	/* Connection reset by peer */
	EPSC_ECONNRESET,
	/* CSR operation failed */
	EPSC_ECSR,
	/* Modify_qp errors */
	EPSC_MODIFY_QP_OUT_OF_RANGE,
	EPSC_MODIFY_QP_INVALID,
	EPSC_MODIFY_CANNOT_CHANGE_QP_ATTR,
	EPSC_MODIFY_INVALID_QP_STATE,
	EPSC_MODIFY_INVALID_MIG_STATE,
	/* General failure */
	EPSC_FAIL	 = 0xff
}psif_epsc_csr_status_t; /* enum psif_epsc_csr_status [ 8 bits] */

/*
 * Host EPS mail-box opcodes
 *//* Extent 8 bit */
typedef enum {
	/* ... */
	EPSC_NOOP	 = 0,
	/* Response to initial config request */
	EPSC_SETUP	 = 0x1,
	EPSC_TEARDOWN	 = 0x36,
	/* Set single 64bit register - depricated */
	EPSC_SET_SINGLE	 = 0x2,
	/* Set one 64bit register using CSR addr */
	EPSC_SET_ONE_CSR	 = 0x3,
	/* */
	EPSC_SET_RESERVED	 = 0x4,
	/* Setup a descriptor base addr */
	EPSC_SET_BASEADDR	 = 0x5,
	/* Set base addr for the EPS eq */
	EPSC_SET_BASEADDR_EQ	 = 0x6,
	/* Set Local ID for UF (backdoor) */
	EPSC_SET_LID	 = 0x7,
	/* Depricated */
	EPSC_SET_LID_P1	 = 0x8,
	EPSC_SET_LID_P2	 = 0x9,
	/* Set Global ID for UF (backdoor) */
	EPSC_SET_GID	 = 0xa,
	/* Set Vlink state */
	EPSC_SET_VLINK_STATE	 = 0xb,
	/* Get Vlink state */
	EPSC_QUERY_VLINK_STATE	 = 0xc,
	/* Reset UF at startup */
	EPSC_UF_RESET	 = 0xd,
	/* Modify QP complete w/kick */
	EPSC_MODIFY_QP	 = 0xe,
	/* Get single 64bit register - depricated */
	EPSC_GET_SINGLE	 = 0xf,
	/* Get one 64bit register using CSR addr */
	EPSC_GET_ONE_CSR	 = 0x10,
	/* Query QP sub-entry */
	EPSC_QUERY_QP	 = 0x11,
	/* Non-MAD query device */
	EPSC_QUERY_DEVICE	 = 0x12,
	/* Non-MAD query port */
	EPSC_QUERY_PORT_1	 = 0x13,
	EPSC_QUERY_PORT_2	 = 0x14,
	/* Non-MAD SMA attribute query */
	EPSC_QUERY_PKEY	 = 0x15,
	EPSC_QUERY_GID	 = 0x16,
	/* Non-MAD SMA attribute setting */
	EPSC_MODIFY_DEVICE	 = 0x17,
	EPSC_MODIFY_PORT_1	 = 0x18,
	EPSC_MODIFY_PORT_2	 = 0x19,
	/* Local MC subscription handling */
	EPSC_MC_ATTACH	 = 0x1a,
	EPSC_MC_DETACH	 = 0x1b,
	EPSC_MC_QUERY	 = 0x1c,
	/* Handle asynchronous events */
	EPSC_EVENT_ACK	 = 0x1d,
	EPSC_EVENT_INDEX	 = 0x1e,
	/* Program flash content */
	EPSC_FLASH_START	 = 0x1f,
	EPSC_FLASH_INFO	 = 0x20,
	EPSC_FLASH_ERASE_SECTOR	 = 0x21,
	EPSC_FLASH_RD	 = 0x22,
	EPSC_FLASH_WR	 = 0x23,
	EPSC_FLASH_CHECK	 = 0x24,
	EPSC_FLASH_SCAN	 = 0x25,
	EPSC_FLASH_STOP	 = 0x26,
	/* IB packet tracer */
	EPSC_TRACE_STATUS	 = 0x27,
	EPSC_TRACE_SETUP	 = 0x28,
	EPSC_TRACE_START	 = 0x29,
	EPSC_TRACE_STOP	 = 0x2a,
	EPSC_TRACE_ACQUIRE	 = 0x2b,
	/* Test operations */
	EPSC_TEST_HOST_RD	 = 0x2c,
	EPSC_TEST_HOST_WR	 = 0x2d,
	/* Get EPS-C version details */
	EPSC_FW_VERSION	 = 0x2e,
	/* Redirection/configuration of EPSC's internal log subsystem */
	EPSC_LOG_CTRL	 = 0x2f,
	EPSC_LOG_REQ_NOTIFY	 = 0x30,
	/* Force & read back link speed */
	EPSC_LINK_CNTRL	 = 0x31,
	/* EPS-A control & communication (to EPS-C) */
	EPSC_A_CONTROL	 = 0x33,
	/* EPS-A targeted commands (to EPS-A) */
	EPSC_A_COMMAND	 = 0x35,
	/* Exercise mmu with access from epsc */
	EPSC_EXERCISE_MMU	 = 0x34,
	/* Access to EPS-C CLI */
	EPSC_CLI_ACCESS	 = 0x37,
	/* EOF marker - must be last / highest */
	EPSC_LAST_OP	 = 0x38,
	/* Padding out to required bits allocated */
	PSIF_EPSC_CSR_OPCODE_FIELD_MAX	 = 0xff
}psif_epsc_csr_opcode_t; /* enum psif_epsc_csr_opcode [ 8 bits] */

/*
 * The eps-c fw csr flags
 *//* Extent 8 bit */
typedef enum {
	EPSC_FL_NONE	 = 0,
	/* Request notification (interrupt) when completion is ready */
	EPSC_FL_NOTIFY	 = 0x1,
	/* Padding out to required bits allocated */
	PSIF_EPSC_CSR_FLAGS_FIELD_MAX	 = 0xff
}psif_epsc_csr_flags_t; /* enum psif_epsc_csr_flags [ 8 bits] */

/*
 * EPSC_MODIFY_DEVICE operations
 *//* Extent 16 bit */
typedef enum {
	PSIF_DEVICE_MODIFY_SYS_IMAGE_GUID	 = 0x1,
	PSIF_DEVICE_MODIFY_NODE_DESC	 = 0x2,
	/* Padding out to required bits allocated */
	PSIF_EPSC_CSR_MODIFY_DEVICE_FLAGS_FIELD_MAX	 = 0xffff
}psif_epsc_csr_modify_device_flags_t; /* enum psif_epsc_csr_modify_device_flags [16 bits] */

/*
 * EPSC_MODIFY_PORT_{1,2} operations
 *//* Extent 16 bit */
typedef enum {
	PSIF_PORT_SHUTDOWN	 = 0x1,
	PSIF_PORT_INIT_TYPE	 = 0x4,
	PSIF_PORT_RESET_QKEY_CNTR	 = 0x8,
	PSIF_PORT_RESET_PKEY_CNTR	 = 0x10,
	/* Padding out to required bits allocated */
	PSIF_EPSC_CSR_MODIFY_PORT_FLAGS_FIELD_MAX	 = 0xffff
}psif_epsc_csr_modify_port_flags_t; /* enum psif_epsc_csr_modify_port_flags [16 bits] */

/*
 * Valid fields in struct psif_epsc_csr_trace_setup
 *//* Extent 32 bit */
typedef enum {
	EPSC_TRACE_SETUP_CNTR	 = 0x1,
	EPSC_TRACE_QUAL_1_CNTR	 = 0x2,
	EPSC_TRACE_TRIGG_1_CNTR	 = 0x4,
	EPSC_TRACE_QUAL_2_CNTR	 = 0x8,
	EPSC_TRACE_TRIGG_2_CNTR	 = 0x10,
	EPSC_TRACE_ALL_CNTR	 = 0x1f,
	/* Padding out to required bits allocated */
	PSIF_EPSC_CSR_TRACE_CONTROL_FIELD_MAX	 = 0x7fffffff
}psif_epsc_csr_trace_control_t; /* enum psif_epsc_csr_trace_control [32 bits] */

/*
 *//* Extent 3 bit */
typedef enum {
	PSIF_LINK_SPEED_EDR	 = 0,
	PSIF_LINK_SPEED_QDR	 = 0x1,
	PSIF_LINK_SPEED_DDR	 = 0x2,
	PSIF_LINK_SPEED_SDR	 = 0x3,
	/* Padding out to required bits allocated */
	PSIF_IB_LINK_SPEED_FIELD_MAX	 = 0x7
}psif_ib_link_speed_t; /* enum psif_ib_link_speed [ 3 bits] */

/*
 *//* Extent 2 bit */
typedef enum {
	PSIF_LINK_WIDTH_X4	 = 0,
	PSIF_LINK_WIDTH_X1	 = 0x1,
	/* Padding out to required bits allocated */
	PSIF_IB_LINK_WIDTH_FIELD_MAX	 = 0x3
}psif_ib_link_width_t; /* enum psif_ib_link_width [ 2 bits] */

/*
 *//* Extent 32 bit */
typedef enum {
	EPSC_A_LOAD,
	EPSC_A_START,
	EPSC_A_STOP,
	EPSC_A_STATUS,
	/* Padding out to required bits allocated */
	PSIF_EPSC_CSR_EPSA_COMMAND_FIELD_MAX	 = 0x7fffffff
}psif_epsc_csr_epsa_command_t; /* enum psif_epsc_csr_epsa_command [32 bits] */

/*
 * Completion notification states. Could take any of these values:
 * PSIF_CQ_UNARMED PSIF_CQ_ARMED_SE PSIF_CQ_ARMED_ALL PSIF_CQ_TRIGGERED
 *//* Extent 2 bit */
typedef enum {
	PSIF_CQ_UNARMED,
	PSIF_CQ_ARMED_SE,
	PSIF_CQ_ARMED_ALL,
	PSIF_CQ_TRIGGERED
}psif_cq_state_t; /* enum psif_cq_state [ 2 bits] */

/*
 * This is an indication if the RSS hash was generated with port inputs or
 * not.
 *//* Extent 1 bit */
typedef enum {
	RSS_WITHOUT_PORT,
	RSS_WITH_PORT
}psif_rss_hash_source_t; /* enum psif_rss_hash_source [ 1 bits] */

/* CSR automated type for TSU_HOST_TVL_TABLE */
/*
 * TSU VL mapping table for requests. Inputs/addressing to this table are
 * {UF(35 UFs), tsu_qosl (High/Low BAR), tsu_sl, port}.
 */
struct psif_csr_host_tvl_table {
	/* *** 64 bit group 0 start *** */
	/* tsu_vl(7[0] bits)TSU Virtual Lane. */
	u64	data:7; /* 7 bits @ offs 0:0 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_tvl_table [64 bits] */

/* CSR automated type for TSU_HOST_MAX_GLOBAL_TVL_CRDTS */
/* Per TVL register.Maximum global credits a particular TVL can get. */
struct psif_csr_host_max_global_tvl_crdts {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_max_global_tvl_crdts [64 bits] */

/* CSR automated type for TSU_HOST_PRIVATE_TVL_CRDTS */
/*
 * Per TVL register.Maximum private credits a particular TVL can get. The
 * amount of credits dedicated to this TVL.
 */
struct psif_csr_host_private_tvl_crdts {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_private_tvl_crdts [64 bits] */

/* CSR automated type for TSU_HOST_TOTAL_GLOBAL_TVL_CRDTS */
/* Total number of global credits assign to TVLs. */
struct psif_csr_host_total_global_tvl_crdts {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_total_global_tvl_crdts [64 bits] */

/* CSR automated type for TSU_HOST_XIU_ARBITER */
/* weight given for round robin arbitration for xiu commands. */
struct psif_csr_host_xiu_arbiter {
	/* *** 64 bit group 0 start *** */
	u16	atomic:3; /* 3 bits @ offs 0:0 */
	u16	:5; /* 5 bits @ offs 0:3 */
	u16	mmu_voq:3; /* 3 bits @ offs 0:8 */
	u16	:5; /* 5 bits @ offs 0:11 */
	u16	mmu:3; /* 3 bits @ offs 0:16 */
	u16	:5; /* 5 bits @ offs 0:19 */
	u16	intrp:3; /* 3 bits @ offs 0:24 */
	u16	:5; /* 5 bits @ offs 0:27 */
	u32	sqs_rb:3; /* 3 bits @ offs 0:32 */
	u32	:29; /* 29 bits @ offs 0:35 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_xiu_arbiter [64 bits] */

/* CSR automated type for TSU_HOST_EPS_ARBITER */
/* weight given for round robin arbitration for eps commands. */
struct psif_csr_host_eps_arbiter {
	/* *** 64 bit group 0 start *** */
	u64	mmu_voq:3; /* 3 bits @ offs 0:0 */
	u64	:5; /* 5 bits @ offs 0:3 */
	u64	intrp:3; /* 3 bits @ offs 0:8 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_eps_arbiter [64 bits] */

/* CSR automated type for TSU_HOST_ERROR_CRDTS */
/* Number of error credits reserved in the tsu_host llq. */
struct psif_csr_host_error_crdts {
	/* *** 64 bit group 0 start *** */
	u64	num_sqs_rb_credit:7; /* 7 bits @ offs 0:0 */
	u64	:1; /* 1 bits @ offs 0:7 */
	u64	:7; /* 7 bits @ offs 0:8 */
	u64	:49; /* 49 bits @ offs 0:15 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_error_crdts [64 bits] */

/* CSR automated type for TSU_HOST_DATA_LATENCY */
/* Data Latency skew from all clients to tsu_host. */
struct psif_csr_host_data_latency {
	/* *** 64 bit group 0 start *** */
	u64	data:4; /* 4 bits @ offs 0:0 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_data_latency [64 bits] */

/* CSR automated type for TSU_HOST_TVL_CRDTS_USED */
/*
 * Per TVL register. The amount of private and global credits used to this
 * TVL.
 */
struct psif_csr_host_tvl_crdts_used {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_tvl_crdts_used [64 bits] */

/* CSR automated type for TSU_HOST_GLOBAL_CRDTS_USED */
/* Amount of global credits used shared among all TVLs. */
struct psif_csr_host_global_crdts_used {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_global_crdts_used [64 bits] */

/* CSR automated type for TSU_HOST_HCA_MODE */
/* when set puts the tsu_host in hca mode for Atomics. */
struct psif_csr_host_hca_mode {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_hca_mode [64 bits] */

/* CSR automated type for TSU_HOST_ENABLE_PCIE_SWAP */
/*
 * when set flips the compare and swap field in xiu meta_data bus in PCIe
 * mode.
 */
struct psif_csr_host_enable_pcie_swap {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_enable_pcie_swap [64 bits] */

/* CSR automated type for TSU_HOST_LITTLE_ENDIAN_MODE */
/* Handling Endianess of host Processor. */
struct psif_csr_host_little_endian_mode {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_little_endian_mode [64 bits] */

/* CSR automated type for TSU_HOST_XIU_LLQ_GLOBAL_CREDITS */
/* allocating global credits to llq in XIU */
struct psif_csr_host_xiu_llq_global_credits {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_xiu_llq_global_credits [64 bits] */

/*
 * Context used by tsu_mmu when performing address translation. The structure
 * is follows: [63:56] st [55:55] no_snoop [54:53] tph [52:52] ro [51:12]
 * table_ptr [11:11] th [10:8] translation_type [7:4] page_size [3:3]
 * wr_access [2:0] table_level
 */
struct psif_mmu_cntx {
	/* *** 64 bit group 0 start *** */
	/*
	 * XXX: Should this be enumerated? XXX: Make sure description is added when
	 * encoding is decided...
	 */
	u64	table_level:3; /* 3 bits @ offs 0:0 */
	/* Set for write access. */
	u64	wr_access:1; /* 1 bits @ offs 0:3 */
	/* Different supported page sizes. */
	#if defined(__arm__) /* enum psif_page_size */
		u64	page_size:4;
	#else /* !__arm__ */
		enum psif_page_size	page_size:4;
	#endif	 /* 4 bits @ offs 0:4 */
	/*
	 * Translation types supported by the PSIF MMU. The modes are:
	 * MMU_PASS_THROUGH MMU_GVA2GPA_MODE, MMU_EPSA_MODE, MMU_EPSC_MODE
	 */
	#if defined(__arm__) /* enum psif_mmu_translation */
		u64	translation_type:3;
	#else /* !__arm__ */
		enum psif_mmu_translation	translation_type:3;
	#endif	 /* 3 bits @ offs 0:8 */
	/* Indicates that the TPH field is valid for the PCIe request. */
	u64	th:1; /* 1 bits @ offs 0:11 */
	/*
	 * This is bit [51:12] of the table pointer. The lower twelve bits are always
	 * set to zero. The pointer is pointing to a certain level in the page table
	 * structure. Only applicable if translation_type is set.
	 */
	u64	table_ptr:40; /* 40 bits @ offs 0:12 */
	/* PCIe relaxed ordering. */
	u64	ro:1; /* 1 bits @ offs 0:52 */
	/* PCIe TLP hints. */
	u64	tph:2; /* 2 bits @ offs 0:53 */
	/* PCIe no snoop. */
	u64	ns:1; /* 1 bits @ offs 0:55 */
	/* PCIe steering tag. */
	u64	st:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_mmu_cntx [64 bits] */

/* Compact Base Address Register format. Not for use in register definitions. */
struct psif_base_addr { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* host_address(64[0] bits)Host address used for accesses to/from TSU HOST. */
	u64	address; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_context; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * clog2_extent used for entry alignment. This field used to calculate
	 * address for a particular entry. Address to an entry is calculated as
	 * follows: host_addr + entry_num*(1 (leftshift) clog2_extent)
	 */
	u32	extent_log2:5; /* 5 bits @ offs 2:0 */
	/* Manually added spacing to pad out base addr */
	u32	:27; /* 27 bits @ offs 2:5 */
	/* Number of entries in table. */
	u32	num_entries; /* 32 bits @ offs 2:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_base_addr [192 bits] */

/* CSR automated type for TSU_HOST_MRS_CREDIT_CNT */
/* MRS credit debug counter. */
struct psif_csr_host_mrs_credit_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_mrs_credit_cnt [64 bits] */

/* CSR automated type for TSU_HOST_ERR_CREDIT_CNT */
/* ERR credit debug counter. */
struct psif_csr_host_err_credit_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_err_credit_cnt [64 bits] */

/* CSR automated type for TSU_HOST_LLQ_CNT */
/* LLQ debug counter. */
struct psif_csr_host_llq_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_llq_cnt [64 bits] */

/* CSR automated type for TSU_HOST_INT_STATUS */
/*
 * EPS Address Error Interrupt status register. 1b per source (1=int
 * triggered).
 */
struct psif_csr_host_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_status [64 bits] */

/* CSR automated type for TSU_HOST_INT_MASK */
/* EPS Address Error Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_host_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_mask [64 bits] */

/* CSR automated type for TSU_HOST_INT_PRI */
/*
 * EPS Address Error Interrupt priority register. 1b per source (1=high,
 * 0=low).
 */
struct psif_csr_host_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_pri [64 bits] */

/* CSR automated type for TSU_HOST_INT_STATUS_CLEAR */
/*
 * EPS Address Error Interrupt status clear register. 1b per source (1=source
 * will be cleared from int_status register when kick is called).
 */
struct psif_csr_host_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_status_clear [64 bits] */

/* CSR automated type for TSU_HOST_INT_STATUS_CLEAR_KICK */
/* Trigger the EPS Address Error int_status clear operation. */
struct psif_csr_host_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_HOST_EPS_ADDRESS */
/*
 * EPS address which caused the int_status.eps_address_invalid to get set.
 */
struct psif_csr_host_eps_address {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_eps_address [64 bits] */

/* CSR automated type for TSU_HOST_ECC_PARITY_ERRS */
/* ECC and Parity Errors status register. */
struct psif_csr_host_ecc_parity_errs {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_ecc_parity_errs [64 bits] */

/* CSR automated type for TSU_HOST_FATAL_INT_MASK */
/*
 * Fatal Interrupt and Stop Mask register. 1b per source (interrupt masks:
 * 1=masked, stop-masks: 1=error does not cause host to stop processing) ECC,
 * or CAM Parity error if enabled, will cause a fatal interrupt. Decide
 * whether or not to stop all host processing when this error occurs.
 */
struct psif_csr_host_fatal_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	ecc_fatal_stop_mask:1; /* 1 bits @ offs 0:0 */
	u64	cam_fatal_mask:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_fatal_int_mask [64 bits] */

/* CSR automated type for TSU_HOST_INT_CTRL */
/* Interrupt Total Moderation */
struct psif_csr_host_int_ctrl {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_ctrl [64 bits] */

/* CSR automated type for TSU_HOST_INT_CHAN_CTRL_0 */
/* Interrupt Channel Control 0 */
struct psif_csr_host_int_chan_ctrl_0 {
	/* *** 64 bit group 0 start *** */
	u64	channel_rate_high:20; /* 20 bits @ offs 0:0 */
	u64	channel_rate_low:20; /* 20 bits @ offs 0:20 */
	u64	channel_rx_scale:4; /* 4 bits @ offs 0:40 */
	u64	channel_adaptive:1; /* 1 bits @ offs 0:44 */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:45 */
	u64	msix_vector_id:6; /* 6 bits @ offs 0:51 */
	u64	:7; /* 7 bits @ offs 0:57 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_chan_ctrl_0 [64 bits] */

/* CSR automated type for TSU_HOST_INT_CHAN_CTRL_1 */
/* Interrupt Channel Control 1 */
struct psif_csr_host_int_chan_ctrl_1 {
	/* *** 64 bit group 0 start *** */
	u16	channel_ausec_high; /* 16 bits @ offs 0:0 */
	u16	channel_ausec_low; /* 16 bits @ offs 0:16 */
	u16	channel_ausec; /* 16 bits @ offs 0:32 */
	u16	:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_chan_ctrl_1 [64 bits] */

/* CSR automated type for TSU_HOST_INT_CHAN_CTRL_2 */
/* Interrupt Channel Control 2 */
struct psif_csr_host_int_chan_ctrl_2 {
	/* *** 64 bit group 0 start *** */
	u16	channel_pusec_high; /* 16 bits @ offs 0:0 */
	u16	channel_pusec_low; /* 16 bits @ offs 0:16 */
	u16	channel_pusec; /* 16 bits @ offs 0:32 */
	u16	:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_host_int_chan_ctrl_2 [64 bits] */

/* CSR automated type for TSU_MMU_MMU_CONFIG */
/* MMU Static-Configuration and Status */
struct psif_csr_mmu_config {
	/* *** 64 bit group 0 start *** */
	u16	cam_evict_cntr_prescale_sel:3; /* 3 bits @ offs 0:0 */
	u16	cam_evict_cntr_cnt_sel:5; /* 5 bits @ offs 0:3 */
	u16	ptwc_evict_algorithm:1; /* 1 bits @ offs 0:8 */
	u16	mmuc_evict_algorithm:1; /* 1 bits @ offs 0:9 */
	u16	random_evict:1; /* 1 bits @ offs 0:10 */
	u16	mmuc_hash_select:1; /* 1 bits @ offs 0:11 */
	u16	ptwc_hash_select:1; /* 1 bits @ offs 0:12 */
	u16	swap_rsp:1; /* 1 bits @ offs 0:13 */
	u16	chk_upper_addr_bits:1; /* 1 bits @ offs 0:14 */
	u16	chk_bit_sixty_three:1; /* 1 bits @ offs 0:15 */
	u16	bit_sixty_three_value:1; /* 1 bits @ offs 0:16 */
	u16	sparc_pages:1; /* 1 bits @ offs 0:17 */
	u16	dma_cnt_mask:8; /* 8 bits @ offs 0:18 */
	u16	hash_slide_sel:2; /* 2 bits @ offs 0:26 */
	u16	mmuc_way_config_sel:2; /* 2 bits @ offs 0:28 */
	u16	dis_table_ptr_trans:1; /* 1 bits @ offs 0:30 */
	u16	cam_par_err_fatal:1; /* 1 bits @ offs 0:31 */
	u16	ta_upper_twelve:12; /* 12 bits @ offs 0:32 */
	u16	:4; /* 4 bits @ offs 0:44 */
	u16	pa_upper_twelve:12; /* 12 bits @ offs 0:48 */
	u16	:4; /* 4 bits @ offs 0:60 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_config [64 bits] */

/* CSR automated type for TSU_MMU_CREDIT_CONFIG */
/* MMU Credit Configuration */
struct psif_csr_mmu_credit_config {
	/* *** 64 bit group 0 start *** */
	u64	mmu_llq_non_e_csr_cred:9; /* 9 bits @ offs 0:0 */
	u64	mmu_llq_gen_credit:9; /* 9 bits @ offs 0:9 */
	u64	eps_llq_credit:9; /* 9 bits @ offs 0:18 */
	u64	:37; /* 37 bits @ offs 0:27 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_credit_config [64 bits] */

/* CSR automated type for TSU_MMU_PA_MASK */
/* PA Address Size Configuration */
struct psif_csr_mmu_pa_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:20; /* 20 bits @ offs 0:0 */
	u64	:44; /* 44 bits @ offs 0:20 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_pa_mask [64 bits] */

/* CSR automated type for TSU_MMU_FLUSH_CACHES */
/* Flush MMU and-or PTW Caches. */
struct psif_csr_mmu_flush_caches {
	/* *** 64 bit group 0 start *** */
	u64	flush_mmu_cache:1; /* 1 bits @ offs 0:0 */
	u64	flush_ptw_cache:1; /* 1 bits @ offs 0:1 */
	u64	mmu_cache_flushed:1; /* 1 bits @ offs 0:2 */
	u64	ptw_cache_flushed:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_flush_caches [64 bits] */

/* CSR automated type for TSU_MMU_STAT_COUNTERS */
/* Statistic Counters. */
struct psif_csr_mmu_stat_counters {
	/* *** 64 bit group 0 start *** */
	u16	mmuc_entry_cnt:13; /* 13 bits @ offs 0:0 */
	u16	:3; /* 3 bits @ offs 0:13 */
	u64	mmuc_entry_evict_cnt:8; /* 8 bits @ offs 0:16 */
	u64	host_cmd_cnt:9; /* 9 bits @ offs 0:24 */
	u64	:3; /* 3 bits @ offs 0:33 */
	u64	miss_llq_entry_cnt:9; /* 9 bits @ offs 0:36 */
	u64	:3; /* 3 bits @ offs 0:45 */
	u64	mmu_llq_entry_cnt:9; /* 9 bits @ offs 0:48 */
	u64	:7; /* 7 bits @ offs 0:57 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_stat_counters [64 bits] */

/* CSR automated type for TSU_MMU_ECC_PARITY_ERRS */
/* ECC and Parity Errors. */
struct psif_csr_mmu_ecc_parity_errs {
	/* *** 64 bit group 0 start *** */
	u64	data:17; /* 17 bits @ offs 0:0 */
	u64	:47; /* 47 bits @ offs 0:17 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_ecc_parity_errs [64 bits] */

/* CSR automated type for TSU_MMU_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_mmu_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_uf_control [64 bits] */

/* CSR automated type for TSU_MMU_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_mmu_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_uf_control_kick [64 bits] */

/* CSR automated type for TSU_MMU_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_mmu_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_int_status [64 bits] */

/* CSR automated type for TSU_MMU_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_mmu_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_int_mask [64 bits] */

/* CSR automated type for TSU_MMU_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_mmu_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_int_pri [64 bits] */

/* CSR automated type for TSU_MMU_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_mmu_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_int_status_clear [64 bits] */

/* CSR automated type for TSU_MMU_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_mmu_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_MMU_UNCOR_ERR_MASK */
/* Uncorrectable-Fatal Error Mask */
struct psif_csr_mmu_uncor_err_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_mmu_uncor_err_mask [64 bits] */

/* CSR automated type for TSU_CBU_TVL_TABLE */
/*
 * TSU VL mapping table for requests. Inputs/addressing to this table are
 * {UF, tsu_qosl (High/Low BAR), tsu_sl}.
 */
struct psif_csr_tvl_table {
	/* *** 64 bit group 0 start *** */
	/* tsu_vl(7[0] bits)TSU Virtual Lane. */
	u64	data:7; /* 7 bits @ offs 0:0 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_tvl_table [64 bits] */

/* CSR automated type for TSU_CBU_SUB_BAR_ADDR */
/*
 * Below dcb_bar address is a write to the VCB, else write to the DCB.
 * dcb_bar = 0 applies no VCB. Below this qosl_bar address is low BAR, else
 * is high BAR. Inputs/addressing to this table is UF.
 */
struct psif_csr_sub_bar_addr {
	/* *** 64 bit group 0 start *** */
	u32	qosl_bar:14; /* 14 bits @ offs 0:0 */
	u32	:18; /* 18 bits @ offs 0:14 */
	u32	dcb_bar:15; /* 15 bits @ offs 0:32 */
	u32	:17; /* 17 bits @ offs 0:47 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sub_bar_addr [64 bits] */

/* CSR automated type for TSU_CBU_VCB_START_OFFSET */
/*
 * Virtual collect buffer start offset. VCB#=vcb_start_offset + pio
 * address[25:12]. Inputs/addressing to this table is UF.
 */
struct psif_csr_vcb_start {
	/* *** 64 bit group 0 start *** */
	u64	data:14; /* 14 bits @ offs 0:0 */
	u64	:50; /* 50 bits @ offs 0:14 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_vcb_start [64 bits] */

/* CSR automated type for TSU_CBU_PCB_ALLOC_HIGH */
/*
 * How many physical collect buffers are allocated to the high BAR.
 * Inputs/addressing to this table is UF.
 */
struct psif_csr_pcb_alloc_high {
	/* *** 64 bit group 0 start *** */
	/* cb_addr(11[0] bits)Address to the collect buffers. */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_pcb_alloc_high [64 bits] */

/* CSR automated type for TSU_CBU_PCB_ALLOC_LOW */
/*
 * How many physical collect buffers are allocated to the low BAR.
 * Inputs/addressing to this table is UF.
 */
struct psif_csr_pcb_alloc_low {
	/* *** 64 bit group 0 start *** */
	/* cb_addr(11[0] bits)Address to the collect buffers. */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_pcb_alloc_low [64 bits] */

/* CSR automated type for TSU_CBU_PCB_AVAILABLE */
/*
 * How many physical collect buffers are available. Inputs/addressing to this
 * table is UF.
 */
struct psif_csr_pcb_available {
	/* *** 64 bit group 0 start *** */
	/* cb_addr(11[0] bits)Address to the collect buffers. */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_pcb_available [64 bits] */

/* CSR automated type for TSU_CBU_PCB_HIGH_USED */
/*
 * How many physical collect buffers are used in high BAR. Inputs/addressing
 * to this table is UF.
 */
struct psif_csr_pcb_used_high {
	/* *** 64 bit group 0 start *** */
	/* cb_addr(11[0] bits)Address to the collect buffers. */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_pcb_used_high [64 bits] */

/* CSR automated type for TSU_CBU_PCB_LOW_USED */
/*
 * How many physical collect buffers are used in low BAR. Inputs/addressing
 * to this table is UF.
 */
struct psif_csr_pcb_used_low {
	/* *** 64 bit group 0 start *** */
	/* cb_addr(11[0] bits)Address to the collect buffers. */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_pcb_used_low [64 bits] */

/* CSR automated type for TSU_CBU_SCBD_INIT */
/* scoreboard init. */
struct psif_csr_scbd_init {
	/* *** 64 bit group 0 start *** */
	u64	dcb:1; /* 1 bits @ offs 0:0 */
	u64	vcb:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_scbd_init [64 bits] */

/* CSR automated type for TSU_CBU_SCBD_INIT_DONE */
/* scoreboard init done status. */
struct psif_csr_scbd_fini {
	/* *** 64 bit group 0 start *** */
	u64	dcb:1; /* 1 bits @ offs 0:0 */
	u64	vcb:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_scbd_fini [64 bits] */

/* CSR automated type for TSU_CBU_DCB_START_OFFSET_HOST */
/* Start offset of dedicated collect buffers number for the host driver. */
struct psif_csr_dcb_start_offset_host {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dcb_start_offset_host [64 bits] */

/* CSR automated type for TSU_CBU_DCB_START_OFFSET_EPS */
/* Start offset of dedicated collect buffers number for the eps. */
struct psif_csr_dcb_start_offset_eps {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dcb_start_offset_eps [64 bits] */

/* CSR automated type for TSU_CBU_DCB_START_OFFSET_SQS */
/*
 * Start offset of dedicated collect buffers number for the send queue
 * scheduler.
 */
struct psif_csr_dcb_start_offset_sqs {
	/* *** 64 bit group 0 start *** */
	u64	num:8; /* 8 bits @ offs 0:0 */
	u64	dcb_sqs_disable:1; /* 1 bits @ offs 0:8 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dcb_start_offset_sqs [64 bits] */

/* CSR automated type for TSU_CBU_COLLECT_LEN_ROUNDUP */
/* Collect length round up to 64B for scoreboard. */
struct psif_csr_cbu_collect_len_roundup {
	/* *** 64 bit group 0 start *** */
	u64	pio:1; /* 1 bits @ offs 0:0 */
	u64	eps:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_collect_len_roundup [64 bits] */

/* CSR automated type for TSU_CBU_ECC_ERR_CTRL */
/* ECC error control */
struct psif_csr_cbu_ecc_err_ctrl {
	/* *** 64 bit group 0 start *** */
	u64	mask_fatal_interrupt:1; /* 1 bits @ offs 0:0 */
	u64	uncorrectable_err_stop:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_ecc_err_ctrl [64 bits] */

/* CSR automated type for TSU_CBU_ECC_ERR_STATUS */
/* ECC status */
struct psif_csr_cbu_ecc_err_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_ecc_err_status [64 bits] */

/* CSR automated type for TSU_CBU_ECC_ERR_STATUS_CLEAR */
/* ECC status */
struct psif_csr_cbu_ecc_err_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_ecc_err_status_clear [64 bits] */

/* CSR automated type for TSU_CBU_CHOKE */
/* Per UF to drop PIO. Inputs/addressing to this table is UF. */
struct psif_csr_cbu_choke {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_choke [64 bits] */

/* CSR automated type for TSU_CBU_UF_STATUS */
/* UF choke status. Inputs/addressing to this table is UF. */
struct psif_csr_cbu_uf_status {
	/* *** 64 bit group 0 start *** */
	u32	vcb_active_cnt:15; /* 15 bits @ offs 0:0 */
	u32	:17; /* 17 bits @ offs 0:15 */
	u32	choke_done:1; /* 1 bits @ offs 0:32 */
	u32	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_uf_status [64 bits] */

/* CSR automated type for TSU_CBU_VCB_CLEAR_NUM */
/* vcb clear CB number. Inputs/addressing to this table is scoreboard table. */
struct psif_csr_cbu_vcb_clear_num {
	/* *** 64 bit group 0 start *** */
	u64	data:14; /* 14 bits @ offs 0:0 */
	u64	:50; /* 50 bits @ offs 0:14 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_vcb_clear_num [64 bits] */

/* CSR automated type for TSU_CBU_VCB_CLEAR */
/*
 * vcb clear. Inputs/addressing to this table is scoreboard table. Write to
 * clear VCB, Read to get the scoreboard status
 */
struct psif_csr_cbu_vcb_clear {
	/* *** 64 bit group 0 start *** */
	u64	scoreboard:40; /* 40 bits @ offs 0:0 */
	u64	overrun:1; /* 1 bits @ offs 0:40 */
	u64	:7; /* 7 bits @ offs 0:41 */
	u64	pcb_num:10; /* 10 bits @ offs 0:48 */
	u64	:6; /* 6 bits @ offs 0:58 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_vcb_clear [64 bits] */

/* CSR automated type for TSU_CBU_DCB_START_OFFSET */
/* PIO DCB start_offset. Inputs/addressing to this table is UF. */
struct psif_csr_cbu_dcb_start_offset {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_dcb_start_offset [64 bits] */

/* CSR automated type for TSU_CBU_DCB_UF_TABLE */
/*
 * Table to contain UF number for each DCB. EPS/Host drive has to write UF #
 * to this table before it writes to the DCB. Inputs/addressing to this table
 * is DCB#
 */
struct psif_csr_dcb_uf_table {
	/* *** 64 bit group 0 start *** */
	u64	data:6; /* 6 bits @ offs 0:0 */
	u64	:58; /* 58 bits @ offs 0:6 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dcb_uf_table [64 bits] */

/* CSR automated type for TSU_CBU_DCB_STATUS_HW_LOCK */
/*
 * Status state of each DCB. The EPS/Host drive has to read this table to
 * claim a DCB. Inputs/addressing to this table is DCB#
 */
struct psif_csr_cbu_dcb_status_hw_lock {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_dcb_status_hw_lock [64 bits] */

/* CSR automated type for TSU_CBU_DCB_STATUS */
/* Status state of each DCB. Inputs/addressing to this table is DCB# */
struct psif_csr_dcb_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dcb_status [64 bits] */

/* CSR automated type for TSU_CBU_DCB_CLEAR */
/* dcb clear. Inputs/addressing to this table is scoreboard table. */
struct psif_csr_cbu_dcb_clear {
	/* *** 64 bit group 0 start *** */
	u64	scoreboard:40; /* 40 bits @ offs 0:0 */
	u64	overrun:1; /* 1 bits @ offs 0:40 */
	u64	:7; /* 7 bits @ offs 0:41 */
	u64	pcb_num:10; /* 10 bits @ offs 0:48 */
	u64	:6; /* 6 bits @ offs 0:58 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_dcb_clear [64 bits] */

/* CSR automated type for TSU_CBU_DCB_DOORBELL */
/*
 * DCB doorbell header/payload memory from EPS-C. Address[13:6] = DCB number
 * and Address[5:0] = 8 bytes offset into the DCB.
 */
struct psif_csr_cbu_dcb_doorbell {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cbu_dcb_doorbell [64 bits] */

/* CSR automated type for TSU_RQS_PRIVATE_CMPL_CREDIT */
/*
 * Initial completion credit per TVL. This is private credit for the
 * particular TVL and can only be used by this TVL. The private completion
 * credit indicates how many entries in tsu_cmpl are reserved for requests on
 * this TVL.
 */
struct psif_csr_cmpl_credit_private {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_credit_private [64 bits] */

/* CSR automated type for TSU_RQS_TVL_CMPL_CREDIT_CONSUMED */
/*
 * Current completion credits used per TVL. This is credit currently used by
 * a particular TVL. This register is updated by hardware and can be read by
 * software.
 */
struct psif_csr_cmpl_credit_tvl_consumed {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_credit_tvl_consumed [64 bits] */

/* CSR automated type for TSU_RQS_COMMON_CMPL_CREDIT */
/*
 * Initial completion credit for the free pool. The free pool can be used by
 * anyone being set up to use common credits. This is additional credits
 * which can be used in addition to the private TVL completion credit. The
 * common completion credit indicates how many entries in tsu_cmpl can be
 * used by any TVL. It is a restriction that the TVL is set up to use common
 * credit.
 */
struct psif_csr_cmpl_credit_common {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_credit_common [64 bits] */

/* CSR automated type for TSU_RQS_COMMON_CMPL_CREDIT_CONSUMED */
/*
 * This is register contain the number of currently consumed common
 * completion credits. This register is updated by hardware and can be read
 * from software.
 */
struct psif_csr_cmpl_credit_common_consumed {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_credit_common_consumed [64 bits] */

/* CSR automated type for TSU_RQS_PRIVATE_EXEC_CREDIT */
/*
 * Initial execution credit per TVL. This is private credit for the
 * particular TVL and can only be used by this TVL. The credit indicates how
 * many DMA contexts are reserved for this particular TVL
 */
struct psif_csr_exec_credit_private {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_exec_credit_private [64 bits] */

/* CSR automated type for TSU_RQS_TVL_EXEC_CREDIT_CONSUMED */
/*
 * Current execution credit used per TVL. This is credit used by a particular
 * TVL. This register is updated by hardware and can be read by software.
 */
struct psif_csr_exec_credit_tvl_consumed {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_exec_credit_tvl_consumed [64 bits] */

/* CSR automated type for TSU_RQS_COMMON_EXEC_CREDIT */
/*
 * Initial execution credit for the free pool. The free pool can be used by
 * anyone being set up to use common credits. This is additional credits
 * which can be used in addition to the private TVL execution credit. The
 * common execution credit indicates how many DMA contexts can be used by any
 * TVL. It is a restriction that the TVL is set up to use common credit.
 */
struct psif_csr_exec_credit_common {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_exec_credit_common [64 bits] */

/* CSR automated type for TSU_RQS_COMMON_EXEC_CREDIT_CONSUMED */
/*
 * This register contain the number of currently consumed common execution
 * credits. The register is updated by hardware and can be read from
 * software.
 */
struct psif_csr_exec_credit_common_consumed {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_exec_credit_common_consumed [64 bits] */

struct psif_sl2vl {
	/* *** 64 bit group 0 start *** */
	/* VL for SL15. */
	u16	sl15:3; /* 3 bits @ offs 0:0 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:3 */
	/* VL for SL14. */
	u16	sl14:3; /* 3 bits @ offs 0:4 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:7 */
	/* VL for SL13. */
	u16	sl13:3; /* 3 bits @ offs 0:8 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:11 */
	/* VL for SL12. */
	u16	sl12:3; /* 3 bits @ offs 0:12 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:15 */
	/* VL for SL11. */
	u16	sl11:3; /* 3 bits @ offs 0:16 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:19 */
	/* VL for SL1O. */
	u16	sl10:3; /* 3 bits @ offs 0:20 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:23 */
	/* VL for SL9. */
	u16	sl9:3; /* 3 bits @ offs 0:24 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:27 */
	/* VL for SL8. */
	u16	sl8:3; /* 3 bits @ offs 0:28 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:31 */
	/* VL for SL7. */
	u16	sl7:3; /* 3 bits @ offs 0:32 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:35 */
	/* VL for SL6. */
	u16	sl6:3; /* 3 bits @ offs 0:36 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:39 */
	/* VL for SL5. */
	u16	sl5:3; /* 3 bits @ offs 0:40 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:43 */
	/* VL for SL4. */
	u16	sl4:3; /* 3 bits @ offs 0:44 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:47 */
	/* VL for SL3. */
	u16	sl3:3; /* 3 bits @ offs 0:48 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:51 */
	/* VL for SL2. */
	u16	sl2:3; /* 3 bits @ offs 0:52 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:55 */
	/* VL for SL1. */
	u16	sl1:3; /* 3 bits @ offs 0:56 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:59 */
	/* VL for SLO. */
	u16	sl0:3; /* 3 bits @ offs 0:60 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_sl2vl [64 bits] */

/* CSR automated type for TSU_RQS_P{1,2}_SL2VL */
/*
 * Port1 SL to VL mapping tables. One entry in this table is the SL to VL
 * mapping table for one UF.
 */
struct psif_csr_sl2vl {
	/* *** 64 bit group 0 start *** */
	struct psif_sl2vl	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sl2vl [64 bits] */

/* CSR automated type for TSU_RQS_P{1,2}_OWN_LID_BASE */
/*
 * Own LIDs base and LMC. Potentially all own LID bits come from the QP state
 * entry. The number of bits to use is based on the LMC. Per UF register.
 */
struct psif_csr_own_lid_base {
	/* *** 64 bit group 0 start *** */
	u64	gid_flag:1; /* 1 bits @ offs 0:0 */
	/* lmc(3[0] bits)LID Mask Control data type. */
	u64	lmc:3; /* 3 bits @ offs 0:1 */
	/* ib_lrh_lid(16[0] bits)Local ID */
	u64	lid_base:16; /* 16 bits @ offs 0:4 */
	u64	:44; /* 44 bits @ offs 0:20 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_own_lid_base [64 bits] */

/* CSR automated type for TSU_RQS_P{1,2}_PORT_ENABLE */
/*
 * Port1 enable bits per UF. If bit is set, the corresponding GID and LID
 * table entries are valid.
 */
struct psif_csr_port_enable {
	/* *** 64 bit group 0 start *** */
	/* num_uf(35[0] bits)Number of universal functions. */
	u64	data:35; /* 35 bits @ offs 0:0 */
	u64	:29; /* 29 bits @ offs 0:35 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_port_enable [64 bits] */

/* CSR automated type for TSU_RQS_P{1,2}_SMP_ALLOWED */
/*
 * Register with a bit per UF/VHCA indicating if the UF/VHCA is allowed to
 * send SMPs.
 */
struct psif_csr_rqs_smp_allowed {
	/* *** 64 bit group 0 start *** */
	/* num_vhca(33[0] bits)Number of vHCAs. */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqs_smp_allowed [64 bits] */

/* CSR automated type for TSU_RQS_KICK_FIFO_UF_INUSE */
/* Kick FIFO entries in use per UF */
struct psif_csr_rqs_kick_fifo_uf_inuse {
	/* *** 64 bit group 0 start *** */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqs_kick_fifo_uf_inuse [64 bits] */

/* CSR automated type for TSU_RQS_P{1,2}_GID_FORWARDING_TABLE */
/*
 * GID forwarding table. The forwarding table is used to figure out if a
 * packet should be sent in loopback or not. There are (2 * NUM_VHCA + 1) 67
 * GIDs per physical IB port.
 */
struct psif_csr_rqs_gid_forwarding_table {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqs_gid_forwarding_table [64 bits] */

/* CSR automated type for TSU_DMA_MAX_ALLOC_VL_BUFF */
/*
 * Per VL register (0-7: Port 0 VL0-7, 8: Port 0 VL15, 9: Port0 loopback.
 * 10-19: Port 1). Maximum global buffer a particular VL can get.
 */
struct psif_csr_vl_buff_max_alloc {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_vl_buff_max_alloc [64 bits] */

/* CSR automated type for TSU_DMA_PRIVATE_VL_BUFF */
/*
 * Per VL register (0-7: Port0 VL0-7, 8: Port0 VL15, 9: Port0 loopback.
 * 10-19: Port 1). The amount of buffer dedicated to this VL.
 */
struct psif_csr_vl_buff_private {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_vl_buff_private [64 bits] */

/* CSR automated type for TSU_DMA_VL_BUFF_USED */
/*
 * Per VL register (0-7: Port0 VL0-7, 8: Port0 VL15, 9: Port0 loopback.
 * 10-19: Port 1). The amount of dedicated and global buffer used to this VL.
 */
struct psif_csr_vl_buff_used {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_vl_buff_used [64 bits] */

/* CSR automated type for TSU_DMA_GLOBAL_BUFF_USED */
/* Amount of global buffer used shared among all VLs. */
struct psif_csr_global_buff_used {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_global_buff_used [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_BUF_CO */
/* Num of 256B block DMA buffer check-out */
struct psif_csr_num_of_dma_buf_co {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_buf_co [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_BUF_CI */
/* Num of 256B block DMA buffer check-in */
struct psif_csr_num_of_dma_buf_ci {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_buf_ci [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_CNTXTLLQ_INBUN */
/* Number of RQS command to DMA */
struct psif_csr_num_of_dma_cntxtllq_inbun {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_cntxtllq_inbun [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_CNTXTLLQ_POP */
/* Number of Context LLQ pop */
struct psif_csr_num_of_dma_cntxtllq_pop {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_cntxtllq_pop [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_CNTXTLLQ_R2G */
/* Number of Context LLQ ready to go set */
struct psif_csr_num_of_dma_cntxtllq_r2g {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_cntxtllq_r2g [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_IBPB_CMD */
/* Number of IBPB command from DMA */
struct psif_csr_num_of_dma_ibpb_cmd {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_ibpb_cmd [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_CMPL_CMD */
/* Number of CMPL command from DMA */
struct psif_csr_num_of_dma_cmpl_cmd {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_cmpl_cmd [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_QPS_RD_CMD */
/* Number of QPS RD command from DMA */
struct psif_csr_num_of_dma_qps_rd_cmd {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_qps_rd_cmd [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_QPS_RD_RSP */
/* Number of QPS RD response from QPS */
struct psif_csr_num_of_dma_qps_rd_rsp {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_qps_rd_rsp [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_QPS_WR_CMD */
/* Number of QPS WR command from DMA */
struct psif_csr_num_of_dma_qps_wr_cmd {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_qps_wr_cmd [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_QPS_WR_RSP */
/* Number of QPS WR response from QPS */
struct psif_csr_num_of_dma_qps_wr_rsp {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_qps_wr_rsp [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_PKTLLQ_INBUN */
/* Number of packet in the packet LLQ */
struct psif_csr_num_of_dma_pktllq_inbun {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_pktllq_inbun [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_PKTLLQ_POP */
/* Number of Packet LLQ pop */
struct psif_csr_num_of_dma_pktllq_pop {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_pktllq_pop [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_PKTLLQ_R2G */
/* Number of Packet LLQ ready to go set */
struct psif_csr_num_of_dma_pktllq_r2g {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_pktllq_r2g [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_PYLD_CMD */
/* Num of payload DMA command */
struct psif_csr_num_of_dma_pyld_cmd {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_pyld_cmd [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_PYLD_RSP */
/* Num of payload DMA response */
struct psif_csr_num_of_dma_pyld_rsp {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_pyld_rsp [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_SGE_CMD */
/* Num of sge DMA command */
struct psif_csr_num_of_dma_sge_cmd {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_sge_cmd [64 bits] */

/* CSR automated type for TSU_DMA_NUM_OF_SGE_RSP */
/* Num of sge DMA response */
struct psif_csr_num_of_dma_sge_rsp {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_num_of_dma_sge_rsp [64 bits] */

/* CSR automated type for TSU_DMA_LSO_BUF_USED */
/* Num of LSO buffer used */
struct psif_csr_dma_lso_buf_used {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_lso_buf_used [64 bits] */

/* CSR automated type for TSU_DMA_ECC_ERR_CTRL */
/* ECC error control */
struct psif_csr_dma_ecc_err_ctrl {
	/* *** 64 bit group 0 start *** */
	u64	mask_fatal_interrupt:1; /* 1 bits @ offs 0:0 */
	u64	uncorrectable_err_stop:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_ecc_err_ctrl [64 bits] */

/* CSR automated type for TSU_DMA_ECC_ERR_STATUS */
/* ECC status */
struct psif_csr_dma_ecc_err_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_ecc_err_status [64 bits] */

/* CSR automated type for TSU_DMA_ECC_ERR_STATUS_CLEAR */
/* ECC status */
struct psif_csr_dma_ecc_err_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_ecc_err_status_clear [64 bits] */

/* CSR automated type for TSU_DMA_LINK_SPEED */
/*
 * IB link speed per port. 0=EDR, 1=QDR, 2=DDR, 3=SDR. Address to the
 * Register Table: {uf, port}
 */
struct psif_csr_link_speed {
	/* *** 64 bit group 0 start *** */
	u64	data:2; /* 2 bits @ offs 0:0 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_link_speed [64 bits] */

/* CSR automated type for TSU_DMA_LINK_WIDTH */
/*
 * IB link width per port. 0=X4 and 1=X1. Address to the Register Table: {uf,
 * port}
 */
struct psif_csr_link_width {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_link_width [64 bits] */

/* CSR automated type for TSU_DMA_UF_TRANS_MAX */
/*
 * Maximum number of payload read 256B buffer per UF. Address to the Register
 * Table:uf
 */
struct psif_csr_dma_uf_trans_max {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_uf_trans_max [64 bits] */

/* CSR automated type for TSU_DMA_UF_TRANS_USED */
/* Number of payload read transaction per UF. Address to the Register Table:uf */
struct psif_csr_dma_uf_trans_used {
	/* *** 64 bit group 0 start *** */
	u64	data:9; /* 9 bits @ offs 0:0 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_uf_trans_used [64 bits] */

/* CSR automated type for TSU_DMA_MAC_ADDR0_TABLE */
/*
 * MAC address #0 table for uf 0-33. Inputs/addressing to this table are {UF,
 * port}.
 */
struct psif_csr_dma_mac_addr0_table {
	/* *** 64 bit group 0 start *** */
	u64	mac_addr0_table:48; /* 48 bits @ offs 0:0 */
	u64	valid:1; /* 1 bits @ offs 0:48 */
	u64	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_mac_addr0_table [64 bits] */

/* CSR automated type for TSU_DMA_MAC_ADDR1_TABLE */
/*
 * MAC address #1 table for uf 0-33. Inputs/addressing to this table are {UF,
 * port}.
 */
struct psif_csr_dma_mac_addr1_table {
	/* *** 64 bit group 0 start *** */
	u64	mac_addr1_table:48; /* 48 bits @ offs 0:0 */
	u64	valid:1; /* 1 bits @ offs 0:48 */
	u64	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_mac_addr1_table [64 bits] */

/* CSR automated type for TSU_DMA_VID_TABLE */
/*
 * VID table for uf 0-33. Inputs/addressing to this table are {UF, port,
 * index}.
 */
struct psif_csr_dma_vid_table {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_vid_table [64 bits] */

/* CSR automated type for TSU_DMA_MAC_CTRL */
/* MAC control per port per UF 0-33. Address to the Register Table: {uf port} */
struct psif_csr_dma_mac_ctrl {
	/* *** 64 bit group 0 start *** */
	u64	vlan_enforce:1; /* 1 bits @ offs 0:0 */
	u64	double_vlan:1; /* 1 bits @ offs 0:1 */
	u64	smac_enforce:1; /* 1 bits @ offs 0:2 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_mac_ctrl [64 bits] */

/* CSR automated type for TSU_DMA_PPTY_HDR_LENGTH */
/* Size of the EoIB and IPoIB header */
struct psif_csr_dma_ppty_hdr_length {
	/* *** 64 bit group 0 start *** */
	u64	ipoib:2; /* 2 bits @ offs 0:0 */
	u64	eoib:2; /* 2 bits @ offs 0:2 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_ppty_hdr_length [64 bits] */

/* CSR automated type for TSU_DMA_TCP_FLAGS_MASK */
/* Mask bit to the TCP flags for the LSO segments */
struct psif_csr_dma_tcp_flags_mask {
	/* *** 64 bit group 0 start *** */
	u16	last:9; /* 9 bits @ offs 0:0 */
	u16	:7; /* 7 bits @ offs 0:9 */
	u16	middle:9; /* 9 bits @ offs 0:16 */
	u16	:7; /* 7 bits @ offs 0:25 */
	u32	first:9; /* 9 bits @ offs 0:32 */
	u32	:23; /* 23 bits @ offs 0:41 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_tcp_flags_mask [64 bits] */

/* CSR automated type for TSU_DMA_OFFLOAD_CTRL */
/* Control for ip checksum tcp checksum udp checksum and ethernet padding */
struct psif_csr_dma_offload_ctrl {
	/* *** 64 bit group 0 start *** */
	u64	pad_eth:1; /* 1 bits @ offs 0:0 */
	u64	inv_0_udp_chksum:1; /* 1 bits @ offs 0:1 */
	u64	inv_0_tcp_chksum:1; /* 1 bits @ offs 0:2 */
	u64	inv_0_ip_chksum:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_offload_ctrl [64 bits] */

/* CSR automated type for TSU_DMA_VLAN_MEMBER_TABLE */
/*
 * VLAN membership table per UF 0-33. Inputs/addressing to this table is {UF,
 * vid[11:6}}.
 */
struct psif_csr_dma_vlan_member_table {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_vlan_member_table [64 bits] */

/* CSR automated type for TSU_DMA_OUTER_VLAN_TYPE */
/* Outer VLAN Ethernet type */
struct psif_csr_dma_outer_vlan_type {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_outer_vlan_type [64 bits] */

/* CSR automated type for TSU_DMA_INNER_VLAN_TYPE */
/* Outer VLAN Ethernet type */
struct psif_csr_dma_inner_vlan_type {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dma_inner_vlan_type [64 bits] */

/* CSR automated type for TSU_IBPB_P{1,2}_PKEY_TABLE */
/* Shared P-Key table for all UFs on this port. */
struct psif_csr_snd_pkey_table {
	/* *** 64 bit group 0 start *** */
	/* ib_bth_pkey(16[0] bits)Partition Key */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_snd_pkey_table [64 bits] */

/* CSR automated type for TSU_IBPB_P{1,2}_GID_UPPER */
/*
 * Upper 64 bits of GID for port1. There are (2 * NUM_VHCA + 1) 67 GIDs per
 * physical IB port.
 */
struct psif_csr_ibpb_gid_upper {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpb_gid_upper [64 bits] */

/* CSR automated type for TSU_IBPB_P{1,2}_GID_LOWER */
/*
 * Lower 64 bits of GID for port1. There are (2 * NUM_VHCA + 1) 67 GIDs per
 * physical IB port.
 */
struct psif_csr_ibpb_gid_lower {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpb_gid_lower [64 bits] */

/* CSR automated type for TSU_IBPB_P{1,2}_OWN_LID_BASE */
/*
 * Own LIDs base and LMC. Potentially all own LID bits come from the QP state
 * entry. The number of bits to use is based on the LMC. Per UF register.
 */
struct psif_csr_snd_lid {
	/* *** 64 bit group 0 start *** */
	/* lmc(3[0] bits)LID Mask Control data type. */
	u64	lmc:3; /* 3 bits @ offs 0:0 */
	/* ib_lrh_lid(16[0] bits)Local ID */
	u64	lid_base:16; /* 16 bits @ offs 0:3 */
	u64	:45; /* 45 bits @ offs 0:19 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_snd_lid [64 bits] */

/* CSR automated type for TSU_IBPB_P{1,2}_PKEY_UF_STRIDE */
/*
 * Size of individual P-Key tables per UF. All UFs have the same size or if
 * set to 0, it means one common table.
 */
struct psif_csr_snd_pkey_uf_stride {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_snd_pkey_uf_stride [64 bits] */

/* CSR automated type for TSU_QPS_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_qps_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_uf_control [64 bits] */

/* CSR automated type for TSU_QPS_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_qps_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_uf_control_kick [64 bits] */

/* CSR automated type for TSU_QPS_UF_EMPTY */
/*
 * Bitvector indicating (one bit per UF) if a UF has entries in tsu_qps or
 * not. This could be used to verify that a UF flush has happened. XXX:
 * Should there be multiple registers or one register per UF?
 */
struct psif_csr_uf_empty {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_uf_empty [64 bits] */

/* Interrupt bit definitions for TSU QPS. */
struct psif_qps_int_definition {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:62; /* 62 bits @ offs 0:0 */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:62 */
	/* Modify/Query QP bit. */
	u64	modify_query:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_qps_int_definition [64 bits] */

/* CSR automated type for TSU_QPS_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_qps_int_status {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Modify/Query QP bit. */
	u64	modify_query:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_qps_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_int_status [64 bits] */

/* CSR automated type for TSU_QPS_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_qps_int_mask {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Modify/Query QP bit. */
	u64	modify_query:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_qps_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_int_mask [64 bits] */

/* CSR automated type for TSU_QPS_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_qps_int_pri {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Modify/Query QP bit. */
	u64	modify_query:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_qps_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_int_pri [64 bits] */

/* CSR automated type for TSU_QPS_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_qps_int_status_clear {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Modify/Query QP bit. */
	u64	modify_query:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_qps_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_int_status_clear [64 bits] */

/* CSR automated type for TSU_QPS_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_qps_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_QPS_UF_STOP_TIMEOUT_KICK */
/*
 * Stops timeout checking for UF in the uf_control register. This register
 * must be kicked in order to make sure refcounts are not incremented for the
 * UF to be flushed/invalidated.
 */
struct psif_csr_qps_uf_stop_timeout_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_uf_stop_timeout_kick [64 bits] */

/* QP number UF and command for either modify or query QP. */
struct psif_modify_command {
	/* *** 64 bit group 0 start *** */
	/* Manually added spacing to pad out psif_modify_command */
	u32	:4; /* 4 bits @ offs 0:0 */
	/* QP number for this operation. */
	u32	qp_num:24; /* 24 bits @ offs 0:4 */
	/* Current state the QP must be in to do the modification. */
	#if defined(__arm__) /* enum psif_qp_state */
		u32	current_state:3;
	#else /* !__arm__ */
		enum psif_qp_state	current_state:3;
	#endif	 /* 3 bits @ offs 0:28 */
	/*
	 * Port number used for accesses to QP0/1. This field is don't care for all
	 * other QPs.
	 */
	#if defined(__arm__) /* enum psif_port */
		u32	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:31 */
	/* UF this QP belongs to. */
	u8	uf:6; /* 6 bits @ offs 0:32 */
	/* Command indicating operation - query or modify. */
	#if defined(__arm__) /* enum psif_qp_command */
		u8	cmd:2;
	#else /* !__arm__ */
		enum psif_qp_command	cmd:2;
	#endif	 /* 2 bits @ offs 0:38 */
} PSIF_PACKED; /* struct psif_modify_command [40 bits] */

/*
 * Modify/query QP attributes. Bit mask indicating which field should be
 * modified.
 */
struct psif_qp_attributes {
	/* *** 64 bit group 0 start *** */
	/* Do not modify unless current state is as indicated in command. */
	u16	use_current_state:1; /* 1 bits @ offs 0:0 */
	/* Change max outstanding RD/ATOMIC towards destination. */
	u16	max_outstanding:1; /* 1 bits @ offs 0:1 */
	/* Change the xmit psn (SQ PSN) when set. */
	u16	xmit_psn:1; /* 1 bits @ offs 0:2 */
	/* Change the RNR retry count when set. */
	u16	rnr_retry_count:1; /* 1 bits @ offs 0:3 */
	/* Change the retry count when set. */
	u16	error_retry_count:1; /* 1 bits @ offs 0:4 */
	/* Change the RNR minimum timer value when set. */
	u16	min_rnr_nak_time:1; /* 1 bits @ offs 0:5 */
	/* Change the local ack timeout when set. */
	u16	local_ack_timeout:1; /* 1 bits @ offs 0:6 */
	/* Change P-Key index if set. */
	u16	pkey_index:1; /* 1 bits @ offs 0:7 */
	/* Change the Q-Key when set. */
	u16	qkey:1; /* 1 bits @ offs 0:8 */
	/* Change the receive capabilities when set. */
	u16	qp_rcv_cap:1; /* 1 bits @ offs 0:9 */
	/* Change the state of the QP when set. */
	u16	qp_state:1; /* 1 bits @ offs 0:10 */
	/* Change alternate path if set. */
	u16	alt_path:1; /* 1 bits @ offs 0:11 */
	/*
	 * Change migration state if set. In some cases this might lead to a path
	 * migration.
	 */
	u16	mig_state:1; /* 1 bits @ offs 0:12 */
	/* Change primary path if set. */
	u16	prim_path:1; /* 1 bits @ offs 0:13 */
	/* Change expected PSN (RQ PSN) if set. */
	u16	expected_psn:1; /* 1 bits @ offs 0:14 */
	/* Change path MTU if set. */
	u16	path_mtu:1; /* 1 bits @ offs 0:15 */
	/* Change path req_access error if set. */
	u8	req_access_error:1; /* 1 bits @ offs 0:16 */
	/* Manually added spacing to pad outpsif_qp_attributes */
	u8	:7; /* 7 bits @ offs 0:17 */
} PSIF_PACKED; /* struct psif_qp_attributes [24 bits] */

/* CSR automated type for TSU_QPS_MODIFY_QP_CTRL */
/*
 * Per UF modify/query QP command/attribute register. Only one register is
 * implemented in hardware - one at a time. EPS implements one register per
 * UF. When one is written, the modify data is written to modify_qp_data
 * register before this register is written. The Modify or Query QP command
 * is autmatically kicked when this register is written. Is one outstanding
 * modify/query QP per UF ok, or do we need more?
 */
struct psif_csr_modify_qp_ctrl {
	/* *** 64 bit group 0 start *** */
	/* Do not modify unless current state is as indicated in command. */
	u16	use_current_state:1; /* 1 bits @ offs 0:0 */
	/* Change max outstanding RD/ATOMIC towards destination. */
	u16	max_outstanding:1; /* 1 bits @ offs 0:1 */
	/* Change the xmit psn (SQ PSN) when set. */
	u16	xmit_psn:1; /* 1 bits @ offs 0:2 */
	/* Change the RNR retry count when set. */
	u16	rnr_retry_count:1; /* 1 bits @ offs 0:3 */
	/* Change the retry count when set. */
	u16	error_retry_count:1; /* 1 bits @ offs 0:4 */
	/* Change the RNR minimum timer value when set. */
	u16	min_rnr_nak_time:1; /* 1 bits @ offs 0:5 */
	/* Change the local ack timeout when set. */
	u16	local_ack_timeout:1; /* 1 bits @ offs 0:6 */
	/* Change P-Key index if set. */
	u16	pkey_index:1; /* 1 bits @ offs 0:7 */
	/* Change the Q-Key when set. */
	u16	qkey:1; /* 1 bits @ offs 0:8 */
	/* Change the receive capabilities when set. */
	u16	qp_rcv_cap:1; /* 1 bits @ offs 0:9 */
	/* Change the state of the QP when set. */
	u16	qp_state:1; /* 1 bits @ offs 0:10 */
	/* Change alternate path if set. */
	u16	alt_path:1; /* 1 bits @ offs 0:11 */
	/*
	 * Change migration state if set. In some cases this might lead to a path
	 * migration.
	 */
	u16	mig_state:1; /* 1 bits @ offs 0:12 */
	/* Change primary path if set. */
	u16	prim_path:1; /* 1 bits @ offs 0:13 */
	/* Change expected PSN (RQ PSN) if set. */
	u16	expected_psn:1; /* 1 bits @ offs 0:14 */
	/* Change path MTU if set. */
	u16	path_mtu:1; /* 1 bits @ offs 0:15 */
	/* Change path req_access error if set. */
	u64	req_access_error:1; /* 1 bits @ offs 0:16 */
	/* Manually added spacing to pad outpsif_qp_attributes */
	u64	:7; /* 7 bits @ offs 0:17 */
	/* Inlined cmd_attributes : struct psif_qp_attributes (24 bits) */ /* 24 bits @ offs 0:24 */
	/* Manually added spacing to pad out psif_modify_command */
	u64	:4; /* 4 bits @ offs 0:24 */
	/* QP number for this operation. */
	u64	qp_num:24; /* 24 bits @ offs 0:28 */
	/* Current state the QP must be in to do the modification. */
	#if defined(__arm__) /* enum psif_qp_state */
		u64	current_state:3;
	#else /* !__arm__ */
		enum psif_qp_state	current_state:3;
	#endif	 /* 3 bits @ offs 0:52 */
	/*
	 * Port number used for accesses to QP0/1. This field is don't care for all
	 * other QPs.
	 */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:55 */
	/* UF this QP belongs to. */
	u64	uf:6; /* 6 bits @ offs 0:56 */
	/* Command indicating operation - query or modify. */
	#if defined(__arm__) /* enum psif_qp_command */
		u64	cmd:2;
	#else /* !__arm__ */
		enum psif_qp_command	cmd:2;
	#endif	 /* 2 bits @ offs 0:62 */
	/* *** 64 bit group 1 start *** */
	/* Inlined cmd : struct psif_modify_command (40 bits) */ /* 40 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_modify_qp_ctrl [64 bits] */

/*
 * Modify QP structure - this structure is only to make register_file work in
 * the CSR generation.
 */
struct psif_qp_data {
	/* *** 64 bit group 0 start *** */
	/* First 64 bits of modify QP data. */
	u64	data_0; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Second 64 bits of modify QP data. */
	u64	data_1; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* First 64 bits of modify primary path data. */
	u64	data_2; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Second 64 bits of modify primary path data. */
	u64	data_3; /* 64 bits @ offs 3:0 */
	/* *** 64 bit group 4 start *** */
	/* Third 64 bits of modify primary path data. */
	u64	data_4; /* 64 bits @ offs 4:0 */
	/* *** 64 bit group 5 start *** */
	/* Fourth 64 bits of modify primary path data. */
	u64	data_5; /* 64 bits @ offs 5:0 */
	/* *** 64 bit group 6 start *** */
	/* First 64 bits of modify alternate path data. */
	u64	data_6; /* 64 bits @ offs 6:0 */
	/* *** 64 bit group 7 start *** */
	/* Second 64 bits of modify alternate path data. */
	u64	data_7; /* 64 bits @ offs 7:0 */
	/* *** 64 bit group 8 start *** */
	/* Third 64 bits of modify alternate path data. */
	u64	data_8; /* 64 bits @ offs 8:0 */
	/* *** 64 bit group 9 start *** */
	/* Fourth 64 bits of modify alternate path data. */
	u64	data_9; /* 64 bits @ offs 9:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_qp_data [640 bits] */

/* CSR automated type for TSU_QPS_MODIFY_QP_KICK */
/*
 * Kick register to start a new modify or query command. This register is
 * written by EPS.
 */
struct psif_csr_modify_qp_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_modify_qp_kick [64 bits] */

/* CSR automated type for TSU_QPS_MODIFY_QP_STATUS */
/*
 * Status register indicating status of modify QP and query QP commands. This
 * register is read by the EPS only.
 */
struct psif_csr_qps_modify_qp_status {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_modify_status */
		u64	data:3;
	#else /* !__arm__ */
		enum psif_modify_status	data:3;
	#endif	 /* 3 bits @ offs 0:0 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_modify_qp_status [64 bits] */

/* CSR automated type for TSU_QPS_QUERY_QP_DATA */
/*
 * Data register containing data for the query QP command. This is read by
 * the EPS only. The register is laid out to contain QP, primary_path and
 * alternate path - same as it is in host memory. This is only a data bus,
 * not using the structure psif_verbs_pkg::query_qp_t. When data is queried,
 * and written to this register the psif_verbs_pkg::query_qp_t is cast to
 * this structure. Please look at psif_verbs_pkg::query_qp_t for details.
 */
struct psif_csr_qps_query_qp_data {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_query_qp_data [64 bits] */

/* CSR automated type for TSU_QPS_WR_QP_DATA */
/*
 * QP data register - see psif_verbs_pkg::qp_t for details on layout. This
 * register contain the QP data information to write to QP index (HW cache
 * index) given by the wr_qp_index CSR. This register is used to initialize
 * QP 0/1, and is not accessible from user space. It could also be used for
 * diagnostics.
 */
struct psif_csr_qps_wr_qp_data {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_wr_qp_data [64 bits] */

/* CSR automated type for TSU_QPS_WR_QP_PATH */
/*
 * QP data register - see psif_verbs_pkg::path_info_t for details on layout.
 * This register contain the path data to write to QP index (HW cache index)
 * given by the wr_qp_index CSR. This register is used to initialize QP 0/1,
 * and is not accessible from user space.
 */
struct psif_csr_qps_wr_qp_path {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_wr_qp_path [64 bits] */

/* CSR automated type for TSU_QPS_WR_QP_INDEX */
/*
 * QP index register. This register contain the QP index where the QP
 * information is written to. This register is used to initialize QP 0/1, and
 * is not accessible from user space. Set this to 0 for QP0 and 1 for QP1.
 */
struct psif_csr_qps_wr_qp_index {
	/* *** 64 bit group 0 start *** */
	/* qp_indx(11[0] bits)Queue Pair index used to address a QP in tsu_qps. */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_wr_qp_index [64 bits] */

/* CSR automated type for TSU_QPS_WR_QP_KICK */
/*
 * Kick register to start a new writing the QP information in wr_qp_data and
 * wr_qp_path to QP index given in wr_qp_index CSR. This register is .
 */
struct psif_csr_qps_wr_qp_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_wr_qp_kick [64 bits] */

/* CSR automated type for TSU_QPS_MODIFY_ATTR_MASK_INIT_RTR */
/*
 * DO NOT USE!! This register gives the option to change fields which can be
 * changed in a QP modify command. It is not to be accessed by users, and is
 * only here for flexibility. The register contain legal attribute masks for
 * QP modification for state transition INIT to RTR.
 */
struct psif_csr_qps_modify_attr_mask_init_rtr {
	/* *** 64 bit group 0 start *** */
	u32	cmd_attr_opt:17; /* 17 bits @ offs 0:0 */
	u32	:15; /* 15 bits @ offs 0:17 */
	u32	cmd_attr_mand:17; /* 17 bits @ offs 0:32 */
	u32	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_modify_attr_mask_init_rtr [64 bits] */

/* CSR automated type for TSU_QPS_MODIFY_ATTR_MASK_RTR_RTS */
/*
 * DO NOT USE!! This register gives the option to change fields which can be
 * changed in a QP modify command. It is not to be accessed by users, and is
 * only here for flexibility. The register contain legal attribute masks for
 * QP modification for state transition RTR to RTS.
 */
struct psif_csr_qps_modify_attr_mask_rtr_rts {
	/* *** 64 bit group 0 start *** */
	u32	cmd_attr_opt:17; /* 17 bits @ offs 0:0 */
	u32	:15; /* 15 bits @ offs 0:17 */
	u32	cmd_attr_mand:17; /* 17 bits @ offs 0:32 */
	u32	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_modify_attr_mask_rtr_rts [64 bits] */

/* CSR automated type for TSU_QPS_MODIFY_ATTR_MASK_RTS_RTS */
/*
 * DO NOT USE!! This register gives the option to change fields which can be
 * changed in a QP modify command. It is not to be accessed by users, and is
 * only here for flexibility. The register contain legal attribute masks for
 * QP modification for state transition RTS to RTS.
 */
struct psif_csr_qps_modify_attr_mask_rts_rts {
	/* *** 64 bit group 0 start *** */
	u32	cmd_attr_opt:17; /* 17 bits @ offs 0:0 */
	u32	:15; /* 15 bits @ offs 0:17 */
	u32	cmd_attr_mand:17; /* 17 bits @ offs 0:32 */
	u32	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_modify_attr_mask_rts_rts [64 bits] */

/* CSR automated type for TSU_QPS_MODIFY_ATTR_MASK_ANY_ERR_RESET */
/*
 * DO NOT USE!! This register gives the option to change fields which can be
 * changed in a QP modify command. It is not to be accessed by users, and is
 * only here for flexibility. The register contain legal attribute masks for
 * QP modification for state transition from any state to RESET or ERROR.
 */
struct psif_csr_qps_modify_attr_mask_any_err_reset {
	/* *** 64 bit group 0 start *** */
	u32	cmd_attr_opt:17; /* 17 bits @ offs 0:0 */
	u32	:15; /* 15 bits @ offs 0:17 */
	u32	cmd_attr_mand:17; /* 17 bits @ offs 0:32 */
	u32	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_modify_attr_mask_any_err_reset [64 bits] */

/* CSR automated type for TSU_QPS_MODIFY_ATTR_MASK_SQERR_RTS */
/*
 * DO NOT USE!! This register gives the option to change fields which can be
 * changed in a QP modify command. It is not to be accessed by users, and is
 * only here for flexibility. Legal attribute masks for QP modification for
 * state transition from SQERR to RTS.
 */
struct psif_csr_qps_modify_attr_mask_sqerr_rts {
	/* *** 64 bit group 0 start *** */
	u32	cmd_attr_opt:17; /* 17 bits @ offs 0:0 */
	u32	:15; /* 15 bits @ offs 0:17 */
	u32	cmd_attr_mand:17; /* 17 bits @ offs 0:32 */
	u32	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_modify_attr_mask_sqerr_rts [64 bits] */

/* CSR automated type for TSU_QPS_REF_COUNT */
/* Per UF refcount register. This is used for UF flushing. */
struct psif_csr_qps_ref_count {
	/* *** 64 bit group 0 start *** */
	u64	data:11; /* 11 bits @ offs 0:0 */
	u64	:53; /* 53 bits @ offs 0:11 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_qps_ref_count [64 bits] */

/* CSR automated type for TSU_CMPL_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_cmpl_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_uf_control [64 bits] */

/* CSR automated type for TSU_CMPL_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_cmpl_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_uf_control_kick [64 bits] */

/* CSR automated type for TSU_CMPL_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_cmpl_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_int_status [64 bits] */

/* CSR automated type for TSU_CMPL_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_cmpl_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_int_mask [64 bits] */

/* CSR automated type for TSU_CMPL_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_cmpl_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_int_pri [64 bits] */

/* CSR automated type for TSU_CMPL_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_cmpl_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_int_status_clear [64 bits] */

/* CSR automated type for TSU_CMPL_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_cmpl_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_cmpl_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_VAL_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_val_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_uf_control [64 bits] */

/* CSR automated type for TSU_VAL_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_val_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_uf_control_kick [64 bits] */

/* CSR automated type for TSU_VAL_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_val_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_int_status [64 bits] */

/* CSR automated type for TSU_VAL_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_val_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_int_mask [64 bits] */

/* CSR automated type for TSU_VAL_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_val_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_int_pri [64 bits] */

/* CSR automated type for TSU_VAL_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_val_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_int_status_clear [64 bits] */

/* CSR automated type for TSU_VAL_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_val_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_val_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_RQH_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_rqh_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_uf_control [64 bits] */

/* CSR automated type for TSU_RQH_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_rqh_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_uf_control_kick [64 bits] */

/* Interrupt bit definitions for TSU RQH. */
struct psif_rqh_int_definition {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:62; /* 62 bits @ offs 0:0 */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:62 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_rqh_int_definition [64 bits] */

/* CSR automated type for TSU_RQH_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_rqh_int_status {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_rqh_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_int_status [64 bits] */

/* CSR automated type for TSU_RQH_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_rqh_int_mask {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_rqh_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_int_mask [64 bits] */

/* CSR automated type for TSU_RQH_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_rqh_int_pri {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_rqh_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_int_pri [64 bits] */

/* CSR automated type for TSU_RQH_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_rqh_int_status_clear {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_rqh_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_int_status_clear [64 bits] */

/* CSR automated type for TSU_RQH_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_rqh_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_SW_INDEX_WR */
/*
 * Head index register. Indirect register to write in order to get a
 * consistent view of the complete descriptor. This is used along with the
 * address and write register.
 */
struct psif_csr_rqh_indirect_eq_sw_index_wr {
	/* *** 64 bit group 0 start *** */
	/* eq_max_entries(32[0] bits)Type definition for maximum number of event queue entries. */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_sw_index_wr [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_HW_INDEX_WR */
/*
 * Tail index register. Indirect register to write in order to get a
 * consistent view of the complete descriptor. This is used along with the
 * address and write register.
 */
struct psif_csr_rqh_indirect_eq_hw_index_wr {
	/* *** 64 bit group 0 start *** */
	/* eq_max_entries(32[0] bits)Type definition for maximum number of event queue entries. */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_hw_index_wr [64 bits] */

struct psif_eq_ctrl {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:21; /* 21 bits @ offs 0:0 */
	/*
	 * Event queue sequence number. This is the sequence number to be used for
	 * this event. When used by a client, it is incremented and written back to
	 * this descriptor.
	 */
	u64	sequence_number:32; /* 32 bits @ offs 0:21 */
	/*
	 * The size (log2 number of entries) of the event queue. This is used for
	 * calculating when to wrap the head and tail indexes.
	 */
	u64	size_log2:5; /* 5 bits @ offs 0:53 */
	/*
	 * The size between event queue entries. This is the shift value to find the
	 * start of the next entry.
	 */
	u64	extent_log2:5; /* 5 bits @ offs 0:58 */
	/* The descriptor is valid. */
	u64	valid:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_eq_ctrl [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_CTRL_WR */
/*
 * MMU context and descriptor control register. Indirect register to write in
 * order to get a consistent view of the complete descriptor. This is used
 * along with the address and write register.
 */
struct psif_csr_rqh_indirect_eq_ctrl_wr {
	/* *** 64 bit group 0 start *** */
	/*
	 * Event queue sequence number. This is the sequence number to be used for
	 * this event. When used by a client, it is incremented and written back to
	 * this descriptor.
	 */
	u32	sequence_number; /* 32 bits @ offs 0:0 */
	/*
	 * The size (log2 number of entries) of the event queue. This is used for
	 * calculating when to wrap the head and tail indexes.
	 */
	u32	size_log2:5; /* 5 bits @ offs 0:32 */
	/*
	 * The size between event queue entries. This is the shift value to find the
	 * start of the next entry.
	 */
	u32	extent_log2:5; /* 5 bits @ offs 0:37 */
	/* The descriptor is valid. */
	u32	valid:1; /* 1 bits @ offs 0:42 */
	/* Inlined data : struct psif_eq_ctrl (64 bits) */ /* 64 bits @ offs 0:43 */
	u32	:21; /* 21 bits @ offs 0:43 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_ctrl_wr [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_BASE_ADDR_WR */
/*
 * Base address register. Indirect register to write in order to get a
 * consistent view of the complete descriptor. This is used along with the
 * address and write register.
 */
struct psif_csr_rqh_indirect_eq_base_addr_wr {
	/* *** 64 bit group 0 start *** */
	/* host_address(64[0] bits)Host address used for accesses to/from TSU HOST. */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_base_addr_wr [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_MMU_CONTEXT_WR */
/*
 * Max number of entries and sequence number register. Indirect register to
 * write in order to get a consistent view of the complete descriptor. This
 * is used along with the address and write register.
 */
struct psif_csr_rqh_indirect_mmu_context_wr {
	/* *** 64 bit group 0 start *** */
	struct psif_mmu_cntx	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_mmu_context_wr [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECTION_ADDR_WR */
/*
 * This register must be set prior to kicking a write of the indirect event
 * queue registers.
 */
struct psif_csr_rqh_indirection_addr_wr {
	/* *** 64 bit group 0 start *** */
	u64	data:7; /* 7 bits @ offs 0:0 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirection_addr_wr [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_WR_KICK */
/*
 * When this register is written to, the content of indirect_eq_sw_index_wr,
 * indirect_eq_hw_index_wr, indirect_eq_ctrl_wr, indirect_eq_base_addr_wr,
 * indirect_eq_size_wr is written to event queue entry number defined by the
 * value in the indirect_addr.
 */
struct psif_csr_rqh_indirect_wr_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_wr_kick [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_SW_INDEX_RD */
/*
 * Head index register. Indirect register to read in order to get a
 * consistent view of the complete descriptor. This is used along with the
 * address and read register.
 */
struct psif_csr_rqh_indirect_eq_sw_index_rd {
	/* *** 64 bit group 0 start *** */
	/* eq_max_entries(32[0] bits)Type definition for maximum number of event queue entries. */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_sw_index_rd [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_HW_INDEX_RD */
/*
 * Tail index register. Indirect register to read in order to get a
 * consistent view of the complete descriptor. This is used along with the
 * address and read register.
 */
struct psif_csr_rqh_indirect_eq_hw_index_rd {
	/* *** 64 bit group 0 start *** */
	/* eq_max_entries(32[0] bits)Type definition for maximum number of event queue entries. */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_hw_index_rd [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_CTRL_RD */
/*
 * MMU context and descriptor control register. Indirect register to read in
 * order to get a consistent view of the complete descriptor. This is used
 * along with the address and write register.
 */
struct psif_csr_rqh_indirect_eq_ctrl_rd {
	/* *** 64 bit group 0 start *** */
	/*
	 * Event queue sequence number. This is the sequence number to be used for
	 * this event. When used by a client, it is incremented and written back to
	 * this descriptor.
	 */
	u32	sequence_number; /* 32 bits @ offs 0:0 */
	/*
	 * The size (log2 number of entries) of the event queue. This is used for
	 * calculating when to wrap the head and tail indexes.
	 */
	u32	size_log2:5; /* 5 bits @ offs 0:32 */
	/*
	 * The size between event queue entries. This is the shift value to find the
	 * start of the next entry.
	 */
	u32	extent_log2:5; /* 5 bits @ offs 0:37 */
	/* The descriptor is valid. */
	u32	valid:1; /* 1 bits @ offs 0:42 */
	/* Inlined data : struct psif_eq_ctrl (64 bits) */ /* 64 bits @ offs 0:43 */
	u32	:21; /* 21 bits @ offs 0:43 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_ctrl_rd [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_EQ_BASE_ADDR_RD */
/*
 * Base address register. Indirect register to read in order to get a
 * consistent view of the complete descriptor. This is used along with the
 * address and read register.
 */
struct psif_csr_rqh_indirect_eq_base_addr_rd {
	/* *** 64 bit group 0 start *** */
	/* host_address(64[0] bits)Host address used for accesses to/from TSU HOST. */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_eq_base_addr_rd [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_MMU_CONTEXT_RD */
/*
 * Max number of entries and sequence number register. Indirect register to
 * read in order to get a consistent view of the complete descriptor. This is
 * used along with the address and read register.
 */
struct psif_csr_rqh_indirect_mmu_context_rd {
	/* *** 64 bit group 0 start *** */
	struct psif_mmu_cntx	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_mmu_context_rd [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECTION_ADDR_RD */
/*
 * This register must be set prior to kicking a read of the indirect event
 * queue registers.
 */
struct psif_csr_rqh_indirection_addr_rd {
	/* *** 64 bit group 0 start *** */
	u64	data:7; /* 7 bits @ offs 0:0 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirection_addr_rd [64 bits] */

/* CSR automated type for TSU_RQH_INDIRECT_RD_KICK */
/*
 * When this register is written to, the content of event queue entry in
 * indirect_addr is written to indirect_eq_sw_index_rd,
 * indirect_eq_hw_index_rd, indirect_eq_ctrl_rd, indirect_eq_base_addr_rd,
 * indirect_eq_size_rd. These registers can now be read as one consistent
 * register.
 */
struct psif_csr_rqh_indirect_rd_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_indirect_rd_kick [64 bits] */

/* CSR automated type for TSU_RQH_EQ_SW_INDEX */
/*
 * Directly accessible software index. Software can update this directly
 * without having to go through a staging read/write register.
 */
struct psif_csr_rqh_eq_sw_index {
	/* *** 64 bit group 0 start *** */
	/* eq_max_entries(32[0] bits)Type definition for maximum number of event queue entries. */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_sw_index [64 bits] */

/* CSR automated type for TSU_RQH_EQ_HW_INDEX */
/*
 * Directly accessible software index. Software can update this directly
 * without having to go through a staging read/write register.
 */
struct psif_csr_rqh_eq_hw_index {
	/* *** 64 bit group 0 start *** */
	/* eq_max_entries(32[0] bits)Type definition for maximum number of event queue entries. */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_hw_index [64 bits] */

/* CSR automated type for TSU_RQH_EQ_MAPPING_TABLE */
/*
 * Used for translating each vHCA's EQ number to the physical EQ number.
 */
struct psif_csr_rqh_eq_mapping_table {
	/* *** 64 bit group 0 start *** */
	u64	num_eqs:7; /* 7 bits @ offs 0:0 */
	u64	:1; /* 1 bits @ offs 0:7 */
	u64	base_eq:7; /* 7 bits @ offs 0:8 */
	u64	:49; /* 49 bits @ offs 0:15 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_mapping_table [64 bits] */

/* CSR automated type for TSU_RQH_EQ_OVERFLOW_STATUS_0 */
/* EQ Overflow Status 0 EQs 0-63 */
struct psif_csr_rqh_eq_overflow_status_0 {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_overflow_status_0 [64 bits] */

/* CSR automated type for TSU_RQH_EQ_OVERFLOW_STATUS_1 */
/* EQ Overflow Status 1 EQs 64-127 */
struct psif_csr_rqh_eq_overflow_status_1 {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_overflow_status_1 [64 bits] */

/* CSR automated type for TSU_RQH_EQ_INVALID_STATUS_0 */
/* EQ Invavlid Status 0 EQs 0-63 */
struct psif_csr_rqh_eq_invalid_status_0 {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_invalid_status_0 [64 bits] */

/* CSR automated type for TSU_RQH_EQ_INVALID_STATUS_1 */
/* EQ Overflow Status 1 EQs 64-127 */
struct psif_csr_rqh_eq_invalid_status_1 {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_invalid_status_1 [64 bits] */

/* CSR automated type for TSU_RQH_EQ_OUT_OF_RANGE_STATUS */
/* EQ out of range status */
struct psif_csr_rqh_eq_out_of_range_status {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_eq_out_of_range_status [64 bits] */

/* CSR automated type for TSU_RQH_CLEAR_EQ_STATUS_0 */
/* Clear EQ Status 0 EQs 0-63 */
struct psif_csr_rqh_clear_eq_status_0 {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_clear_eq_status_0 [64 bits] */

/* CSR automated type for TSU_RQH_CLEAR_EQ_STATUS_1 */
/* Clear EQ Status 1 EQs 64-127 */
struct psif_csr_rqh_clear_eq_status_1 {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_clear_eq_status_1 [64 bits] */

/* CSR automated type for TSU_RQH_CLEAR_EQ_STATUS_KICK */
/* Initiates clear of EQ status bits as indicated in Clear EQ Status 0/1. */
struct psif_csr_rqh_clear_eq_status_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_clear_eq_status_kick [64 bits] */

/* CSR automated type for TSU_RQH_CLEAR_EQ_UF_STATUS */
/* Clear per UF EQ out of range Status */
struct psif_csr_rqh_clear_eq_uf_status {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_clear_eq_uf_status [64 bits] */

/* CSR automated type for TSU_RQH_CLEAR_EQ_UF_STATUS_KICK */
/* Initiates clear of per UF out of range EQ status bits */
struct psif_csr_rqh_clear_eq_uf_status_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rqh_clear_eq_uf_status_kick [64 bits] */

/* CSR automated type for TSU_DSCR_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_dscr_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_uf_control [64 bits] */

/* CSR automated type for TSU_DSCR_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_dscr_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_uf_control_kick [64 bits] */

/* Interrupt bit definitions for TSU DSCR. */
struct psif_dscr_int_definition {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:62; /* 62 bits @ offs 0:0 */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:62 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_dscr_int_definition [64 bits] */

/* CSR automated type for TSU_DSCR_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_dscr_int_status {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_dscr_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_int_status [64 bits] */

/* CSR automated type for TSU_DSCR_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_dscr_int_mask {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_dscr_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_int_mask [64 bits] */

/* CSR automated type for TSU_DSCR_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_dscr_int_pri {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_dscr_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_int_pri [64 bits] */

/* CSR automated type for TSU_DSCR_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_dscr_int_status_clear {
	/* *** 64 bit group 0 start *** */
	/* UF Flush/Invalidate bit */
	u64	uf_flush_invalidate:1; /* 1 bits @ offs 0:0 */
	/* Asynchronous event bit. */
	u64	async_event:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_dscr_int_definition (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_int_status_clear [64 bits] */

/* CSR automated type for TSU_DSCR_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_dscr_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_int_status_clear_kick [64 bits] */

/*
 * Event queue entry status - this is a helper struct for RTL. Put this in
 * the async FIFO and add this .
 */
struct psif_async_eq_entry_status_fifo {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u32	:22; /* 22 bits @ offs 0:0 */
	/* Type of event. */
	#if defined(__arm__) /* enum psif_event_type */
		u32	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:22 */
	/* UF - valid for affiliated events. */
	u32	uf:6; /* 6 bits @ offs 0:26 */
	#if defined(__arm__) /* enum psif_event_status */
		u32	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:32 */
	/* QP number - valid for affiliated events. */
	u32	qp:24; /* 24 bits @ offs 0:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_async_eq_entry_status_fifo [64 bits] */

/* Event queue entry status. */
struct psif_async_eq_entry_status {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u32	:21; /* 21 bits @ offs 0:0 */
	/*
	 * Valid bit for this event entry. It is here as a help for SW/FW. If this
	 * register is read, and this bit is not set, the FIFO this register is fed
	 * from is empty.
	 */
	u32	valid:1; /* 1 bits @ offs 0:21 */
	/* Type of event. */
	#if defined(__arm__) /* enum psif_event_type */
		u32	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:22 */
	/* UF - valid for affiliated events. */
	u32	uf:6; /* 6 bits @ offs 0:26 */
	#if defined(__arm__) /* enum psif_event_status */
		u32	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:32 */
	/* QP number - valid for affiliated events. */
	u32	qp:24; /* 24 bits @ offs 0:40 */
	/* *** 64 bit group 1 start *** */
	/* Async event data. */
	/* Inlined data : struct psif_async_eq_entry_status_fifo (64 bits) */ /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_async_eq_entry_status [64 bits] */

/* CSR automated type for TSU_DSCR_ASYNC_EVENT_STATUS */
/* Async event FIFO - status portion. */
struct psif_csr_dscr_async_event_status {
	/* *** 64 bit group 0 start *** */
	u32	:21; /* 21 bits @ offs 0:0 */
	/*
	 * Valid bit for this event entry. It is here as a help for SW/FW. If this
	 * register is read, and this bit is not set, the FIFO this register is fed
	 * from is empty.
	 */
	u32	valid:1; /* 1 bits @ offs 0:21 */
	/* Type of event. */
	#if defined(__arm__) /* enum psif_event_type */
		u32	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:22 */
	/* UF - valid for affiliated events. */
	u32	uf:6; /* 6 bits @ offs 0:26 */
	#if defined(__arm__) /* enum psif_event_status */
		u32	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:32 */
	/* QP number - valid for affiliated events. */
	u32	qp:24; /* 24 bits @ offs 0:40 */
	/* *** 64 bit group 1 start *** */
	/* Async event data. */
	/* Inlined data : struct psif_async_eq_entry_status_fifo (64 bits) */ /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/* Inlined data : struct psif_async_eq_entry_status (64 bits) */ /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_async_event_status [64 bits] */

/*
 * Event queue entry - affiliated data portion. This is only valid for
 * affiliated events for the appropriate data types.
 */
struct psif_async_eq_entry_affiliated {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:23; /* 23 bits @ offs 0:0 */
	/* IB port number */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:23 */
	/* LID. */
	u64	lid:16; /* 16 bits @ offs 0:24 */
	/* Descriptor union. */
	/* Actual data type: union eq_dscr_union */
	u64	dscr_union:24; /* 24 bits @ offs 0:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_async_eq_entry_affiliated [64 bits] */

/* CSR automated type for TSU_DSCR_ASYNC_EVENT_AFFILIATED */
/* Async event FIFO - affiliated data portion. */
struct psif_csr_dscr_async_event_affiliated {
	/* *** 64 bit group 0 start *** */
	u64	:23; /* 23 bits @ offs 0:0 */
	/* IB port number */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:23 */
	/* LID. */
	u64	lid:16; /* 16 bits @ offs 0:24 */
	/* Descriptor union. */
	/* Actual data type: union eq_dscr_union */
	u64	dscr_union:24; /* 24 bits @ offs 0:40 */
	/* *** 64 bit group 1 start *** */
	/* Inlined data : struct psif_async_eq_entry_affiliated (64 bits) */ /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_async_event_affiliated [64 bits] */

/* CSR automated type for TSU_DSCR_ASYNC_EVENT_POP */
/* This pop register is written after async event register is read. */
struct psif_csr_dscr_async_event_pop {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_async_event_pop [64 bits] */

/* CSR automated type for TSU_DSCR_DIAGNOSTIC */
/* Various diagnostic control bits */
struct psif_csr_dscr_diagnostic {
	/* *** 64 bit group 0 start *** */
	u64	suspend:1; /* 1 bits @ offs 0:0 */
	u64	read_enable:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_diagnostic [64 bits] */

/* CSR automated type for TSU_DSCR_FATAL_INTERRUPT */
/* Fatal interrupt bits */
struct psif_csr_dscr_fatal_interrupt {
	/* *** 64 bit group 0 start *** */
	u64	data:40; /* 40 bits @ offs 0:0 */
	u64	:24; /* 24 bits @ offs 0:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_fatal_interrupt [64 bits] */

/* CSR automated type for TSU_DSCR_FATAL_INTERRUPT_CLEAR */
/* Clear fatal interrupt status. */
struct psif_csr_dscr_fatal_interrupt_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_dscr_fatal_interrupt_clear [64 bits] */

/* CSR automated type for TSU_RCV_RSS_EOIB_TABLE */
/* RSS table containing CQ and RQ. This table is used for EoIB RSS. */
struct psif_csr_rcv_rss_eoib_table {
	/* *** 64 bit group 0 start *** */
	/* cqd_id(24[0] bits)Completion queue descriptor ID. */
	u32	cmplq_desc_id:24; /* 24 bits @ offs 0:0 */
	u32	:8; /* 8 bits @ offs 0:24 */
	/* rqd_id(24[0] bits)Receive queue descriptor ID. */
	u32	rcvq_desc_id:24; /* 24 bits @ offs 0:32 */
	u32	:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_rss_eoib_table [64 bits] */

/* CSR automated type for TSU_RCV_RSS_CTRL_EOIB_TABLE */
/*
 * Control register for RSS per vHCA (UF0-UF32). Containing the bit masks to
 * use when masking hashes.
 */
struct psif_csr_rcv_rss_ctrl_eoib_table {
	/* *** 64 bit group 0 start *** */
	/* rss_table_offset(7[0] bits)RSS table offset type. */
	u64	offset:7; /* 7 bits @ offs 0:0 */
	/* rss_hash_mask_bits(3[0] bits)Number of bits used from the hash value calculated. */
	u64	mask_bits:3; /* 3 bits @ offs 0:7 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_rss_ctrl_eoib_table [64 bits] */

/* CSR automated type for TSU_RCV_RSS_IPOIB_TABLE */
/* RSS table containing CQ and RQ. This table is used for IPoIB RSS. */
struct psif_csr_rcv_rss_ipoib_table {
	/* *** 64 bit group 0 start *** */
	/* cqd_id(24[0] bits)Completion queue descriptor ID. */
	u32	cmplq_desc_id:24; /* 24 bits @ offs 0:0 */
	u32	:8; /* 8 bits @ offs 0:24 */
	/* rqd_id(24[0] bits)Receive queue descriptor ID. */
	u32	rcvq_desc_id:24; /* 24 bits @ offs 0:32 */
	u32	:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_rss_ipoib_table [64 bits] */

/* CSR automated type for TSU_RCV_RSS_CTRL_IPOIB_TABLE */
/*
 * Control register for RSS per vHCA (UF0-UF32). Containing the bit masks to
 * use when masking hashes.
 */
struct psif_csr_rcv_rss_ctrl_ipoib_table {
	/* *** 64 bit group 0 start *** */
	/* rss_table_offset(7[0] bits)RSS table offset type. */
	u64	offset:7; /* 7 bits @ offs 0:0 */
	/* rss_hash_mask_bits(3[0] bits)Number of bits used from the hash value calculated. */
	u64	mask_bits:3; /* 3 bits @ offs 0:7 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_rss_ctrl_ipoib_table [64 bits] */

/* CSR automated type for TSU_RCV_PROXY_SIZE */
/*
 * Control register for EPS-A offloading per vHCA (UF0-UF32). It is
 * containing the size which is the limit for sending packets to EPS-A.
 */
struct psif_csr_rcv_proxy_size {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_path_mtu */
		u64	data:3;
	#else /* !__arm__ */
		enum psif_path_mtu	data:3;
	#endif	 /* 3 bits @ offs 0:0 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_proxy_size [64 bits] */

/* CSR automated type for TSU_RCV_MAD_SIZE */
/* Maximum MAD packet size supported. */
struct psif_csr_rcv_mad_size {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_path_mtu */
		u64	data:3;
	#else /* !__arm__ */
		enum psif_path_mtu	data:3;
	#endif	 /* 3 bits @ offs 0:0 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_mad_size [64 bits] */

/* CSR automated type for TSU_RCV_EOIB_MCAST_REJECT */
/*
 * Error counter for multicast rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eoib_mcast_reject {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eoib_mcast_reject [64 bits] */

/* CSR automated type for TSU_RCV_EOIB_BCAST_REJECT */
/*
 * Error counter for broadcast rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eoib_bcast_reject {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eoib_bcast_reject [64 bits] */

/* CSR automated type for TSU_RCV_EOIB_UCAST_REJECT */
/*
 * Error counter for unicast rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eoib_ucast_reject {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eoib_ucast_reject [64 bits] */

/* CSR automated type for TSU_RCV_EIOB_FRAGMENT_REJECT */
/*
 * Error counter for fragment rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eiob_fragment_reject {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eiob_fragment_reject [64 bits] */

/* CSR automated type for TSU_RCV_EIOB_RUNTS_REJECT */
/*
 * Error counter for runt rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eiob_runts_reject {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eiob_runts_reject [64 bits] */

/* CSR automated type for TSU_RCV_EIOB_OUTER_VLAN_REJECT */
/*
 * Error counter for outer VLAN rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eiob_outer_vlan_reject {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eiob_outer_vlan_reject [64 bits] */

/* CSR automated type for TSU_RCV_EIOB_VLAN_TAG_REJECT */
/*
 * Error counter for VALN tag rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eiob_vlan_tag_reject {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eiob_vlan_tag_reject [64 bits] */

/* CSR automated type for TSU_RCV_EIOB_VID_REJECT */
/*
 * Error counter for VID rejects. There is one register per vHCA port.
 */
struct psif_csr_rcv_eiob_vid_reject {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_eiob_vid_reject [64 bits] */

struct psif_no_mcast_duplication {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:62; /* 62 bits @ offs 0:0 */
	/* If set IP over IB multicast packets are not replicated back to itself. */
	u64	ipoib:1; /* 1 bits @ offs 0:62 */
	/*
	 * If set, Ethernet over IB multicast packets are not replicated back to
	 * itself.
	 */
	u64	eoib:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_no_mcast_duplication [64 bits] */

/* CSR automated type for TSU_RCV_NO_MCAST_DUPLICATION */
/*
 * Control if multicast packets should be forwarded to yourself or not when
 * the QP is a IPoIB or EoIB QP.
 */
struct psif_csr_rcv_no_mcast_duplication {
	/* *** 64 bit group 0 start *** */
	/* If set IP over IB multicast packets are not replicated back to itself. */
	u64	ipoib:1; /* 1 bits @ offs 0:0 */
	/*
	 * If set, Ethernet over IB multicast packets are not replicated back to
	 * itself.
	 */
	u64	eoib:1; /* 1 bits @ offs 0:1 */
	/* Inlined data : struct psif_no_mcast_duplication (64 bits) */ /* 64 bits @ offs 0:2 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_no_mcast_duplication [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_SGID_UPPER */
/* Trap register for P-Key and Q-Key traps. */
struct psif_csr_rcv_key_trap_sgid_upper {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_sgid_upper [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_SGID_LOWER */
/* Trap register for P-Key and Q-Key traps. */
struct psif_csr_rcv_key_trap_sgid_lower {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_sgid_lower [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_DGID_UPPER */
/* Trap register for P-Key and Q-Key traps. */
struct psif_csr_rcv_key_trap_dgid_upper {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_dgid_upper [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_DGID_LOWER */
/* Trap register for P-Key and Q-Key traps. */
struct psif_csr_rcv_key_trap_dgid_lower {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_dgid_lower [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_QP */
/* Trap register for P-Key and Q-Key traps. */
struct psif_csr_rcv_key_trap_qp {
	/* *** 64 bit group 0 start *** */
	u32	srcqp:24; /* 24 bits @ offs 0:0 */
	u32	:8; /* 8 bits @ offs 0:24 */
	u32	destqp:24; /* 24 bits @ offs 0:32 */
	u32	sl:4; /* 4 bits @ offs 0:56 */
	u32	:1; /* 1 bits @ offs 0:60 */
	u32	port_num:1; /* 1 bits @ offs 0:61 */
	u32	qkey_trap:1; /* 1 bits @ offs 0:62 */
	u32	valid:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_qp [64 bits] */

struct psif_pkey_trap {
	/* *** 64 bit group 0 start *** */
	/* P-Key value or index. */
	u16	pkey; /* 16 bits @ offs 0:0 */
	/* Reserved */
	u16	:14; /* 14 bits @ offs 0:16 */
	/* This is the membership bit from the P-Key received in the incomming packet. */
	u16	membership:1; /* 1 bits @ offs 0:30 */
	/* The P-Key is the actual P-Key value and not the P-Key index. */
	u16	value:1; /* 1 bits @ offs 0:31 */
} PSIF_PACKED; /* struct psif_pkey_trap [32 bits] */

/* This is a union used for P-Key and Q-Key traps. */
union psif_qkey_pkey_trap_union {
	/* This is used when the trap is a P-Key trap. */
	struct psif_pkey_trap	pkey; /* 32 bits @ 0 offs 0 */
	/* This is used when the trap is a Q-Key trap. */
	u32	qkey; /* 32 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_qkey_pkey_trap_union [32 bits] */

/* This structure is used in the P-Key/Q-Key trap FIFO. */
struct psif_qkey_pkey_trap {
	/* *** 64 bit group 0 start *** */
	/* Union containing P-Key or Q-Key information. */
	union psif_qkey_pkey_trap_union	key; /* 32 bits @ offs 0:0 */
	/* Destination LID path bits. */
	u16	dlid_path:7; /* 7 bits @ offs 0:32 */
	/* UF. */
	u16	uf:6; /* 6 bits @ offs 0:39 */
	/* Reserved */
	u16	:3; /* 3 bits @ offs 0:45 */
	/* Source LID. Only valid for UD. */
	u16	slid; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_qkey_pkey_trap [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_LID_KEY */
/* Trap register for P-Key and Q-Key traps. */
struct psif_csr_rcv_key_trap_lid_key {
	/* *** 64 bit group 0 start *** */
	struct psif_qkey_pkey_trap	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_lid_key [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_POP */
/* Pop register for P-Key and Q-Key trap FIFO. */
struct psif_csr_rcv_key_trap_pop {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_pop [64 bits] */

/* CSR automated type for TSU_RCV_KEY_TRAP_BACKPRESSURE */
/* Register indicating what to do if the trap FIFO is full. */
struct psif_csr_rcv_key_trap_backpressure {
	/* *** 64 bit group 0 start *** */
	u64	rc:1; /* 1 bits @ offs 0:0 */
	u64	uc:1; /* 1 bits @ offs 0:1 */
	u64	ud:1; /* 1 bits @ offs 0:2 */
	u64	xrc:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_key_trap_backpressure [64 bits] */

/* CSR automated type for TSU_RCV_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_rcv_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_int_status [64 bits] */

/* CSR automated type for TSU_RCV_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_rcv_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_int_mask [64 bits] */

/* CSR automated type for TSU_RCV_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_rcv_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_int_pri [64 bits] */

/* CSR automated type for TSU_RCV_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_rcv_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_int_status_clear [64 bits] */

/* CSR automated type for TSU_RCV_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_rcv_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_PKEY_TABLE */
/* Shared P-Key table for all UFs on this port. */
struct psif_csr_rcv_pkey_table {
	/* *** 64 bit group 0 start *** */
	/* ib_bth_pkey(16[0] bits)Partition Key */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_pkey_table [64 bits] */

struct psif_lid_base {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:44; /* 44 bits @ offs 0:0 */
	/* If set GID routing must be used. */
	u64	gid_flag:1; /* 1 bits @ offs 0:44 */
	/* LID mask control. */
	u64	lmc:3; /* 3 bits @ offs 0:45 */
	/* LID base. */
	u64	lid_base:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_lid_base [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_OWN_LID_BASE */
/*
 * Own LIDs base and LMC. Potentially all own LID bits come from the QP state
 * entry. The number of bits to use is based on the LMC. Per UF register.
 */
struct psif_csr_rcv_lid {
	/* *** 64 bit group 0 start *** */
	/* If set GID routing must be used. */
	u64	gid_flag:1; /* 1 bits @ offs 0:0 */
	/* LID mask control. */
	u64	lmc:3; /* 3 bits @ offs 0:1 */
	/* LID base. */
	u64	lid_base:16; /* 16 bits @ offs 0:4 */
	/* Inlined data : struct psif_lid_base (64 bits) */ /* 64 bits @ offs 0:20 */
	u64	:44; /* 44 bits @ offs 0:20 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_lid [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_PKEY_UF_STRIDE */
/*
 * Size of individual P-Key tables per UF. All UFs have the same size or if
 * set to 0, it means one common table.
 */
struct psif_csr_rcv_pkey_uf_stride {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_pkey_uf_stride [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_DEFAULT_VSWITCH_PORT */
/* Default vSwitch port for vSwitch1. */
struct psif_csr_ibpr_default_vswitch_port {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	data:6; /* 6 bits @ offs 0:0 */
	u64	:58; /* 58 bits @ offs 0:6 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_default_vswitch_port [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_DEFAULT_SM_HCA */
/* Default SM HCA. Indicating which vHCA to send SM packets to. */
struct psif_csr_ibpr_default_sm_hca {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	data:6; /* 6 bits @ offs 0:0 */
	u64	:58; /* 58 bits @ offs 0:6 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_default_sm_hca [64 bits] */

/* GSI forwarding for different GSI types. */
struct psif_gsi_forwarding {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:55; /* 55 bits @ offs 0:0 */
	/*
	 * Application Specific classes. Refer to Annex 'Application Specific
	 * Identifiers' for a listing of Application Specific Management class values
	 * currently assigned.
	 */
	u64	application:1; /* 1 bits @ offs 0:55 */
	/* Vendor Specific classes */
	u64	vendor:1; /* 1 bits @ offs 0:56 */
	/*
	 * SNMP Tunneling class (tunneling of the SNMP protocol through the IBA
	 * fabric)
	 */
	u64	snmp:1; /* 1 bits @ offs 0:57 */
	/* Communication Management class */
	u64	com_mgt:1; /* 1 bits @ offs 0:58 */
	/* Device Management class */
	u64	dev_mgt:1; /* 1 bits @ offs 0:59 */
	/* Base Management class (tunneling of IB-ML commands through the IBA subnet) */
	u64	bm:1; /* 1 bits @ offs 0:60 */
	/* Performance Management class */
	u64	perf:1; /* 1 bits @ offs 0:61 */
	/* Subnet Administration class */
	u64	subn_adm:1; /* 1 bits @ offs 0:62 */
	/* Subnet Management class (Directed Route) */
	u64	subn:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_gsi_forwarding [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_GSI_FORWARDING_TABLE */
/*
 * When a bit is set, the TSU will forward the particular management class to
 * EPS-C. Per UF0-UF32.
 */
struct psif_csr_ibpr_gsi_forwarding_table {
	/* *** 64 bit group 0 start *** */
	/*
	 * Application Specific classes. Refer to Annex 'Application Specific
	 * Identifiers' for a listing of Application Specific Management class values
	 * currently assigned.
	 */
	u64	application:1; /* 1 bits @ offs 0:0 */
	/* Vendor Specific classes */
	u64	vendor:1; /* 1 bits @ offs 0:1 */
	/*
	 * SNMP Tunneling class (tunneling of the SNMP protocol through the IBA
	 * fabric)
	 */
	u64	snmp:1; /* 1 bits @ offs 0:2 */
	/* Communication Management class */
	u64	com_mgt:1; /* 1 bits @ offs 0:3 */
	/* Device Management class */
	u64	dev_mgt:1; /* 1 bits @ offs 0:4 */
	/* Base Management class (tunneling of IB-ML commands through the IBA subnet) */
	u64	bm:1; /* 1 bits @ offs 0:5 */
	/* Performance Management class */
	u64	perf:1; /* 1 bits @ offs 0:6 */
	/* Subnet Administration class */
	u64	subn_adm:1; /* 1 bits @ offs 0:7 */
	/* Subnet Management class (Directed Route) */
	u64	subn:1; /* 1 bits @ offs 0:8 */
	/* Inlined data : struct psif_gsi_forwarding (64 bits) */ /* 64 bits @ offs 0:9 */
	u64	:55; /* 55 bits @ offs 0:9 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_gsi_forwarding_table [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_SMP_ALLOWED */
/*
 * Register with a bit per UF/VHCA indicating if the UF/VHCA is allowed to
 * send SMPs.
 */
struct psif_csr_ibpr_smp_allowed {
	/* *** 64 bit group 0 start *** */
	/* num_vhca(33[0] bits)Number of vHCAs. */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_smp_allowed [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_SMP_ALLOWED_DROP_STATUS_CLEAR */
/*
 * Status register with a bit per UF/VHCA indicating if an UF/VHCA SMP not
 * allowed packet drop status is cleared.
 */
struct psif_csr_ibpr_smp_allowed_drop_status_clear {
	/* *** 64 bit group 0 start *** */
	/* num_vhca(33[0] bits)Number of vHCAs. */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_smp_allowed_drop_status_clear [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_SMP_ALLOWED_DROP_STATUS */
/*
 * Status register with a bit per UF/VHCA indicating if an UF/VHCA SMP not
 * allowed packet is dropped.
 */
struct psif_csr_ibpr_smp_allowed_drop_status {
	/* *** 64 bit group 0 start *** */
	/* num_vhca(33[0] bits)Number of vHCAs. */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_smp_allowed_drop_status [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_SAMPLE_INTERVAL */
/* Sample interval register. */
struct psif_csr_ibpr_vswitch1_sample_interval {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_sample_interval [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_SAMPLE_START */
/* Sample start delay register. */
struct psif_csr_ibpr_vswitch1_sample_start {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_sample_start [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_SAMPLE_COUNT */
/* Sample count register. This register contain the counted values. */
struct psif_csr_ibpr_vswitch1_sample_count {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_sample_count [64 bits] */

struct psif_port_samplecounter_sel {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:39; /* 39 bits @ offs 0:0 */
	/* If applicable counter type which opcode are this counter counting for. */
	#if defined(__arm__) /* enum ib_opcode */
		u64	opcode:8;
	#else /* !__arm__ */
		enum ib_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 0:39 */
	/* If applicable counter type which VL are this counter counting for. */
	u64	vl:4; /* 4 bits @ offs 0:47 */
	/* If applicable counter type which UF are this counter counting for. */
	u64	uf:6; /* 6 bits @ offs 0:51 */
	/* Port sample type which is being counted. */
	#if defined(__arm__) /* enum psif_port_samplecounter_type */
		u64	counter_type:7;
	#else /* !__arm__ */
		enum psif_port_samplecounter_type	counter_type:7;
	#endif	 /* 7 bits @ offs 0:57 */
} PSIF_PACKED_ALIGNED; /* struct psif_port_samplecounter_sel [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_SAMPLE_PORT */
/*
 * Sample UF register. Indicating which port this entry is counting for and
 * what type it is counting.
 */
struct psif_csr_ibpr_vswitch1_sample_port {
	/* *** 64 bit group 0 start *** */
	/* If applicable counter type which opcode are this counter counting for. */
	#if defined(__arm__) /* enum ib_opcode */
		u64	opcode:8;
	#else /* !__arm__ */
		enum ib_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 0:0 */
	/* If applicable counter type which VL are this counter counting for. */
	u64	vl:4; /* 4 bits @ offs 0:8 */
	/* If applicable counter type which UF are this counter counting for. */
	u64	uf:6; /* 6 bits @ offs 0:12 */
	/* Port sample type which is being counted. */
	#if defined(__arm__) /* enum psif_port_samplecounter_type */
		u64	counter_type:7;
	#else /* !__arm__ */
		enum psif_port_samplecounter_type	counter_type:7;
	#endif	 /* 7 bits @ offs 0:18 */
	/* Inlined data : struct psif_port_samplecounter_sel (64 bits) */ /* 64 bits @ offs 0:25 */
	u64	:39; /* 39 bits @ offs 0:25 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_sample_port [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_PORTSAMPLE_START */
/* Start port Sampling. */
struct psif_csr_ibpr_vswitch1_portsample_start {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_portsample_start [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_SAMPLE_STATUS */
/* Sample status register. */
struct psif_csr_ibpr_vswitch1_sample_status {
	/* *** 64 bit group 0 start *** */
	u64	data:2; /* 2 bits @ offs 0:0 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_sample_status [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_SAMPLE_INTERVAL */
/* Sample interval register. */
struct psif_csr_ibpr_vhca_sample_interval {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_sample_interval [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_SAMPLE_START */
/* Sample start delay register. */
struct psif_csr_ibpr_vhca_sample_start {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_sample_start [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_SAMPLE_COUNT */
/* Sample count register. This register contain the counted values. */
struct psif_csr_ibpr_vhca_sample_count {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_sample_count [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_SAMPLE_PORT */
/*
 * Sample UF register. Indicating which port this entry is counting for and
 * what type it is counting.
 */
struct psif_csr_ibpr_vhca_sample_port {
	/* *** 64 bit group 0 start *** */
	/* If applicable counter type which opcode are this counter counting for. */
	#if defined(__arm__) /* enum ib_opcode */
		u64	opcode:8;
	#else /* !__arm__ */
		enum ib_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 0:0 */
	/* If applicable counter type which VL are this counter counting for. */
	u64	vl:4; /* 4 bits @ offs 0:8 */
	/* If applicable counter type which UF are this counter counting for. */
	u64	uf:6; /* 6 bits @ offs 0:12 */
	/* Port sample type which is being counted. */
	#if defined(__arm__) /* enum psif_port_samplecounter_type */
		u64	counter_type:7;
	#else /* !__arm__ */
		enum psif_port_samplecounter_type	counter_type:7;
	#endif	 /* 7 bits @ offs 0:18 */
	/* Inlined data : struct psif_port_samplecounter_sel (64 bits) */ /* 64 bits @ offs 0:25 */
	u64	:39; /* 39 bits @ offs 0:25 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_sample_port [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_PORTSAMPLE_START */
/* Start port Sampling. */
struct psif_csr_ibpr_vhca_portsample_start {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_portsample_start [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_SAMPLE_STATUS */
/* Sample status register. */
struct psif_csr_ibpr_vhca_sample_status {
	/* *** 64 bit group 0 start *** */
	u64	data:2; /* 2 bits @ offs 0:0 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_sample_status [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_SAMPLE_INTERVAL */
/* Sample interval register. */
struct psif_csr_ibpr_vswitch2_sample_interval {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_sample_interval [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_SAMPLE_START */
/* Sample start delay register. */
struct psif_csr_ibpr_vswitch2_sample_start {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_sample_start [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_SAMPLE_COUNT */
/* Sample count register. This register contain the counted values. */
struct psif_csr_ibpr_vswitch2_sample_count {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_sample_count [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_SAMPLE_PORT */
/*
 * Sample UF register. Indicating which UF this entry is counting for and
 * what type it is counting.
 */
struct psif_csr_ibpr_vswitch2_sample_port {
	/* *** 64 bit group 0 start *** */
	/* If applicable counter type which opcode are this counter counting for. */
	#if defined(__arm__) /* enum ib_opcode */
		u64	opcode:8;
	#else /* !__arm__ */
		enum ib_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 0:0 */
	/* If applicable counter type which VL are this counter counting for. */
	u64	vl:4; /* 4 bits @ offs 0:8 */
	/* If applicable counter type which UF are this counter counting for. */
	u64	uf:6; /* 6 bits @ offs 0:12 */
	/* Port sample type which is being counted. */
	#if defined(__arm__) /* enum psif_port_samplecounter_type */
		u64	counter_type:7;
	#else /* !__arm__ */
		enum psif_port_samplecounter_type	counter_type:7;
	#endif	 /* 7 bits @ offs 0:18 */
	/* Inlined data : struct psif_port_samplecounter_sel (64 bits) */ /* 64 bits @ offs 0:25 */
	u64	:39; /* 39 bits @ offs 0:25 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_sample_port [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_PORTSAMPLE_START */
/* Start port Sampling. */
struct psif_csr_ibpr_vswitch2_portsample_start {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_portsample_start [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_SAMPLE_STATUS */
/* Sample status register. */
struct psif_csr_ibpr_vswitch2_sample_status {
	/* *** 64 bit group 0 start *** */
	u64	data:2; /* 2 bits @ offs 0:0 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_sample_status [64 bits] */

/* CSR automated type for TSU_IBPR_SET_VLINK_STATE */
/* Set link state for the vHCA or the vSwitch. */
struct psif_csr_ibpr_set_vlink_state {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_set_vlink_state [64 bits] */

struct psif_set_vlink_state {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:51; /* 51 bits @ offs 0:0 */
	/* UF. */
	u64	uf:6; /* 6 bits @ offs 0:51 */
	/* Port number the link state is valid for. */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:57 */
	/*
	 * Does the state belong to the vHCA or the vSwitch. 0: vhca side 1: vswitch
	 * side.
	 */
	u64	vhca_or_vswitch:1; /* 1 bits @ offs 0:58 */
	/* Link state to set to the UF. */
	#if defined(__arm__) /* enum psif_vlink_state */
		u64	link_state:5;
	#else /* !__arm__ */
		enum psif_vlink_state	link_state:5;
	#endif	 /* 5 bits @ offs 0:59 */
} PSIF_PACKED_ALIGNED; /* struct psif_set_vlink_state [64 bits] */

/* CSR automated type for TSU_IBPR_VLINK_STATE_REGISTER */
/* link state for the vHCA or the vSwitch. */
struct psif_csr_ibpr_vlink_state_register {
	/* *** 64 bit group 0 start *** */
	/* UF. */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	/* Port number the link state is valid for. */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:6 */
	/*
	 * Does the state belong to the vHCA or the vSwitch. 0: vhca side 1: vswitch
	 * side.
	 */
	u64	vhca_or_vswitch:1; /* 1 bits @ offs 0:7 */
	/* Link state to set to the UF. */
	#if defined(__arm__) /* enum psif_vlink_state */
		u64	link_state:5;
	#else /* !__arm__ */
		enum psif_vlink_state	link_state:5;
	#endif	 /* 5 bits @ offs 0:8 */
	/* Inlined data : struct psif_set_vlink_state (64 bits) */ /* 64 bits @ offs 0:13 */
	u64	:51; /* 51 bits @ offs 0:13 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vlink_state_register [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_VLINK_STATE */
/*
 * Get vlink state for the vHCA and the vSwitch. It is up to the firmware to
 * report correct physical link states when one side is set to disabled and
 * the other side is down.
 */
struct psif_csr_ibpr_vlink_state {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_vlink_state */
		u64	vhca_state:5;
	#else /* !__arm__ */
		enum psif_vlink_state	vhca_state:5;
	#endif	 /* 5 bits @ offs 0:0 */
	#if defined(__arm__) /* enum psif_vlink_state */
		u64	vswitch_state:5;
	#else /* !__arm__ */
		enum psif_vlink_state	vswitch_state:5;
	#endif	 /* 5 bits @ offs 0:5 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vlink_state [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_GID_UPPER */
/*
 * When data is present, this register should be read for processing.
 * Hardware multicast FIFO is popped when p1_mcast_pop is written.
 */
struct psif_csr_ibpr_mcast_gid_upper {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_gid_upper [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_GID_LOWER */
/*
 * When data is present, this register should be read for processing.
 * Hardware multicast FIFO is popped when p1_mcast_pop is written.
 */
struct psif_csr_ibpr_mcast_gid_lower {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_gid_lower [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_GIDHASH_LID */
/*
 * When data is present, this register should be read for processing.
 * Hardware multicast FIFO is popped when p1_mcast_pop is written.
 */
struct psif_csr_ibpr_mcast_gidhash_lid {
	/* *** 64 bit group 0 start *** */
	u64	datavalid:1; /* 1 bits @ offs 0:0 */
	u64	lid:16; /* 16 bits @ offs 0:1 */
	u64	gidhash:32; /* 32 bits @ offs 0:17 */
	u64	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_gidhash_lid [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_POP */
/*
 * This pop register is written after data in p1_mcast_gid_upper,
 * p1_mcast_gid_lower and p1_mcast_lid is read. Writing this register will
 * pop the FIFO.
 */
struct psif_csr_ibpr_mcast_pop {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_pop [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_MAX_PKTS */
/*
 * This registers indicate how many multicast packets this port can hold
 * before starting drop packets.
 */
struct psif_csr_ibpr_mcast_max_pkts {
	/* *** 64 bit group 0 start *** */
	u64	data:10; /* 10 bits @ offs 0:0 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_max_pkts [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_WR_CREDIT */
/*
 * This register contain the credit for writing to the CSR FIFO for multicast
 * packets.
 */
struct psif_csr_ibpr_mcast_wr_credit {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_wr_credit [64 bits] */

struct psif_mcast_wr_data {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:34; /* 34 bits @ offs 0:0 */
	/* QP number to send packet to. */
	u64	qp_num:24; /* 24 bits @ offs 0:34 */
	/* UF to replicate the packet to. */
	u64	uf:6; /* 6 bits @ offs 0:58 */
} PSIF_PACKED_ALIGNED; /* struct psif_mcast_wr_data [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_WR_FIFO */
/* Write to multicast FIFO. */
struct psif_csr_ibpr_mcast_wr_fifo {
	/* *** 64 bit group 0 start *** */
	/* QP number to send packet to. */
	u64	qp_num:24; /* 24 bits @ offs 0:0 */
	/* UF to replicate the packet to. */
	u64	uf:6; /* 6 bits @ offs 0:24 */
	/* Inlined data : struct psif_mcast_wr_data (64 bits) */ /* 64 bits @ offs 0:30 */
	u64	:34; /* 34 bits @ offs 0:30 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_wr_fifo [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_MCAST_WR_FIFO_KICK */
/* Kick multicast FIFO - data is valid in the multicast FIFO. */
struct psif_csr_ibpr_mcast_wr_fifo_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_mcast_wr_fifo_kick [64 bits] */

/* CSR automated type for TSU_IBPR_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_ibpr_int_status {
	/* *** 64 bit group 0 start *** */
	u64	p2_rx_choke_done:1; /* 1 bits @ offs 0:0 */
	u64	p1_rx_choke_done:1; /* 1 bits @ offs 0:1 */
	u64	p2_mcast:1; /* 1 bits @ offs 0:2 */
	u64	p1_mcast:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_int_status [64 bits] */

/* CSR automated type for TSU_IBPR_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_ibpr_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	p2_rx_choke_done_mask:1; /* 1 bits @ offs 0:0 */
	u64	p1_rx_choke_done_mask:1; /* 1 bits @ offs 0:1 */
	u64	p2_mcast_mask:1; /* 1 bits @ offs 0:2 */
	u64	p1_mcast_mask:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_int_mask [64 bits] */

/* CSR automated type for TSU_IBPR_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_ibpr_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	p2_rx_choke_done_pri:1; /* 1 bits @ offs 0:0 */
	u64	p1_rx_choke_done_pri:1; /* 1 bits @ offs 0:1 */
	u64	p2_mcast_pri:1; /* 1 bits @ offs 0:2 */
	u64	p1_mcast_pri:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_int_pri [64 bits] */

/* CSR automated type for TSU_IBPR_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_ibpr_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	p2_rx_choke_done_clear:1; /* 1 bits @ offs 0:0 */
	u64	p1_rx_choke_done_clear:1; /* 1 bits @ offs 0:1 */
	u64	p2_mcast_clear:1; /* 1 bits @ offs 0:2 */
	u64	p1_mcast_clear:1; /* 1 bits @ offs 0:3 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_int_status_clear [64 bits] */

/* CSR automated type for TSU_IBPR_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_ibpr_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_RX_CHOKE */
/* Rx choke register */
struct psif_csr_ibpr_rx_choke {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_rx_choke [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_XMIT_DISCARDS */
/* Port counter PortXmitDiscards. This is per vSwitch port [32:0]. */
struct psif_csr_ibpr_vswitch1_xmit_discards {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_xmit_discards [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_RCV_SWITCH_RELAY_ERRORS */
/*
 * Port counter PortRcvSwitchRelayErrors. This register entry is associated
 * with the corresponding register entry in all other sample register per
 * port.
 */
struct psif_csr_ibpr_vswitch1_rcv_switch_relay_errors {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_rcv_switch_relay_errors [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_RCV_PKTS_DROP */
/* Vendor Port counter receive packets drop. This is per vSwitch. */
struct psif_csr_ibpr_vswitch1_rcv_pkts_drop {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_rcv_pkts_drop [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_PORTCOUNTER_CLEAR */
/*
 * Clear portcounter according to setting in portcounter_clear registers
 */
struct psif_csr_ibpr_vswitch1_portcounter_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_portcounter_clear [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_XMIT_DISCARD_CLEAR_REGISTER */
/* Clear register for the the PortXmitDiscard */
struct psif_csr_ibpr_vswitch1_xmit_discard_clear_register {
	/* *** 64 bit group 0 start *** */
	/* num_vhca(33[0] bits)Number of vHCAs. */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_xmit_discard_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH1_PORTCOUNTER_CLEAR_REGISTER */
/* Clear register for portcounters (single instance) */
struct psif_csr_ibpr_vswitch1_portcounter_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:2; /* 2 bits @ offs 0:0 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch1_portcounter_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_DISCARDS */
/* Port counter PortXmitDiscards. This is per vSwitch port. */
struct psif_csr_ibpr_vhca_xmit_discards {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_discards [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_RCV_DATA */
/* Port counter Port Receive data. This is per vSwitch port. */
struct psif_csr_ibpr_vhca_rcv_data {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_rcv_data [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_RCV_PKTS */
/* Port counter Port Receive Packets. This is per vSwitch port. */
struct psif_csr_ibpr_vhca_rcv_pkts {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_rcv_pkts [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_DATA */
/* Port counter Port Xmit data. This is per vSwitch port. */
struct psif_csr_ibpr_vhca_xmit_data {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_data [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_PKTS */
/* Port counter Port Xmit Packets. This is per vSwitch port. */
struct psif_csr_ibpr_vhca_xmit_pkts {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_pkts [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_PKTS_DROP */
/*
 * Port counter counting packets dropped (marked p_error) in Xmit path.
 */
struct psif_csr_ibpr_vhca_xmit_pkts_drop {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_pkts_drop [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_PORTCOUNTER_CLEAR */
/*
 * Clear vhca portcounters according to vhca port counter clear registers.
 */
struct psif_csr_ibpr_vhca_portcounter_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_portcounter_clear [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_DISCARDS_CLEAR_REGISTER */
/*
 * Register specifying clear on the the PortXmitDiscards counter. This is per
 * vSwitch port.
 */
struct psif_csr_ibpr_vhca_xmit_discards_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_discards_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_RCV_DATA_CLEAR_REGISTER */
/*
 * Register specifying clear on the the PortRcvData counter. This is per vHCA
 * port[32:0].
 */
struct psif_csr_ibpr_vhca_rcv_data_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_rcv_data_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_RCV_PKTS_CLEAR_REGISTER */
/*
 * Register specifying clear on the the PortRcvPkts counter. This is per vHCA
 * port[32:0].
 */
struct psif_csr_ibpr_vhca_rcv_pkts_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_rcv_pkts_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_DATA_CLEAR_REGISTER */
/*
 * Register specifying clear on the the PortRcvData counter. This is per vHCA
 * port[32:0].
 */
struct psif_csr_ibpr_vhca_xmit_data_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_data_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_PKTS_CLEAR_REGISTER */
/*
 * Register specifying clear on the the PortXmitPkts counter. This is per
 * vHCA port[32:0].
 */
struct psif_csr_ibpr_vhca_xmit_pkts_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_pkts_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VHCA_P{1,2}_XMIT_PKTS_DROP_CLEAR_REGISTER */
/*
 * Register specifying clear on the the PortXmitPkts drop counter. This is
 * per vHCA port[32:0].
 */
struct psif_csr_ibpr_vhca_xmit_pkts_drop_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vhca_xmit_pkts_drop_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_XMIT_DISCARDS */
/* Port counter PortXmitDiscards. This is per vSwitch port [32:0]. */
struct psif_csr_ibpr_vswitch2_xmit_discards {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_xmit_discards [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_RCV_SWITCH_RELAY_ERRORS */
/*
 * Port counter PortRcvSwitchRelayErrors. This register entry is associated
 * with the corresponding register entry in all other sample register per
 * port.
 */
struct psif_csr_ibpr_vswitch2_rcv_switch_relay_errors {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_rcv_switch_relay_errors [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_RCV_PKTS_DROP */
/* Vendor Port counter receive packets drop. This is per vSwitch. */
struct psif_csr_ibpr_vswitch2_rcv_pkts_drop {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_rcv_pkts_drop [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_PORTCOUNTER_CLEAR */
/*
 * Clear portcounter according to setting in portcounter_clear registers
 */
struct psif_csr_ibpr_vswitch2_portcounter_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_portcounter_clear [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_XMIT_DISCARD_CLEAR_REGISTER */
/* Clear register for the the PortXmitDiscard */
struct psif_csr_ibpr_vswitch2_xmit_discard_clear_register {
	/* *** 64 bit group 0 start *** */
	/* num_vhca(33[0] bits)Number of vHCAs. */
	u64	data:33; /* 33 bits @ offs 0:0 */
	u64	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_xmit_discard_clear_register [64 bits] */

/* CSR automated type for TSU_IBPR_VSWITCH2_PORTCOUNTER_CLEAR_REGISTER */
/* Clear register for portcounters (single instance) */
struct psif_csr_ibpr_vswitch2_portcounter_clear_register {
	/* *** 64 bit group 0 start *** */
	u64	data:2; /* 2 bits @ offs 0:0 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_vswitch2_portcounter_clear_register [64 bits] */

/* ULP combinations. */
struct psif_ulp_combinations {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:61; /* 61 bits @ offs 0:0 */
	/*
	 * Enable bit for RSS for EPS-A offloading. This is not supported in PSIF
	 * version 1 and is ignored if set.
	 */
	u64	rss_offload_en:1; /* 1 bits @ offs 0:61 */
	/* Enable bit for RSS for IP over IB. */
	u64	rss_ipoib_en:1; /* 1 bits @ offs 0:62 */
	/* Enable bit for RSS for Ethernet over IB. */
	u64	rss_eoib_en:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_ulp_combinations [64 bits] */

/* Flags for deciding what RSS combinations to implement. */
struct psif_rss_flags_eoib {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:53; /* 53 bits @ offs 0:0 */
	/* TBD */
	u64	eoib_ipv6_udp_ex:1; /* 1 bits @ offs 0:53 */
	/* TBD */
	u64	eoib_ipv6_tcp_ex:1; /* 1 bits @ offs 0:54 */
	/* TBD */
	u64	eoib_ipv6_ex:1; /* 1 bits @ offs 0:55 */
	/* TBD */
	u64	eoib_ipv6_frag:1; /* 1 bits @ offs 0:56 */
	/* TBD */
	u64	eoib_ipv6_udp:1; /* 1 bits @ offs 0:57 */
	/* TBD */
	u64	eoib_ipv6_tcp:1; /* 1 bits @ offs 0:58 */
	/* TBD */
	u64	eoib_ipv6:1; /* 1 bits @ offs 0:59 */
	/* TBD */
	u64	eoib_ipv4_frag:1; /* 1 bits @ offs 0:60 */
	/* TBD */
	u64	eoib_ipv4_udp:1; /* 1 bits @ offs 0:61 */
	/* TBD */
	u64	eoib_ipv4_tcp:1; /* 1 bits @ offs 0:62 */
	/* TBD. */
	u64	eoib_ipv4:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_rss_flags_eoib [64 bits] */

/* Flags for deciding what RSS combinations to implement. */
struct psif_rss_flags_ipoib {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:53; /* 53 bits @ offs 0:0 */
	/* TBD */
	u64	ipoib_ipv6_udp_ex:1; /* 1 bits @ offs 0:53 */
	/* TBD */
	u64	ipoib_ipv6_tcp_ex:1; /* 1 bits @ offs 0:54 */
	/* TBD */
	u64	ipoib_ipv6_ex:1; /* 1 bits @ offs 0:55 */
	/* TBD */
	u64	ipoib_ipv6_frag:1; /* 1 bits @ offs 0:56 */
	/* TBD */
	u64	ipoib_ipv6_udp:1; /* 1 bits @ offs 0:57 */
	/* TBD */
	u64	ipoib_ipv6_tcp:1; /* 1 bits @ offs 0:58 */
	/* TBD */
	u64	ipoib_ipv6:1; /* 1 bits @ offs 0:59 */
	/* TBD */
	u64	ipoib_ipv4_frag:1; /* 1 bits @ offs 0:60 */
	/* TBD */
	u64	ipoib_ipv4_udp:1; /* 1 bits @ offs 0:61 */
	/* TBD */
	u64	ipoib_ipv4_tcp:1; /* 1 bits @ offs 0:62 */
	/* TBD. */
	u64	ipoib_ipv4:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_rss_flags_ipoib [64 bits] */

struct psif_rss_control {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:39; /* 39 bits @ offs 0:0 */
	/* TBD */
	u64	ipoib_ipv6_udp_ex:1; /* 1 bits @ offs 0:39 */
	/* TBD */
	u64	ipoib_ipv6_tcp_ex:1; /* 1 bits @ offs 0:40 */
	/* TBD */
	u64	ipoib_ipv6_ex:1; /* 1 bits @ offs 0:41 */
	/* TBD */
	u64	ipoib_ipv6_frag:1; /* 1 bits @ offs 0:42 */
	/* TBD */
	u64	ipoib_ipv6_udp:1; /* 1 bits @ offs 0:43 */
	/* TBD */
	u64	ipoib_ipv6_tcp:1; /* 1 bits @ offs 0:44 */
	/* TBD */
	u64	ipoib_ipv6:1; /* 1 bits @ offs 0:45 */
	/* TBD */
	u64	ipoib_ipv4_frag:1; /* 1 bits @ offs 0:46 */
	/* TBD */
	u64	ipoib_ipv4_udp:1; /* 1 bits @ offs 0:47 */
	/* TBD */
	u64	ipoib_ipv4_tcp:1; /* 1 bits @ offs 0:48 */
	/* TBD. */
	u64	ipoib_ipv4:1; /* 1 bits @ offs 0:49 */
	/* Flags defining inputs to the RSS hash calculation for IPoIB table. */
	/* Inlined rss_flags_ipoib : struct psif_rss_flags_ipoib (64 bits) */ /* 64 bits @ offs 0:50 */
	/* TBD */
	u64	eoib_ipv6_udp_ex:1; /* 1 bits @ offs 0:50 */
	/* TBD */
	u64	eoib_ipv6_tcp_ex:1; /* 1 bits @ offs 0:51 */
	/* TBD */
	u64	eoib_ipv6_ex:1; /* 1 bits @ offs 0:52 */
	/* TBD */
	u64	eoib_ipv6_frag:1; /* 1 bits @ offs 0:53 */
	/* TBD */
	u64	eoib_ipv6_udp:1; /* 1 bits @ offs 0:54 */
	/* TBD */
	u64	eoib_ipv6_tcp:1; /* 1 bits @ offs 0:55 */
	/* TBD */
	u64	eoib_ipv6:1; /* 1 bits @ offs 0:56 */
	/* TBD */
	u64	eoib_ipv4_frag:1; /* 1 bits @ offs 0:57 */
	/* TBD */
	u64	eoib_ipv4_udp:1; /* 1 bits @ offs 0:58 */
	/* TBD */
	u64	eoib_ipv4_tcp:1; /* 1 bits @ offs 0:59 */
	/* TBD. */
	u64	eoib_ipv4:1; /* 1 bits @ offs 0:60 */
	/* Flags defining inputs to the RSS hash calculation for EoIB table. */
	/* Inlined rss_flags_eoib : struct psif_rss_flags_eoib (64 bits) */ /* 64 bits @ offs 0:61 */
	/*
	 * Enable bit for RSS for EPS-A offloading. This is not supported in PSIF
	 * version 1 and is ignored if set.
	 */
	u64	rss_offload_en:1; /* 1 bits @ offs 0:61 */
	/* Enable bit for RSS for IP over IB. */
	u64	rss_ipoib_en:1; /* 1 bits @ offs 0:62 */
	/* Enable bit for RSS for Ethernet over IB. */
	u64	rss_eoib_en:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	/* Valid RSS combinations to calculate. */
	/* Inlined ulp_combinations : struct psif_ulp_combinations (64 bits) */ /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_rss_control [64 bits] */

/* CSR automated type for TSU_IBPR_RSS_CONTROL */
/*
 * Per vHCA (UF0-32) register. This table contain valid RSS combinations to
 * calculate for this UF.
 */
struct psif_csr_ibpr_rss_control {
	/* *** 64 bit group 0 start *** */
	/* TBD */
	u16	ipoib_ipv6_udp_ex:1; /* 1 bits @ offs 0:0 */
	/* TBD */
	u16	ipoib_ipv6_tcp_ex:1; /* 1 bits @ offs 0:1 */
	/* TBD */
	u16	ipoib_ipv6_ex:1; /* 1 bits @ offs 0:2 */
	/* TBD */
	u16	ipoib_ipv6_frag:1; /* 1 bits @ offs 0:3 */
	/* TBD */
	u16	ipoib_ipv6_udp:1; /* 1 bits @ offs 0:4 */
	/* TBD */
	u16	ipoib_ipv6_tcp:1; /* 1 bits @ offs 0:5 */
	/* TBD */
	u16	ipoib_ipv6:1; /* 1 bits @ offs 0:6 */
	/* TBD */
	u16	ipoib_ipv4_frag:1; /* 1 bits @ offs 0:7 */
	/* TBD */
	u16	ipoib_ipv4_udp:1; /* 1 bits @ offs 0:8 */
	/* TBD */
	u16	ipoib_ipv4_tcp:1; /* 1 bits @ offs 0:9 */
	/* TBD. */
	u16	ipoib_ipv4:1; /* 1 bits @ offs 0:10 */
	/* Flags defining inputs to the RSS hash calculation for IPoIB table. */
	/* Inlined rss_flags_ipoib : struct psif_rss_flags_ipoib (64 bits) */ /* 64 bits @ offs 0:11 */
	/* TBD */
	u16	eoib_ipv6_udp_ex:1; /* 1 bits @ offs 0:11 */
	/* TBD */
	u16	eoib_ipv6_tcp_ex:1; /* 1 bits @ offs 0:12 */
	/* TBD */
	u16	eoib_ipv6_ex:1; /* 1 bits @ offs 0:13 */
	/* TBD */
	u16	eoib_ipv6_frag:1; /* 1 bits @ offs 0:14 */
	/* TBD */
	u16	eoib_ipv6_udp:1; /* 1 bits @ offs 0:15 */
	/* TBD */
	u64	eoib_ipv6_tcp:1; /* 1 bits @ offs 0:16 */
	/* TBD */
	u64	eoib_ipv6:1; /* 1 bits @ offs 0:17 */
	/* TBD */
	u64	eoib_ipv4_frag:1; /* 1 bits @ offs 0:18 */
	/* TBD */
	u64	eoib_ipv4_udp:1; /* 1 bits @ offs 0:19 */
	/* TBD */
	u64	eoib_ipv4_tcp:1; /* 1 bits @ offs 0:20 */
	/* TBD. */
	u64	eoib_ipv4:1; /* 1 bits @ offs 0:21 */
	/* Flags defining inputs to the RSS hash calculation for EoIB table. */
	/* Inlined rss_flags_eoib : struct psif_rss_flags_eoib (64 bits) */ /* 64 bits @ offs 0:22 */
	/*
	 * Enable bit for RSS for EPS-A offloading. This is not supported in PSIF
	 * version 1 and is ignored if set.
	 */
	u64	rss_offload_en:1; /* 1 bits @ offs 0:22 */
	/* Enable bit for RSS for IP over IB. */
	u64	rss_ipoib_en:1; /* 1 bits @ offs 0:23 */
	/* Enable bit for RSS for Ethernet over IB. */
	u64	rss_eoib_en:1; /* 1 bits @ offs 0:24 */
	/* Valid RSS combinations to calculate. */
	/* Inlined ulp_combinations : struct psif_ulp_combinations (64 bits) */ /* 64 bits @ offs 0:25 */
	/* Inlined data : struct psif_rss_control (64 bits) */ /* 64 bits @ offs 0:25 */
	u64	:39; /* 39 bits @ offs 0:25 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_rss_control [64 bits] */

/* CSR automated type for TSU_IBPR_RSS_IPV4_SECRET_KEY */
/* 16B Secret key for RSS generation for IPv4. */
struct psif_csr_ibpr_rss_ipv4_secret_key {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_rss_ipv4_secret_key [64 bits] */

/* CSR automated type for TSU_IBPR_RSS_IPV6_SECRET_KEY */
/* 40B Secret key for RSS generation for IPv6. */
struct psif_csr_ibpr_rss_ipv6_secret_key {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_rss_ipv6_secret_key [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_GID_UPPER */
/*
 * Upper 64 bits of GID for port1. There are (2 * NUM_VHCA + 1) 67 GIDs per
 * physical IB port.
 */
struct psif_csr_rcv_gid_upper {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_gid_upper [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_GID_LOWER */
/*
 * Lower 64 bits of GID for port1. There are (2 * NUM_VHCA + 1) 67 GIDs per
 * physical IB port.
 */
struct psif_csr_rcv_gid_lower {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_rcv_gid_lower [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_GID_FORWARDING_TABLE */
/*
 * GID forwarding table. The forwarding table is used to figure out if a
 * packet should be sent in loopback or not. There are (2 * NUM_VHCA + 1) 67
 * GIDs per physical IB port.
 */
struct psif_csr_ibpr_gid_forwarding_table {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_gid_forwarding_table [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_EOIB_MAC1 */
/* Per vHCA + EPS-C ethernet MAC address register. */
struct psif_csr_ibpr_eoib_mac1 {
	/* *** 64 bit group 0 start *** */
	u64	mac1:48; /* 48 bits @ offs 0:0 */
	u64	valid:1; /* 1 bits @ offs 0:48 */
	u64	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_mac1 [64 bits] */

/* CSR automated type for TSU_IBPR_P{1,2}_EOIB_MAC2 */
/* Per vHCA + EPS-C ethernet MAC address register. */
struct psif_csr_ibpr_eoib_mac2 {
	/* *** 64 bit group 0 start *** */
	u64	mac2:48; /* 48 bits @ offs 0:0 */
	u64	valid:1; /* 1 bits @ offs 0:48 */
	u64	:15; /* 15 bits @ offs 0:49 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_mac2 [64 bits] */

struct psif_eoib_control {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:61; /* 61 bits @ offs 0:0 */
	/*
	 * Unicast Promiscuous Mode. This bit enables reception of unicast packets
	 * independent of the port's MAC address
	 */
	u64	upm:1; /* 1 bits @ offs 0:61 */
	/*
	 * Multicast Promiscuous Mode. This enables reception of multicast packets,
	 * independent of the content of the shared EoIB_Multicast_table.
	 */
	u64	mpm:1; /* 1 bits @ offs 0:62 */
	/*
	 * Accept BroadCast packets. This bit control the reception of broadcast
	 * packet.
	 */
	u64	abc:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_eoib_control [64 bits] */

/* CSR automated type for TSU_IBPR_EOIB_CONTROL */
/* Per vHCA + EPS-C ethernet control register. */
struct psif_csr_ibpr_eoib_control {
	/* *** 64 bit group 0 start *** */
	/*
	 * Unicast Promiscuous Mode. This bit enables reception of unicast packets
	 * independent of the port's MAC address
	 */
	u64	upm:1; /* 1 bits @ offs 0:0 */
	/*
	 * Multicast Promiscuous Mode. This enables reception of multicast packets,
	 * independent of the content of the shared EoIB_Multicast_table.
	 */
	u64	mpm:1; /* 1 bits @ offs 0:1 */
	/*
	 * Accept BroadCast packets. This bit control the reception of broadcast
	 * packet.
	 */
	u64	abc:1; /* 1 bits @ offs 0:2 */
	/* Inlined data : struct psif_eoib_control (64 bits) */ /* 64 bits @ offs 0:3 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_control [64 bits] */

/* CSR automated type for TSU_IBPR_DMAC_SEED */
/* Per vHCA + EPS-C DMAC seed register. */
struct psif_csr_ibpr_dmac_seed {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_dmac_seed [64 bits] */

/* CSR automated type for TSU_IBPR_EOIB_VLAN_ETHERTYPES */
/* Per vHCA + EPS-C VLAN EtherTypes register. */
struct psif_csr_ibpr_eoib_vlan_ethertypes {
	/* *** 64 bit group 0 start *** */
	u16	inner_vlan_ether_type; /* 16 bits @ offs 0:0 */
	u16	outer_vlan_ether_type; /* 16 bits @ offs 0:16 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_vlan_ethertypes [64 bits] */

struct psif_eoib_pf_control {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:59; /* 59 bits @ offs 0:0 */
	/*
	 * Unicast OverFlow table Enable. Setting this bit enables a UF to extend the
	 * unicast MAC address space the UF will respond to. Setting this bit enables
	 * false positives.
	 */
	u64	uofe:1; /* 1 bits @ offs 0:59 */
	/*
	 * Receive Tossed Packets. Debug mode. Setting this bit will enable the UF to
	 * receive a packet that otherwise would have been tossed. The completion
	 * will contain information that the packet is considered incorrect by PSIF.
	 */
	u64	rtp:1; /* 1 bits @ offs 0:60 */
	/*
	 * Double VLAN Mode. Setting this bit will require all packets sent/received
	 * to contain an outer VLAN tag.
	 */
	u64	dvm:1; /* 1 bits @ offs 0:61 */
	/*
	 * VLAN Enforcement Mode. Setting this bit will enforce VLAN tag checking for
	 * the UF.
	 */
	u64	vem:1; /* 1 bits @ offs 0:62 */
	/*
	 * No Strip Mode. Setting this bit will keep the VLAN tag in VLAN Enforcement
	 * Mode. This bit is for debugging purposes only.
	 */
	u64	nsm:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_eoib_pf_control [64 bits] */

/* CSR automated type for TSU_IBPR_EOIB_PF_CONTROL */
/* Per vHCA PF control register. */
struct psif_csr_ibpr_eoib_pf_control {
	/* *** 64 bit group 0 start *** */
	/*
	 * Unicast OverFlow table Enable. Setting this bit enables a UF to extend the
	 * unicast MAC address space the UF will respond to. Setting this bit enables
	 * false positives.
	 */
	u64	uofe:1; /* 1 bits @ offs 0:0 */
	/*
	 * Receive Tossed Packets. Debug mode. Setting this bit will enable the UF to
	 * receive a packet that otherwise would have been tossed. The completion
	 * will contain information that the packet is considered incorrect by PSIF.
	 */
	u64	rtp:1; /* 1 bits @ offs 0:1 */
	/*
	 * Double VLAN Mode. Setting this bit will require all packets sent/received
	 * to contain an outer VLAN tag.
	 */
	u64	dvm:1; /* 1 bits @ offs 0:2 */
	/*
	 * VLAN Enforcement Mode. Setting this bit will enforce VLAN tag checking for
	 * the UF.
	 */
	u64	vem:1; /* 1 bits @ offs 0:3 */
	/*
	 * No Strip Mode. Setting this bit will keep the VLAN tag in VLAN Enforcement
	 * Mode. This bit is for debugging purposes only.
	 */
	u64	nsm:1; /* 1 bits @ offs 0:4 */
	/* Inlined data : struct psif_eoib_pf_control (64 bits) */ /* 64 bits @ offs 0:5 */
	u64	:59; /* 59 bits @ offs 0:5 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_pf_control [64 bits] */

/* CSR automated type for TSU_IBPR_EOIB_UNICAST_OVERFLOW_TABLE */
/* Common unicast overflow table for all vHCAs. */
struct psif_csr_ibpr_eoib_unicast_overflow_table {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_unicast_overflow_table [64 bits] */

/* CSR automated type for TSU_IBPR_EOIB_MULTICAST_TABLE */
/* Common multicast table for all VHCAs. */
struct psif_csr_ibpr_eoib_multicast_table {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_multicast_table [64 bits] */

/* CSR automated type for TSU_IBPR_HDR_SPLIT_EOIB */
/*
 * Header split register indicating what EoIB headers to try splitting at.
 */
struct psif_csr_ibpr_hdr_split_eoib {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_header_split_control */
		u64	data:3;
	#else /* !__arm__ */
		enum psif_header_split_control	data:3;
	#endif	 /* 3 bits @ offs 0:0 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_hdr_split_eoib [64 bits] */

/* CSR automated type for TSU_IBPR_HDR_SPLIT_IPOIB_UD */
/*
 * Header split register indicating what IPoIB headers to try splitting at
 * for UD transport.
 */
struct psif_csr_ibpr_hdr_split_ipoib_ud {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_header_split_control */
		u64	data:3;
	#else /* !__arm__ */
		enum psif_header_split_control	data:3;
	#endif	 /* 3 bits @ offs 0:0 */
	u64	:61; /* 61 bits @ offs 0:3 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_hdr_split_ipoib_ud [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_BUFFER_SETUP */
/* Trace buffer setup */
struct psif_csr_ibpr_trace_buffer_setup {
	/* *** 64 bit group 0 start *** */
	u64	no_flits_per_packet:10; /* 10 bits @ offs 0:0 */
	#if defined(__arm__) /* enum psif_trace_buffer_mode */
		u64	buffer_mode:1;
	#else /* !__arm__ */
		enum psif_trace_buffer_mode	buffer_mode:1;
	#endif	 /* 1 bits @ offs 0:10 */
	#if defined(__arm__) /* enum psif_trace_buffer_allocation */
		u64	buffer_allocation:2;
	#else /* !__arm__ */
		enum psif_trace_buffer_allocation	buffer_allocation:2;
	#endif	 /* 2 bits @ offs 0:11 */
	#if defined(__arm__) /* enum psif_trace_sample_source */
		u64	sample_source:2;
	#else /* !__arm__ */
		enum psif_trace_sample_source	sample_source:2;
	#endif	 /* 2 bits @ offs 0:13 */
	u64	:49; /* 49 bits @ offs 0:15 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_buffer_setup [64 bits] */

struct psif_trace_store_qualifier1 {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:22; /* 22 bits @ offs 0:0 */
	/* slid */
	u64	slid:16; /* 16 bits @ offs 0:22 */
	/* dlid */
	u64	dlid:16; /* 16 bits @ offs 0:38 */
	/* lnh */
	u64	lnh:2; /* 2 bits @ offs 0:54 */
	/* sl */
	u64	sl:4; /* 4 bits @ offs 0:56 */
	/* vl */
	u64	vl:4; /* 4 bits @ offs 0:60 */
} PSIF_PACKED_ALIGNED; /* struct psif_trace_store_qualifier1 [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_STORE_QUALIFIER1 */
/* Trace buffer Store qualifier1 */
struct psif_csr_ibpr_trace_store_qualifier1 {
	/* *** 64 bit group 0 start *** */
	/* slid */
	u16	slid; /* 16 bits @ offs 0:0 */
	/* dlid */
	u16	dlid; /* 16 bits @ offs 0:16 */
	/* lnh */
	u32	lnh:2; /* 2 bits @ offs 0:32 */
	/* sl */
	u32	sl:4; /* 4 bits @ offs 0:34 */
	/* vl */
	u32	vl:4; /* 4 bits @ offs 0:38 */
	/* Inlined data : struct psif_trace_store_qualifier1 (64 bits) */ /* 64 bits @ offs 0:42 */
	u32	:22; /* 22 bits @ offs 0:42 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_store_qualifier1 [64 bits] */

struct psif_trace_store_qualifier2 {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:3; /* 3 bits @ offs 0:0 */
	/* Status error */
	u64	status_error:1; /* 1 bits @ offs 0:3 */
	/* universal function */
	u64	uf:6; /* 6 bits @ offs 0:4 */
	/* Partition Key */
	u64	pkey:16; /* 16 bits @ offs 0:10 */
	/* Destination queue pair */
	u64	destqp:24; /* 24 bits @ offs 0:26 */
	/* Transport Header version */
	u64	tver:4; /* 4 bits @ offs 0:50 */
	/* Migration request */
	u64	m:1; /* 1 bits @ offs 0:54 */
	/* Solicited event */
	u64	se:1; /* 1 bits @ offs 0:55 */
	/* opcode */
	u64	opcode:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_trace_store_qualifier2 [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_STORE_QUALIFIER2 */
/* Trace buffer Store qualifier2 */
struct psif_csr_ibpr_trace_store_qualifier2 {
	/* *** 64 bit group 0 start *** */
	/* Status error */
	u64	status_error:1; /* 1 bits @ offs 0:0 */
	/* universal function */
	u64	uf:6; /* 6 bits @ offs 0:1 */
	/* Partition Key */
	u64	pkey:16; /* 16 bits @ offs 0:7 */
	/* Destination queue pair */
	u64	destqp:24; /* 24 bits @ offs 0:23 */
	/* Transport Header version */
	u64	tver:4; /* 4 bits @ offs 0:47 */
	/* Migration request */
	u64	m:1; /* 1 bits @ offs 0:51 */
	/* Solicited event */
	u64	se:1; /* 1 bits @ offs 0:52 */
	/* opcode */
	u64	opcode:8; /* 8 bits @ offs 0:53 */
	/* Inlined data : struct psif_trace_store_qualifier2 (64 bits) */ /* 64 bits @ offs 0:61 */
	u64	:3; /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_store_qualifier2 [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_STORE_QUALIFIER1_MASK */
/* Trace buffer Store qualifier1 mask */
struct psif_csr_ibpr_trace_store_qualifier1_mask {
	/* *** 64 bit group 0 start *** */
	/* slid */
	u16	slid; /* 16 bits @ offs 0:0 */
	/* dlid */
	u16	dlid; /* 16 bits @ offs 0:16 */
	/* lnh */
	u32	lnh:2; /* 2 bits @ offs 0:32 */
	/* sl */
	u32	sl:4; /* 4 bits @ offs 0:34 */
	/* vl */
	u32	vl:4; /* 4 bits @ offs 0:38 */
	/* Inlined data : struct psif_trace_store_qualifier1 (64 bits) */ /* 64 bits @ offs 0:42 */
	u32	:22; /* 22 bits @ offs 0:42 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_store_qualifier1_mask [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_STORE_QUALIFIER2_MASK */
/* Trace buffer Store qualifier2 mask */
struct psif_csr_ibpr_trace_store_qualifier2_mask {
	/* *** 64 bit group 0 start *** */
	/* Status error */
	u64	status_error:1; /* 1 bits @ offs 0:0 */
	/* universal function */
	u64	uf:6; /* 6 bits @ offs 0:1 */
	/* Partition Key */
	u64	pkey:16; /* 16 bits @ offs 0:7 */
	/* Destination queue pair */
	u64	destqp:24; /* 24 bits @ offs 0:23 */
	/* Transport Header version */
	u64	tver:4; /* 4 bits @ offs 0:47 */
	/* Migration request */
	u64	m:1; /* 1 bits @ offs 0:51 */
	/* Solicited event */
	u64	se:1; /* 1 bits @ offs 0:52 */
	/* opcode */
	u64	opcode:8; /* 8 bits @ offs 0:53 */
	/* Inlined data : struct psif_trace_store_qualifier2 (64 bits) */ /* 64 bits @ offs 0:61 */
	u64	:3; /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_store_qualifier2_mask [64 bits] */

struct psif_trace_trigger1 {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:7; /* 7 bits @ offs 0:0 */
	/* psn */
	u64	psn:24; /* 24 bits @ offs 0:7 */
	/* slid */
	u64	slid:16; /* 16 bits @ offs 0:31 */
	/* dlid_path */
	u64	dlid_path:7; /* 7 bits @ offs 0:47 */
	/* lnh */
	u64	lnh:2; /* 2 bits @ offs 0:54 */
	/* sl */
	u64	sl:4; /* 4 bits @ offs 0:56 */
	/* vl */
	u64	vl:4; /* 4 bits @ offs 0:60 */
} PSIF_PACKED_ALIGNED; /* struct psif_trace_trigger1 [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_TRIGGER1 */
/* Trace buffer trigger1 */
struct psif_csr_ibpr_trace_trigger1 {
	/* *** 64 bit group 0 start *** */
	/* psn */
	u64	psn:24; /* 24 bits @ offs 0:0 */
	/* slid */
	u64	slid:16; /* 16 bits @ offs 0:24 */
	/* dlid_path */
	u64	dlid_path:7; /* 7 bits @ offs 0:40 */
	/* lnh */
	u64	lnh:2; /* 2 bits @ offs 0:47 */
	/* sl */
	u64	sl:4; /* 4 bits @ offs 0:49 */
	/* vl */
	u64	vl:4; /* 4 bits @ offs 0:53 */
	/* Inlined data : struct psif_trace_trigger1 (64 bits) */ /* 64 bits @ offs 0:57 */
	u64	:7; /* 7 bits @ offs 0:57 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_trigger1 [64 bits] */

struct psif_trace_trigger2 {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:3; /* 3 bits @ offs 0:0 */
	/* Status error */
	u64	status_error:1; /* 1 bits @ offs 0:3 */
	/* universal function */
	u64	uf:6; /* 6 bits @ offs 0:4 */
	/* Partition Key */
	u64	pkey:16; /* 16 bits @ offs 0:10 */
	/* Destination queue pair */
	u64	destqp:24; /* 24 bits @ offs 0:26 */
	/* Transport Header version */
	u64	tver:4; /* 4 bits @ offs 0:50 */
	/* Migration request */
	u64	m:1; /* 1 bits @ offs 0:54 */
	/* Solicited event */
	u64	se:1; /* 1 bits @ offs 0:55 */
	/* opcode */
	u64	opcode:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_trace_trigger2 [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_TRIGGER2 */
/* Trace buffer trigger2 */
struct psif_csr_ibpr_trace_trigger2 {
	/* *** 64 bit group 0 start *** */
	/* Status error */
	u64	status_error:1; /* 1 bits @ offs 0:0 */
	/* universal function */
	u64	uf:6; /* 6 bits @ offs 0:1 */
	/* Partition Key */
	u64	pkey:16; /* 16 bits @ offs 0:7 */
	/* Destination queue pair */
	u64	destqp:24; /* 24 bits @ offs 0:23 */
	/* Transport Header version */
	u64	tver:4; /* 4 bits @ offs 0:47 */
	/* Migration request */
	u64	m:1; /* 1 bits @ offs 0:51 */
	/* Solicited event */
	u64	se:1; /* 1 bits @ offs 0:52 */
	/* opcode */
	u64	opcode:8; /* 8 bits @ offs 0:53 */
	/* Inlined data : struct psif_trace_trigger2 (64 bits) */ /* 64 bits @ offs 0:61 */
	u64	:3; /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_trigger2 [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_TRIGGER1_MASK */
/* Trace buffer trigger1 mask */
struct psif_csr_ibpr_trace_trigger1_mask {
	/* *** 64 bit group 0 start *** */
	/* psn */
	u64	psn:24; /* 24 bits @ offs 0:0 */
	/* slid */
	u64	slid:16; /* 16 bits @ offs 0:24 */
	/* dlid_path */
	u64	dlid_path:7; /* 7 bits @ offs 0:40 */
	/* lnh */
	u64	lnh:2; /* 2 bits @ offs 0:47 */
	/* sl */
	u64	sl:4; /* 4 bits @ offs 0:49 */
	/* vl */
	u64	vl:4; /* 4 bits @ offs 0:53 */
	/* Inlined data : struct psif_trace_trigger1 (64 bits) */ /* 64 bits @ offs 0:57 */
	u64	:7; /* 7 bits @ offs 0:57 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_trigger1_mask [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_TRIGGER2_MASK */
/* Trace buffer trigger2 mask */
struct psif_csr_ibpr_trace_trigger2_mask {
	/* *** 64 bit group 0 start *** */
	/* Status error */
	u64	status_error:1; /* 1 bits @ offs 0:0 */
	/* universal function */
	u64	uf:6; /* 6 bits @ offs 0:1 */
	/* Partition Key */
	u64	pkey:16; /* 16 bits @ offs 0:7 */
	/* Destination queue pair */
	u64	destqp:24; /* 24 bits @ offs 0:23 */
	/* Transport Header version */
	u64	tver:4; /* 4 bits @ offs 0:47 */
	/* Migration request */
	u64	m:1; /* 1 bits @ offs 0:51 */
	/* Solicited event */
	u64	se:1; /* 1 bits @ offs 0:52 */
	/* opcode */
	u64	opcode:8; /* 8 bits @ offs 0:53 */
	/* Inlined data : struct psif_trace_trigger2 (64 bits) */ /* 64 bits @ offs 0:61 */
	u64	:3; /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_trigger2_mask [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_START */
/* Start trace buffer */
struct psif_csr_ibpr_trace_start {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_start [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_STOP */
/* Stop trace buffer */
struct psif_csr_ibpr_trace_stop {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_stop [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_BUFFER_STATUS */
/* Trace buffer status */
struct psif_csr_ibpr_trace_buffer_status {
	/* *** 64 bit group 0 start *** */
	u64	trigger_address:15; /* 15 bits @ offs 0:0 */
	#if defined(__arm__) /* enum psif_trace_buffer_status */
		u64	status:2;
	#else /* !__arm__ */
		enum psif_trace_buffer_status	status:2;
	#endif	 /* 2 bits @ offs 0:15 */
	u64	:47; /* 47 bits @ offs 0:17 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_buffer_status [64 bits] */

/* CSR automated type for TSU_IBPR_EOIB_VID_TABLE */
/*
 * Per vHCA + EPS-C VID table. There are 64 entries per UF. 4096b * 34 (64x34
 * entries).
 */
struct psif_csr_ibpr_eoib_vid_table {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_eoib_vid_table [64 bits] */

/* CSR automated type for TSU_IBPR_TRACE_BUFFER */
/* Trace buffer */
struct psif_csr_ibpr_trace_buffer {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibpr_trace_buffer [64 bits] */

/* CSR automated type for TSU_SQS_SQS_LIST_TABLE */
/*
 * SQS list table is used to program the list number to associate with UF.
 * Address is list number and data is UF. A single UF can allocate multiple
 * lists.
 */
struct psif_csr_sqs_sqs_list_table {
	/* *** 64 bit group 0 start *** */
	u64	data:6; /* 6 bits @ offs 0:0 */
	u64	:58; /* 58 bits @ offs 0:6 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_sqs_list_table [64 bits] */

/* CSR automated type for TSU_SQS_UF_CONTROL */
/*
 * This register must be set and the kick register is written in order to
 * start the operation.
 */
struct psif_csr_sqs_uf_control {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	command:1; /* 1 bits @ offs 0:6 */
	u64	:57; /* 57 bits @ offs 0:7 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_uf_control [64 bits] */

/* CSR automated type for TSU_SQS_UF_CONTROL_KICK */
/* Starts operation defined in uf_control. */
struct psif_csr_sqs_uf_control_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_uf_control_kick [64 bits] */

/* CSR automated type for TSU_SQS_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_sqs_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_int_status [64 bits] */

/* CSR automated type for TSU_SQS_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_sqs_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_int_mask [64 bits] */

/* CSR automated type for TSU_SQS_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_sqs_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_int_pri [64 bits] */

/* CSR automated type for TSU_SQS_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_sqs_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_int_status_clear [64 bits] */

/* CSR automated type for TSU_SQS_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_sqs_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_SQS_SQS_LIST_STATUS0 */
/* Address: SQS list number. Flush status. */
struct psif_csr_sqs_sqs_list_status0 {
	/* *** 64 bit group 0 start *** */
	u32	current_pointer:24; /* 24 bits @ offs 0:0 */
	u32	:8; /* 8 bits @ offs 0:24 */
	u32	previous_pointer:24; /* 24 bits @ offs 0:32 */
	u32	:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_sqs_list_status0 [64 bits] */

/* CSR automated type for TSU_SQS_SQS_LIST_STATUS1 */
/*
 * Address: SQS list number. Set when the PCIe response has error on the
 * descriptor read.
 */
struct psif_csr_sqs_sqs_list_status1 {
	/* *** 64 bit group 0 start *** */
	u32	tail_pointer:24; /* 24 bits @ offs 0:0 */
	u32	:8; /* 8 bits @ offs 0:24 */
	u32	active:1; /* 1 bits @ offs 0:32 */
	u32	:31; /* 31 bits @ offs 0:33 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_sqs_list_status1 [64 bits] */

/* CSR automated type for TSU_SQS_HASH_CTRL */
/*
 * Hash mask and shift control. XOR width is based on the log 2 of number of
 * list for that UF.
 */
struct psif_csr_sqs_hash_ctrl {
	/* *** 64 bit group 0 start *** */
	u32	mask:24; /* 24 bits @ offs 0:0 */
	u32	:8; /* 8 bits @ offs 0:24 */
	u32	shift:6; /* 6 bits @ offs 0:32 */
	u32	:26; /* 26 bits @ offs 0:38 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_hash_ctrl [64 bits] */

/* CSR automated type for TSU_SQS_ATOMIC_DISABLE */
/*
 * Disble Atomic cmp and swap for the QP next pointer null check. If set,
 * hardware generates read-then-write to update the QP next pointer.
 */
struct psif_csr_sqs_atomic_disable {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_atomic_disable [64 bits] */

/* CSR automated type for TSU_SQS_SQ_BURST_READ_SIZE */
/* Number of burst read for the send queue element per QP. */
struct psif_csr_sqs_sq_burst_read_size {
	/* *** 64 bit group 0 start *** */
	u64	data:8; /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_sq_burst_read_size [64 bits] */

/* CSR automated type for TSU_SQS_CBU_DB_CNT */
/* Number of DB count from CBU. */
struct psif_csr_sqs_cbu_db_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_cbu_db_cnt [64 bits] */

/* CSR automated type for TSU_SQS_ERR_DB_CNT */
/* Number of DB count from ERR. */
struct psif_csr_sqs_err_db_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_err_db_cnt [64 bits] */

/* CSR automated type for TSU_SQS_LLQ_PUSH_CNT */
/* Number of LLQ push. */
struct psif_csr_sqs_llq_push_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_llq_push_cnt [64 bits] */

/* CSR automated type for TSU_SQS_LLQ_POP_CNT */
/* Number of LLQ pop. */
struct psif_csr_sqs_llq_pop_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_llq_pop_cnt [64 bits] */

/* CSR automated type for TSU_SQS_LLQ_PEEK_CNT */
/* Number of LLQ peek. */
struct psif_csr_sqs_llq_peek_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_llq_peek_cnt [64 bits] */

/* CSR automated type for TSU_SQS_SQ_RD_CNT */
/* Number of Send Queue read. */
struct psif_csr_sqs_sq_rd_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_sq_rd_cnt [64 bits] */

/* CSR automated type for TSU_SQS_DSCR_REQ_CNT */
/* Number of Descriptor read. */
struct psif_csr_sqs_dscr_req_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_dscr_req_cnt [64 bits] */

/* CSR automated type for TSU_SQS_DSCR_RSP_CNT */
/* Number of Descriptor read response. */
struct psif_csr_sqs_dscr_rsp_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_dscr_rsp_cnt [64 bits] */

/* CSR automated type for TSU_SQS_ATM_REQ_CNT */
/* Number of Atomic request. */
struct psif_csr_sqs_atm_req_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_atm_req_cnt [64 bits] */

/* CSR automated type for TSU_SQS_ATM_RSP_CNT */
/* Number of Atomic response. */
struct psif_csr_sqs_atm_rsp_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_atm_rsp_cnt [64 bits] */

/* CSR automated type for TSU_SQS_PUSH_SQS_LIST_CNT */
/* Number of QP insert to the SQS list. */
struct psif_csr_sqs_push_sqs_list_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_push_sqs_list_cnt [64 bits] */

/* CSR automated type for TSU_SQS_RING_TIMER */
/* Number of clock to wait before writting to the ring. */
struct psif_csr_sqs_ring_timer {
	/* *** 64 bit group 0 start *** */
	u16	data; /* 16 bits @ offs 0:0 */
	u64	:48; /* 48 bits @ offs 0:16 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_ring_timer [64 bits] */

/* CSR automated type for TSU_SQS_PADDED_SQ_DSCR_HW */
/* Set to write 64B for the send queue hardware descriptor. */
struct psif_csr_sqs_padded_sq_dscr_hw {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_padded_sq_dscr_hw [64 bits] */

/* CSR automated type for TSU_SQS_PADDED_RING_BUFFER */
/* Set to write 64B for the PIO ring buffer. */
struct psif_csr_sqs_padded_ring_buffer {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_padded_ring_buffer [64 bits] */

/* CSR automated type for TSU_SQS_ECC_ERR_CTRL */
/* ECC error control */
struct psif_csr_sqs_ecc_err_ctrl {
	/* *** 64 bit group 0 start *** */
	u64	mask_fatal_interrupt:1; /* 1 bits @ offs 0:0 */
	u64	uncorrectable_err_stop:1; /* 1 bits @ offs 0:1 */
	u64	:62; /* 62 bits @ offs 0:2 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_ecc_err_ctrl [64 bits] */

/* CSR automated type for TSU_SQS_ECC_ERR_STATUS */
/* ECC status */
struct psif_csr_sqs_ecc_err_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_ecc_err_status [64 bits] */

/* CSR automated type for TSU_SQS_ECC_ERR_STATUS_CLEAR */
/* ECC status */
struct psif_csr_sqs_ecc_err_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_ecc_err_status_clear [64 bits] */

/* CSR automated type for TSU_SQS_PIO_RING_BUFFER_WR_PTR */
/* Read/Write for the PIO ring buffer write pointer */
struct psif_csr_sqs_pio_ring_buffer_wr_ptr {
	/* *** 64 bit group 0 start *** */
	u64	data:40; /* 40 bits @ offs 0:0 */
	u64	:24; /* 24 bits @ offs 0:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_pio_ring_buffer_wr_ptr [64 bits] */

/* CSR automated type for TSU_SQS_SQS_LIST_ERR_STATUS */
/*
 * Address: SQS list number. Set when the PCIe response has error on the
 * descriptor read.
 */
struct psif_csr_sqs_sqs_list_err_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_sqs_list_err_status [64 bits] */

/* CSR automated type for TSU_SQS_PIO_RING_BUFFER_RD_PTR */
/* Read/Write for the PIO ring buffer read pointer */
struct psif_csr_sqs_pio_ring_buffer_rd_ptr {
	/* *** 64 bit group 0 start *** */
	u64	data:40; /* 40 bits @ offs 0:0 */
	u64	:24; /* 24 bits @ offs 0:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_pio_ring_buffer_rd_ptr [64 bits] */

/* CSR automated type for TSU_SQS_PIO_RING_BUFFER_PENDING_CNT */
/* Read/Write for the PIO ring buffer pending count */
struct psif_csr_sqs_pio_ring_buffer_pending_cnt {
	/* *** 64 bit group 0 start *** */
	u64	data:41; /* 41 bits @ offs 0:0 */
	u64	:23; /* 23 bits @ offs 0:41 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_sqs_pio_ring_buffer_pending_cnt [64 bits] */

/* CSR automated type for TSU_ERR_INT_STATUS */
/* Interrupt status register. 1b per source (1 = int triggered). */
struct psif_csr_err_int_status {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_int_status [64 bits] */

/* CSR automated type for TSU_ERR_INT_MASK */
/* Interrupt mask register. 1b per source (1 = masked). */
struct psif_csr_err_int_mask {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_int_mask [64 bits] */

/* CSR automated type for TSU_ERR_INT_PRI */
/* Interrupt priority register. 1b per source (1 = high 0 = low). */
struct psif_csr_err_int_pri {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_int_pri [64 bits] */

/* CSR automated type for TSU_ERR_INT_STATUS_CLEAR */
/*
 * Interrupt status clear register. 1b per source (1=source will be cleared
 * from int_status register when kick is called).
 */
struct psif_csr_err_int_status_clear {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_int_status_clear [64 bits] */

/* CSR automated type for TSU_ERR_INT_STATUS_CLEAR_KICK */
/* Trigger the int_status clear operation. */
struct psif_csr_err_int_status_clear_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_int_status_clear_kick [64 bits] */

/* CSR automated type for TSU_ERR_ASYNC_EVENT_STATUS */
/* Async event FIFO - status portion. */
struct psif_csr_err_async_event_status {
	/* *** 64 bit group 0 start *** */
	u32	:21; /* 21 bits @ offs 0:0 */
	/*
	 * Valid bit for this event entry. It is here as a help for SW/FW. If this
	 * register is read, and this bit is not set, the FIFO this register is fed
	 * from is empty.
	 */
	u32	valid:1; /* 1 bits @ offs 0:21 */
	/* Type of event. */
	#if defined(__arm__) /* enum psif_event_type */
		u32	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:22 */
	/* UF - valid for affiliated events. */
	u32	uf:6; /* 6 bits @ offs 0:26 */
	#if defined(__arm__) /* enum psif_event_status */
		u32	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:32 */
	/* QP number - valid for affiliated events. */
	u32	qp:24; /* 24 bits @ offs 0:40 */
	/* *** 64 bit group 1 start *** */
	/* Async event data. */
	/* Inlined data : struct psif_async_eq_entry_status_fifo (64 bits) */ /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/* Inlined data : struct psif_async_eq_entry_status (64 bits) */ /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_async_event_status [64 bits] */

/* CSR automated type for TSU_ERR_ASYNC_EVENT_AFFILIATED */
/* Async event FIFO - affiliated data portion. */
struct psif_csr_err_async_event_affiliated {
	/* *** 64 bit group 0 start *** */
	u64	:23; /* 23 bits @ offs 0:0 */
	/* IB port number */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 0:23 */
	/* LID. */
	u64	lid:16; /* 16 bits @ offs 0:24 */
	/* Descriptor union. */
	/* Actual data type: union eq_dscr_union */
	u64	dscr_union:24; /* 24 bits @ offs 0:40 */
	/* *** 64 bit group 1 start *** */
	/* Inlined data : struct psif_async_eq_entry_affiliated (64 bits) */ /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_async_event_affiliated [64 bits] */

/* CSR automated type for TSU_ERR_ASYNC_EVENT_POP */
/* This pop register is written after async event register is read. */
struct psif_csr_err_async_event_pop {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_async_event_pop [64 bits] */

/* CSR automated type for TSU_ERR_HOST_ERROR_TYPE */
/* Error type the host_counter is counting. */
struct psif_csr_err_host_error_type {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_tsu_error_types */
		u64	data:8;
	#else /* !__arm__ */
		enum psif_tsu_error_types	data:8;
	#endif	 /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_host_error_type [64 bits] */

/* CSR automated type for TSU_ERR_HOST_COUNTER */
/*
 * Counts how many times error type defined in host_error_type register is
 * received by tsu_err. Sticky at max value and then needs to be cleared.
 */
struct psif_csr_err_host_counter {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_host_counter [64 bits] */

/* CSR automated type for TSU_ERR_CLEAR_HOST_COUNTER */
/* Clears host_counter. */
struct psif_csr_err_clear_host_counter {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_clear_host_counter [64 bits] */

/* CSR automated type for TSU_ERR_CMPL_ERROR_TYPE */
/* Error type the cmpl_counter is counting. */
struct psif_csr_err_cmpl_error_type {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_tsu_error_types */
		u64	data:8;
	#else /* !__arm__ */
		enum psif_tsu_error_types	data:8;
	#endif	 /* 8 bits @ offs 0:0 */
	u64	:56; /* 56 bits @ offs 0:8 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_cmpl_error_type [64 bits] */

/* CSR automated type for TSU_ERR_CMPL_COUNTER */
/*
 * Counts how many times error type defined in cmpl_error_type register is
 * received by tsu_err. Sticky at max value and then needs to be cleared.
 */
struct psif_csr_err_cmpl_counter {
	/* *** 64 bit group 0 start *** */
	u32	data; /* 32 bits @ offs 0:0 */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_cmpl_counter [64 bits] */

/* CSR automated type for TSU_ERR_CLEAR_CMPL_COUNTER */
/* Clears. */
struct psif_csr_err_clear_cmpl_counter {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_clear_cmpl_counter [64 bits] */

/* CSR automated type for TSU_ERR_CLEAR_DIAG_RAM */
/* Clears the diag RAM for the UF specified. */
struct psif_csr_err_clear_diag_ram {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	data:6; /* 6 bits @ offs 0:0 */
	u64	:58; /* 58 bits @ offs 0:6 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_clear_diag_ram [64 bits] */

/* CSR automated type for TSU_ERR_CLEAR_DIAG_RAM_KICK */
/* Clears the diag RAM - per UF. */
struct psif_csr_err_clear_diag_ram_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_clear_diag_ram_kick [64 bits] */

/* CSR automated type for TSU_ERR_DIAG_RAM_ADDR */
/* Read the address for the UF. */
struct psif_csr_err_diag_ram_addr {
	/* *** 64 bit group 0 start *** */
	u64	data:4; /* 4 bits @ offs 0:0 */
	u64	:60; /* 60 bits @ offs 0:4 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_diag_ram_addr [64 bits] */

/* CSR automated type for TSU_ERR_DIAG_RAM_READ_ADDR */
/* Set up which RAM entry to read. */
struct psif_csr_err_diag_ram_read_addr {
	/* *** 64 bit group 0 start *** */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:0 */
	u64	addr:4; /* 4 bits @ offs 0:6 */
	u64	:54; /* 54 bits @ offs 0:10 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_diag_ram_read_addr [64 bits] */

/* CSR automated type for TSU_ERR_DIAG_RAM_READ_KICK */
/*
 * Kick - reads the data from the RAM entry specified in diag_ram_read_addr
 * and adds it to registers which can be read.
 */
struct psif_csr_err_diag_ram_read_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_diag_ram_read_kick [64 bits] */

/* CSR automated type for TSU_ERR_FENCE_TIME_TO_WAIT */
/* Time to wait before starting send queue mode. */
struct psif_csr_err_fence_time_to_wait {
	/* *** 64 bit group 0 start *** */
	/* time(48[0] bits)Time stamp type. Used to track time in TSU. */
	u64	data:48; /* 48 bits @ offs 0:0 */
	u64	:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_fence_time_to_wait [64 bits] */

/* CSR automated type for TSU_ERR_DIAG_RAM_DATA */
/* Data from the diagnostic RAM. */
struct psif_csr_err_diag_ram_data {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_diag_ram_data [64 bits] */

/*
 * Error counter bitmask used for clearing error counters in tsu_err. The
 * description indicates what the counters are counting.
 */
struct psif_err_counter_bit_mask {
	/* *** 64 bit group 0 start *** */
	/*
	 * The number of UD packets silently discarded on the receive queue due to
	 * lack of receive descriptor.
	 */
	u16	rq_num_udsdprd:1; /* 1 bits @ offs 0:0 */
	/*
	 * The number of UC packets silently discarded on the receive queue due to
	 * lack of receive descriptor.
	 */
	u16	rq_num_ucsdprd:1; /* 1 bits @ offs 0:1 */
	/* Responder - number of local access errors. */
	u16	rq_num_lae:1; /* 1 bits @ offs 0:2 */
	/* Responder - number of local protection errors. */
	u16	rq_num_lpe:1; /* 1 bits @ offs 0:3 */
	/*
	 * Requester - number of remote invalid request errors NAK-Invalid Request
	 * on: 1. Unsupported OpCode: Responder detected an unsupported OpCode. 2.
	 * Unexpected OpCode: Responder detected an error in the sequence of OpCodes,
	 * such as a missing Last packet.
	 */
	u16	sq_num_rire:1; /* 1 bits @ offs 0:4 */
	/*
	 * Responder - number of remote invalid request errors. NAK may or may not be
	 * sent. 1. QP Async Affiliated Error: Unsupported or Reserved OpCode (RC,RD
	 * only): Inbound request OpCode was either reserved, or was for a function
	 * not supported by thisQP. (E.g. RDMA or ATOMIC on QP not set up for this).
	 * 2. Misaligned ATOMIC: VA does not point to an aligned address on an atomic
	 * operation. 3. Too many RDMA READ or ATOMIC Requests: There were more
	 * requests received and not ACKed than allowed for the connection. 4. Out of
	 * Sequence OpCode, current packet is First or Only: The Responder detected
	 * an error in the sequence of OpCodes; a missing Last packet. 5. Out of
	 * Sequence OpCode, current packet is not First or Only: The Responder
	 * detected an error in the sequence of OpCodes; a missing First packet. 6.
	 * Local Length Error: Inbound Send request message exceeded the responder's
	 * available buffer space. 7. Length error: RDMA WRITE request message
	 * contained too much or too little pay-load data compared to the DMA length
	 * advertised in the first or only packet. 8. Length error: Payload length
	 * was not consistent with the opcode: a: only is between 0 and PMTU bytes b:
	 * (first or middle) equals PMTU bytes c: last is between 1 byte and PMTU
	 * bytes 9. Length error: Inbound message exceeded the size supported by the
	 * CA port.
	 */
	u16	rq_num_rire:1; /* 1 bits @ offs 0:5 */
	/* Requester - number of bad response errors. */
	u16	sq_num_bre:1; /* 1 bits @ offs 0:6 */
	/* Number of CQ overflows. */
	u16	num_cqovf:1; /* 1 bits @ offs 0:7 */
	/* Requester - number of local length errors. */
	u16	sq_num_lle:1; /* 1 bits @ offs 0:8 */
	/* Responder - number of local length errors. */
	u16	rq_num_lle:1; /* 1 bits @ offs 0:9 */
	/* Requester - number local QP operation error. */
	u16	sq_num_lqpoe:1; /* 1 bits @ offs 0:10 */
	/* Responder - number local QP operation error. */
	u16	rq_num_lqpoe:1; /* 1 bits @ offs 0:11 */
	/* Requester - number of RNR nak retries exceeded errors. */
	u16	sq_num_rree:1; /* 1 bits @ offs 0:12 */
	/* Requester - number of transport retries exceeded errors. */
	u16	sq_num_tree:1; /* 1 bits @ offs 0:13 */
	/* Requester - number of out of sequence Naks received - XXX: look at this... */
	u16	sq_num_oos:1; /* 1 bits @ offs 0:14 */
	/* Responder - number of out of sequence requests received. */
	u16	rq_num_oos:1; /* 1 bits @ offs 0:15 */
	/*
	 * Requester - number of remote access errors. NAK-Remote Access Error on:
	 * R_Key Violation: Responder detected an invalid R_Key while executing an
	 * RDMA Request.
	 */
	u8	sq_num_roe:1; /* 1 bits @ offs 0:16 */
	/*
	 * Responder - number of remote operation errors. NAK-Remote Operation Error
	 * on: 1. Malformed WQE: Responder detected a malformed Receive Queue WQE
	 * while processing the packet. 2. Remote Operation Error: Responder
	 * encountered an error, (local to the responder), which prevented it from
	 * completing the request.
	 */
	u8	rq_num_roe:1; /* 1 bits @ offs 0:17 */
	/*
	 * Requester - number of remote access errors. NAK-Remote Access Error on:
	 * R_Key Violation: Responder detected an invalid R_Key while executing an
	 * RDMA Request.
	 */
	u8	sq_num_rae:1; /* 1 bits @ offs 0:18 */
	/*
	 * Responder - number of remote access errors. R_Key Violation Responder
	 * detected an R_Key violation while executing an RDMA request. NAK may or
	 * may not be sent.
	 */
	u8	rq_num_rae:1; /* 1 bits @ offs 0:19 */
	/* Requester - the number of RNR Naks received. */
	u8	sq_num_rnr:1; /* 1 bits @ offs 0:20 */
	/* Responder - the number of RNR Naks sent. */
	u8	rq_num_rnr:1; /* 1 bits @ offs 0:21 */
	/*
	 * Requester - number of CQEs with error. Incremented each time a CQE with
	 * error is generated.
	 */
	u8	sq_num_wrfe:1; /* 1 bits @ offs 0:22 */
	/*
	 * Responder - number of CQEs with error. Incremented each time a CQE with
	 * error is generated.
	 */
	u8	rq_num_wrfe:1; /* 1 bits @ offs 0:23 */
} PSIF_PACKED; /* struct psif_err_counter_bit_mask [24 bits] */

/* CSR automated type for TSU_ERR_CLEAR_ERROR_COUNTERS */
/* Clear all counters having the bit set in the mask. */
struct psif_csr_err_clear_error_counters {
	/* *** 64 bit group 0 start *** */
	/*
	 * The number of UD packets silently discarded on the receive queue due to
	 * lack of receive descriptor.
	 */
	u16	mask_rq_num_udsdprd:1; /* 1 bits @ offs 0:0 */
	/*
	 * The number of UC packets silently discarded on the receive queue due to
	 * lack of receive descriptor.
	 */
	u16	mask_rq_num_ucsdprd:1; /* 1 bits @ offs 0:1 */
	/* Responder - number of local access errors. */
	u16	mask_rq_num_lae:1; /* 1 bits @ offs 0:2 */
	/* Responder - number of local protection errors. */
	u16	mask_rq_num_lpe:1; /* 1 bits @ offs 0:3 */
	/*
	 * Requester - number of remote invalid request errors NAK-Invalid Request
	 * on: 1. Unsupported OpCode: Responder detected an unsupported OpCode. 2.
	 * Unexpected OpCode: Responder detected an error in the sequence of OpCodes,
	 * such as a missing Last packet.
	 */
	u16	mask_sq_num_rire:1; /* 1 bits @ offs 0:4 */
	/*
	 * Responder - number of remote invalid request errors. NAK may or may not be
	 * sent. 1. QP Async Affiliated Error: Unsupported or Reserved OpCode (RC,RD
	 * only): Inbound request OpCode was either reserved, or was for a function
	 * not supported by thisQP. (E.g. RDMA or ATOMIC on QP not set up for this).
	 * 2. Misaligned ATOMIC: VA does not point to an aligned address on an atomic
	 * operation. 3. Too many RDMA READ or ATOMIC Requests: There were more
	 * requests received and not ACKed than allowed for the connection. 4. Out of
	 * Sequence OpCode, current packet is First or Only: The Responder detected
	 * an error in the sequence of OpCodes; a missing Last packet. 5. Out of
	 * Sequence OpCode, current packet is not First or Only: The Responder
	 * detected an error in the sequence of OpCodes; a missing First packet. 6.
	 * Local Length Error: Inbound Send request message exceeded the responder's
	 * available buffer space. 7. Length error: RDMA WRITE request message
	 * contained too much or too little pay-load data compared to the DMA length
	 * advertised in the first or only packet. 8. Length error: Payload length
	 * was not consistent with the opcode: a: only is between 0 and PMTU bytes b:
	 * (first or middle) equals PMTU bytes c: last is between 1 byte and PMTU
	 * bytes 9. Length error: Inbound message exceeded the size supported by the
	 * CA port.
	 */
	u16	mask_rq_num_rire:1; /* 1 bits @ offs 0:5 */
	/* Requester - number of bad response errors. */
	u16	mask_sq_num_bre:1; /* 1 bits @ offs 0:6 */
	/* Number of CQ overflows. */
	u16	mask_num_cqovf:1; /* 1 bits @ offs 0:7 */
	/* Requester - number of local length errors. */
	u16	mask_sq_num_lle:1; /* 1 bits @ offs 0:8 */
	/* Responder - number of local length errors. */
	u16	mask_rq_num_lle:1; /* 1 bits @ offs 0:9 */
	/* Requester - number local QP operation error. */
	u16	mask_sq_num_lqpoe:1; /* 1 bits @ offs 0:10 */
	/* Responder - number local QP operation error. */
	u16	mask_rq_num_lqpoe:1; /* 1 bits @ offs 0:11 */
	/* Requester - number of RNR nak retries exceeded errors. */
	u16	mask_sq_num_rree:1; /* 1 bits @ offs 0:12 */
	/* Requester - number of transport retries exceeded errors. */
	u16	mask_sq_num_tree:1; /* 1 bits @ offs 0:13 */
	/* Requester - number of out of sequence Naks received - XXX: look at this... */
	u16	mask_sq_num_oos:1; /* 1 bits @ offs 0:14 */
	/* Responder - number of out of sequence requests received. */
	u16	mask_rq_num_oos:1; /* 1 bits @ offs 0:15 */
	/*
	 * Requester - number of remote access errors. NAK-Remote Access Error on:
	 * R_Key Violation: Responder detected an invalid R_Key while executing an
	 * RDMA Request.
	 */
	u64	mask_sq_num_roe:1; /* 1 bits @ offs 0:16 */
	/*
	 * Responder - number of remote operation errors. NAK-Remote Operation Error
	 * on: 1. Malformed WQE: Responder detected a malformed Receive Queue WQE
	 * while processing the packet. 2. Remote Operation Error: Responder
	 * encountered an error, (local to the responder), which prevented it from
	 * completing the request.
	 */
	u64	mask_rq_num_roe:1; /* 1 bits @ offs 0:17 */
	/*
	 * Requester - number of remote access errors. NAK-Remote Access Error on:
	 * R_Key Violation: Responder detected an invalid R_Key while executing an
	 * RDMA Request.
	 */
	u64	mask_sq_num_rae:1; /* 1 bits @ offs 0:18 */
	/*
	 * Responder - number of remote access errors. R_Key Violation Responder
	 * detected an R_Key violation while executing an RDMA request. NAK may or
	 * may not be sent.
	 */
	u64	mask_rq_num_rae:1; /* 1 bits @ offs 0:19 */
	/* Requester - the number of RNR Naks received. */
	u64	mask_sq_num_rnr:1; /* 1 bits @ offs 0:20 */
	/* Responder - the number of RNR Naks sent. */
	u64	mask_rq_num_rnr:1; /* 1 bits @ offs 0:21 */
	/*
	 * Requester - number of CQEs with error. Incremented each time a CQE with
	 * error is generated.
	 */
	u64	mask_sq_num_wrfe:1; /* 1 bits @ offs 0:22 */
	/*
	 * Responder - number of CQEs with error. Incremented each time a CQE with
	 * error is generated.
	 */
	u64	mask_rq_num_wrfe:1; /* 1 bits @ offs 0:23 */
	/* Inlined mask : struct psif_err_counter_bit_mask (24 bits) */ /* 24 bits @ offs 0:24 */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:24 */
	u64	:34; /* 34 bits @ offs 0:30 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_clear_error_counters [64 bits] */

/* CSR automated type for TSU_ERR_CLEAR_ERROR_COUNTERS_KICK */
/* Clear all counters having the bit set in the mask. */
struct psif_csr_err_clear_error_counters_kick {
	/* *** 64 bit group 0 start *** */
	u64	data:1; /* 1 bits @ offs 0:0 */
	u64	:63; /* 63 bits @ offs 0:1 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_clear_error_counters_kick [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_0 */
/* Error counters. */
struct psif_csr_err_error_counter_0 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_wrfe; /* 32 bits @ offs 0:0 */
	u32	rq_num_wrfe; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_0 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_1 */
/* Error counters. */
struct psif_csr_err_error_counter_1 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_rnr; /* 32 bits @ offs 0:0 */
	u32	rq_num_rnr; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_1 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_2 */
/* Error counters. */
struct psif_csr_err_error_counter_2 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_rae; /* 32 bits @ offs 0:0 */
	u32	rq_num_rae; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_2 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_3 */
/* Error counters. */
struct psif_csr_err_error_counter_3 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_roe; /* 32 bits @ offs 0:0 */
	u32	rq_num_roe; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_3 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_4 */
/* Error counters. */
struct psif_csr_err_error_counter_4 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_oos; /* 32 bits @ offs 0:0 */
	u32	rq_num_oos; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_4 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_5 */
/* Error counters. */
struct psif_csr_err_error_counter_5 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_rree; /* 32 bits @ offs 0:0 */
	u32	sq_num_tree; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_5 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_6 */
/* Error counters. */
struct psif_csr_err_error_counter_6 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_lqpoe; /* 32 bits @ offs 0:0 */
	u32	rq_num_lqpoe; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_6 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_7 */
/* Error counters. */
struct psif_csr_err_error_counter_7 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_lle; /* 32 bits @ offs 0:0 */
	u32	rq_num_lle; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_7 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_8 */
/* Error counters. */
struct psif_csr_err_error_counter_8 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_bre; /* 32 bits @ offs 0:0 */
	u32	num_cqovf; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_8 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_9 */
/* Error counters. */
struct psif_csr_err_error_counter_9 {
	/* *** 64 bit group 0 start *** */
	u32	sq_num_rire; /* 32 bits @ offs 0:0 */
	u32	rq_num_rire; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_9 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_10 */
/* Error counters. */
struct psif_csr_err_error_counter_10 {
	/* *** 64 bit group 0 start *** */
	u32	rq_num_lae; /* 32 bits @ offs 0:0 */
	u32	rq_num_lpe; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_10 [64 bits] */

/* CSR automated type for TSU_ERR_ERROR_COUNTER_11 */
/* Error counters. */
struct psif_csr_err_error_counter_11 {
	/* *** 64 bit group 0 start *** */
	u32	rq_num_udsdprd; /* 32 bits @ offs 0:0 */
	u32	rq_num_ucsdprd; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_err_error_counter_11 [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT1US_CNT124US */
struct psif_csr_ibu_cnt1us_cnt124us {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0xf9fc
	 This register sets the base clocks for the other counters. Default : F9FCh Note: 1F3h (1us = 500 * 2ns), 7Ch (125us = 125 * 1us)
	 Bit 6-0 = Internal clock cycle (125us) set for Time Out Counter 
	 Bit 15-7 = Internal clock cycle (1us) set for Time Out Counter 
	 */
	u16	cnt1us_cnt124us; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt1us_cnt124us [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT2MS */
struct psif_csr_ibu_cnt2ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x10
	 This register sets the value of the counter used to generate DelayTimeOut (2ms) in the Link Training State Machine. Default: 0010h Note: 0010h (2ms less than 17 * 125us) 
	 Bit 11-0 = 2ms Time Out Counter set value
	 */
	u32	cnt_2ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt2ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT10MS */
struct psif_csr_ibu_cnt10ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x50
	 This register sets the value of the counter used to generate LinkDownTimeout in the Link State Machine. Default: 0050h Note: 0050h (10ms less than 81 * 125us) 
	 Bit 11-0 = 10ms Time Out Counter set value
	 */
	u32	cnt_10ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt10ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT100MS */
struct psif_csr_ibu_cnt100ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x320
	 This register sets the value of the counter used to generate DelayTimeOut (100ms) in the Link Training State Machine. Default: 0320h Note: 0320h (100ms less than 801 * 125us) 
	 Bit 11-0 = 100ms Time Out Counter set value
	 */
	u32	cnt_100ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt100ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT150MS */
struct psif_csr_ibu_cnt150ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x4b0
	 This register sets the value of the counter used to generate DelayTimeOut (150ms) in the Link Training State Machine. Default: 04B0h Note: 04B0h (150ms less than 1201 * 125us) 
	 Bit 11-0 = 150ms Time Out Counter set value
	 */
	u32	cnt_150ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt150ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT400MS */
struct psif_csr_ibu_cnt400ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0xc80
	 This register sets the value of the counter used to generate DelayTimeOut (400ms) in the Link Training State Machine. Default: 0C80h Note: 0C80h (400ms less than 3201 * 125us) 
	 Bit 11-0 = 400ms Time Out Counter set value
	 */
	u32	cnt_400ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt400ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_SKP_TO_CNT */
struct psif_csr_ibu_skp_to_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:7] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:25; /* 25 bits @ offs 0:0 */
	/* bit[6:0] RW reset = 0x47
	 This register sets the value of the counter used to determine the absence of 4 expected SKIP ordered-sets which should trigger link error recovery. Default: 0047h Note: 0047h (72us = 72 * 1us: 18000 symbol clock)
	 Bit 6-0 = Major Error (SKP) set (The absence of 4 expected SKIP ordered-set)
	 */
	u32	skp_to_cnt:7; /* 7 bits @ offs 0:25 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_skp_to_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_TGT_VAL */
struct psif_csr_ibu_tgt_val {
	/* *** 64 bit group 0 start *** */
	/* bit[31:13] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:19; /* 19 bits @ offs 0:0 */
	/* bit[12:0] RW reset = 0x0
	 This register sets the value of the counter used to determine when the SKIP-ordered set is transmitted. The timer will increment from the programmed value to the 4352 symbol max time limit. This reduces the time between scheduling Tx SKIPS which is useful for simulation. The programming range for this register is bit 12:0 = 0 to 10FFh (4352). Programming values outside of this range are illegal and will force a default 0000h value. For default: 0000h the timer will schedule Tx SKIPs every 4352 symbol times per IBTA Vol 2, sec 5.9.2) 
	 Bit 12-0 = SKIP ordered-set output timing reduction Range: 0h to 10FFh
	 */
	u32	tgt_val:13; /* 13 bits @ offs 0:19 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tgt_val [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_VCONFIG */
struct psif_csr_ibu_phy_vconfig {
	/* *** 64 bit group 0 start *** */
	/* bit[31:27] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:5; /* 5 bits @ offs 0:0 */
	/* bit[26:0] RW reset = 0x-2000
	 Bit 0: Invert polarity on Rx lane0. 
	 Bit 1: Invert polarity on Rx lane1. 
	 Bit 2: Invert polarity on Rx lane2. 
	 Bit 3: Invert polarity on Rx lane3. 
	 Bit 4: Reset phy/link Rx. Self-clearing bit. 
	 Bit 5: Reset phy/link Tx. Self-clearing bit. 
	 Bit 6: Skip error enable. 
	 Bit 7: Force sync counter clear. 
	 Bit 8: Disable idle check on receive. 
	 Bit 9: Disable leaky bucket retrain. 
	 Bit 10: Enable add. 
	 Bit 11: Running timers countinously in linkup. 
	 Bit 12: 8b10b: Only require synchronization for link up and ignore phy errors. edr/fdr: Force link up and ignore prbs errors. 
	 Bit 13: Enable optional Rx lane reversal. 
	 Bit 14: Enable optional Tx lane reversal Volume 2, 5.6.4.6.4: Config.TxRevLanes state 
	 Bit 15: Auto-train. 
	 bit 16: qdr/ddr/sdr phy loopback enabled. Diagnostic only. Not for production. 
	 bit 17: edr/fdr phy loopback enabled. Diagnostic only. Not for production. 
	 bit 18: qdr/ddr/sdr link loopback enabled. Diagnostic only. Not for production. 
	 bit 19: edr/fdr link loopback enabled. Diagnostic only. Not for production. 
	 bit 20: Blunt-end loopback enabled. Diagnostic only. Not for production. 
	 bit 21: Lane0 Tx polarity inversion. 
	 bit 22: Lane1 Tx polarity inversion. 
	 bit 23: Lane2 Tx polarity inversion. 
	 bit 24: Lane3 Tx polarity inversion. 
	 bit 25: TS3 MOD disable. 
	 bit 26: Legacy mode disable. 
	 */
	u32	phy_vconfig:27; /* 27 bits @ offs 0:5 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_vconfig [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_DISP_ERROR_CNT */
struct psif_csr_ibu_phy_disp_error_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RC reset = 0x0
	 Total disparity error count. See registers PCPhyCntRst PCPhyCntLoad for reset/load. 
	 */
	u32	phy_disp_error_cnt:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_disp_error_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_CODE_ERROR_CNT */
struct psif_csr_ibu_phy_code_error_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Total disparity error count. See registers PCPhyCntRst PCPhyCntLoad for reset/load. 
	 */
	u32	phy_code_error_cnt:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_code_error_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EVENT_LOG */
struct psif_csr_ibu_phy_event_log {
	/* *** 64 bit group 0 start *** */
	/* bit[31:30] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:2; /* 2 bits @ offs 0:0 */
	/* bit[29:0] RC reset = 0x0
	 Bit 0: Bit 0: Link down due to major 8b/10b phy error: TS1/TS2 received during linkup. 
	 Bit 1: Link down due to major 8b/10b phy error: synchronization loss. 
	 Bit 2: Link down due to major 8b/10b phy error: missing more than four skips.
	 Bit 3: Link down due to major 8b/10b phy error: deskew error. 
	 Bit 4: Reserved 
	 Bit 5: Reserved 
	 Bit 6: Reserved 
	 Bit 7: Reserved 
	 Bit 8: Link down due to major 8b/10b phy error: Leaky-Bucket error threshold. 
	 Bit 9: Link down due to Heart Beat Error 
	 Bit 10: Link down due to Local Link Integrity Errors (High num. of Pkts with physical errors). 
	 Bit 11: Link down due to excessive buffer overflows. 
	 Bit 12: Link down due to flow control timeout error. 
	 Bit 13: Reserved 
	 Bit 14: Reserved 
	 Bit 15: Reserved 
	 Bit 16: Reserved 
	 Bit 17: Reserved 
	 Bit 18: Reserved 
	 Bit 19: Reserved 
	 Bit 20: Reserved 
	 Bit 21: Reserved 
	 Bit 22: Reserved 
	 Bit 23: Reserved 
	 Bit 24: Reserved 
	 Bit 25: Reserved 
	 Bit 26: Reserved 
	 */
	u32	phy_event_log:30; /* 30 bits @ offs 0:2 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_event_log [64 bits] */

/* CSR automated type for IBU_P{1,2}_PORT_TRAIN_FSM */
struct psif_csr_ibu_port_train_fsm {
	/* *** 64 bit group 0 start *** */
	/* bit[31:5] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:27; /* 27 bits @ offs 0:0 */
	/* bit[4:0] RO reset = 0x0
	 Decoding : 
	 h'00: tr_sm_st_polling_act //reset state 
	 h'01: tr_sm_st_polling_qui 
	 h'02: tr_sm_st_sleep_delay 
	 h'03: tr_sm_st_sleep_quiet 
	 h'04: tr_sm_st_disabled 
	 h'05: tr_sm_st_conf_debounc 
	 h'06: tr_sm_st_conf_rcvrcfg 
	 h'07: tr_sm_st_conf_waitrmt 
	 h'08: tr_sm_st_conf_revlan 
	 h'09: tr_sm_st_conf_idle 
	 h'0a: tr_sm_st_conf_enhanced 
	 h'0b: tr_sm_st_conf_test 
	 h'0c: tr_sm_st_conf_waitrmttest 
	 h'0d: tr_sm_st_conf_wenhanced 
	 h'0e: tr_sm_st_linkup 
	 h'0f: tr_sm_st_rec_retrain 
	 h'10: tr_sm_st_rec_waitrmt 
	 h'11: tr_sm_st_rec_idle 
	 h'12: tr_sm_st_test 
	 */
	u32	port_train_fsm:5; /* 5 bits @ offs 0:27 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_port_train_fsm [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_TRAIN_SMTIMER_VS1 */
struct psif_csr_ibu_phy_train_smtimer_vs1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0x0
	 Vendor specific timer for train_sm used to assure at least 16TS [value in us]
	 */
	u32	phy_train_sm_timer_vs1:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_train_smtimer_vs1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_MASK */
struct psif_csr_ibu_mask {
	/* *** 64 bit group 0 start *** */
	/* bit[31:27] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:5; /* 5 bits @ offs 0:0 */
	/* bit[26:0] RW reset = 0x3f
	 Interrupt Mask. Matches Status reg addr x10 bit to bit. Setting each bit to one masks corresponding interrupt of Status register.
	 */
	u32	mask:27; /* 27 bits @ offs 0:5 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_mask [64 bits] */

/* CSR automated type for IBU_P{1,2}_STATUS */
struct psif_csr_ibu_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:1; /* 1 bits @ offs 0:0 */
	/* bit[30] RC reset = 0x0
	 Tx pkt from TSU discarded due to violation of operational VL (OperationalVLs addr x109).
	 */
	u16	port_transmit_vl_error:1; /* 1 bits @ offs 0:1 */
	/* bit[29] RC reset = 0x0
	 An unrecoverable ecc error detected in any of the Tx Srams.
	 */
	u16	tx_ecc_error_status:1; /* 1 bits @ offs 0:2 */
	/* bit[28] RC reset = 0x0
	 An unrecoverable ecc error detected in any of the Rx or loopback Srams.
	 */
	u16	rx_ecc_error_status:1; /* 1 bits @ offs 0:3 */
	/* bit[27] RC reset = 0x0
	 Overflow of any of the Tx ecc error counters: PCTxEccCorErrCnt, PCTxEccUncErrCnt.
	 */
	u16	tx_buffer_ecc_error_cnt_overflow_status:1; /* 1 bits @ offs 0:4 */
	/* bit[26] RC reset = 0x0
	 Overflow of any of the Rx ecc error counters: PCRxVL07EccCorErrCnt, PCRxVL07EccUncErrCnt, PCRxVL15EccCorErrCnt, PCRxVL15EccUncErrCnt, PCRxLoopEccCorErrCnt, PCRxLoopEccUncErrCnt.
	 */
	u16	rx_buffer_ecc_error_cnt_overflow_status:1; /* 1 bits @ offs 0:5 */
	/* bit[25] RC reset = 0x0
	 Overflow of any of the ib packet header error counters: PCLenRcvErrors, PCDlidRcvErrors, PCRcvFCLenErrors, PCRcvFCVlErrors.
	 */
	u16	ib_pkt_header_cnt_overflow_status:1; /* 1 bits @ offs 0:6 */
	/* bit[24] RC reset = 0x0
	 Overflow of any of the crc error counters: PCIcrcRcvErrors, PCVcrcRcvErrors, PCRcvFCCrcErrors.
	 */
	u16	crc_cnt_overflow_status:1; /* 1 bits @ offs 0:7 */
	/* bit[23] RC reset = 0x0
	 Overflow of transmit wait counter: PCPortXmitWait.
	 */
	u16	port_transmit_wait_cnt_overflow_status:1; /* 1 bits @ offs 0:8 */
	/* bit[22] RC reset = 0x0
	 Overflow of vl15 discard error counter: PCVL15Dropped.
	 */
	u16	port_vl15_discard_error_cnt_overflow_status:1; /* 1 bits @ offs 0:9 */
	/* bit[21] RC reset = 0x0
	 Tx pkt from TSU discarded due to violation of neighbor MTU (NeighborMTU addr x104). Clear port counter: PCPortXmitDiscards.
	 */
	u16	port_transmit_discard_error:1; /* 1 bits @ offs 0:10 */
	/* bit[20] RC reset = 0x0
	 Overflow of remote physical error counter: PCPortRcvRemotePhysicalErrors.
	 */
	u16	port_remote_physical_error_cnt_overflow_status:1; /* 1 bits @ offs 0:11 */
	/* bit[19] RC reset = 0x0
	 Overflow of the PCBufOverErrors counter.
	 */
	u16	port_buffer_overflow_errors:1; /* 1 bits @ offs 0:12 */
	/* bit[18] RC reset = 0x0
	 Overflow of the PortLocalPhysicalErrors counter.
	 */
	u16	port_local_physical_errors:1; /* 1 bits @ offs 0:13 */
	/* bit[17] RC reset = 0x0
	 Overflow of Rx link port receive Error counter: PCPortRcvError.
	 */
	u16	port_receive_error_cnt_overflow_status:1; /* 1 bits @ offs 0:14 */
	/* bit[16] RC reset = 0x0
	 Overflow of any of the eight Edr/Fdr FEC Error counters: PhyFECUncErr0,1,2,3 and PhyFECCorErr0,1,2,3.
	 */
	u16	fec_error_cnt_overflow_status:1; /* 1 bits @ offs 0:15 */
	/* bit[15] RC reset = 0x0
	 Overflow of any of the four Edr/Fdr 64bit block Error counters: PhySynHdrErr, PhyCinPktErr, PhyBlkEopErr, PhyBlkTypeErr.
	 */
	u16	block_error_cnt_overflow_status:1; /* 1 bits @ offs 0:16 */
	/* bit[14] RC reset = 0x0
	 Overflow of any of the four Edr/Fdr Error Detection Per Lane counters: PhyEdplErr0,1,2,3.
	 */
	u16	lane_edpl_error_cnt_overflow_status:1; /* 1 bits @ offs 0:17 */
	/* bit[13] RC reset = 0x0
	 Overflow of any of the four Edr/Fdr Prbs error counters: PhyPrbsErr0,1,2,3.
	 */
	u16	lane_prbs_error_cnt_overflow_status:1; /* 1 bits @ offs 0:18 */
	/* bit[12] RC reset = 0x0
	 Symbol error overflow of 8b10b symbol error counter PCSymbErrCnt.
	 */
	u16	minor_error_cnt_overflow_status:1; /* 1 bits @ offs 0:19 */
	/* bit[11] RC reset = 0x0
	 Symbol error overflow of any of the four 8b10b symbol error counters: PCSymbErrCntLane0,1,2,3.
	 */
	u16	lane_minor_error_cnt_overflow_status:1; /* 1 bits @ offs 0:20 */
	/* bit[10] RC reset = 0x0
	 Link Error Recovery Counter Overflow (PCLinkErrRecCnt).
	 */
	u16	link_error_recovery_cnt_overflow_status:1; /* 1 bits @ offs 0:21 */
	/* bit[9] RC reset = 0x0
	 TS3 rej Err. Vol 2: 5.5.2.4.
	 */
	u16	ts3_rej_status:1; /* 1 bits @ offs 0:22 */
	/* bit[8] RO reset = 0x0
	 Sets when Serdes Ready signal transitions from low to high.
	 */
	u16	serdes_ready:1; /* 1 bits @ offs 0:23 */
	/* bit[7] RC reset = 0x0
	 Received valid TS3 from the network.
	 */
	u16	rx_ts3_rcvd:1; /* 1 bits @ offs 0:24 */
	/* bit[6] RC reset = 0x0
	 Flow Control Timeout Error (FC timer expired). Vol 1: 7.12.1 and Table 131 (Trap 131).
	 */
	u16	fc_timeout_err_status:1; /* 1 bits @ offs 0:25 */
	/* bit[5] RC reset = 0x0
	 Port State Change. Vol 1: Table 143 and Table 131 (Trap 128).
	 */
	u16	port_state_change_status:1; /* 1 bits @ offs 0:26 */
	/* bit[4] RC reset = 0x0
	 Excessive Buffer Overruns (PCExcessiveBufferOverrunErrors). Vol 1: 7.12.1 and Table 131 (Trap 130).
	 */
	u16	excessive_buff_overrun_status:1; /* 1 bits @ offs 0:27 */
	/* bit[3] RC reset = 0x0
	 Local Link Integrity Errors counter overrun (PCLocalLinkIntegrityErrors). Vol 1: 7.12.1 and Table 131 (Trap 129).
	 */
	u16	local_link_integrity_status:1; /* 1 bits @ offs 0:28 */
	/* bit[2] RC reset = 0x0
	 Excessive count of physical link down (PCLinkDownedCnt).
	 */
	u16	excessive_phy_link_down_status:1; /* 1 bits @ offs 0:29 */
	/* bit[1] RC reset = 0x0
	 Vol 1 IBTA Table 143: Change of Port State. Down to Init, Init to Down, Arm to Down, Active to Down status.
	 */
	u16	port_state_status:1; /* 1 bits @ offs 0:30 */
	/* bit[0] RC reset = 0x0
	 Change of physical link up/down status.
	 */
	u16	link_change_status:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_WIDTH_ENABLED */
struct psif_csr_ibu_link_width_enabled {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0xb
	 IBTA Vol 1 PortInfo Table 146 LinkWidthEnabled.
	 */
	u32	link_width_enabled:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_width_enabled [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_WIDTH_SUPPORTED */
struct psif_csr_ibu_link_width_supported {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0x0
	 IBTA Vol 1 PortInfo Table 146 LinkWidthSupported.
	 */
	u32	link_width_supported:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_width_supported [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_WIDTH_ACTIVE */
struct psif_csr_ibu_link_width_active {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0x0
	 IBTA Vol 1 PortInfo Table 146 LinkWidthActive.
	 */
	u32	link_width_active:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_width_active [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_SPEED_SUPPORTED */
struct psif_csr_ibu_link_speed_supported {
	/* *** 64 bit group 0 start *** */
	/* bit[31:5] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:27; /* 27 bits @ offs 0:0 */
	/* bit[4:0] RO reset = 0x1f
	 IBTA Vol 1 PortInfo Table 146 LinkSpeedSupported x17:EDR/QDR/DDR/SDR or xF:FDR/QDR/DDR/SDR.
	 */
	u32	link_speed_supported:5; /* 5 bits @ offs 0:27 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_speed_supported [64 bits] */

/* CSR automated type for IBU_P{1,2}_PORT_PHYSICAL_STATE */
struct psif_csr_ibu_port_physical_state {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Reserved debug bits. May return non-zero values.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0x0
	 Vol2 5.6.1 PortPhysicalState. Not a conventional RW CSR. Write is a request to change PortPhyState, while read contains current PortPhyState. Write to force phy SM state: 0:no change, 1:Sleeping, 2:Polling, 3:Disabled, 4:Config, 5:linkup, 6:Recover, 7:Test.
	 */
	u32	port_physical_state:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_port_physical_state [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_DOWN_DEFAULT_STATE */
struct psif_csr_ibu_link_down_default_state {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0x0
	 LinkDownDefaultState: Volume 1, Table 146 PortInfo.
	 */
	u32	link_down_default_state:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_down_default_state [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_SPEED_ACTIVE */
struct psif_csr_ibu_link_speed_active {
	/* *** 64 bit group 0 start *** */
	/* bit[31:5] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:27; /* 27 bits @ offs 0:0 */
	/* bit[4:0] RO reset = 0x0
	 IBTA Vol 1 PortInfo Table 146.
	 */
	u32	link_speed_active:5; /* 5 bits @ offs 0:27 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_speed_active [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_SPEED_ENABLED */
struct psif_csr_ibu_link_speed_enabled {
	/* *** 64 bit group 0 start *** */
	/* bit[31:5] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:27; /* 27 bits @ offs 0:0 */
	/* bit[4:0] RW reset = 0x1
	 IBTA Vol 1 PortInfo Table 146. Default 2.5Gbps ref Vol 2: 5.6.4.2.1.
	 */
	u32	link_speed_enabled:5; /* 5 bits @ offs 0:27 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_speed_enabled [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPHY_CNT_RST */
struct psif_csr_ibu_pcphy_cnt_rst {
	/* *** 64 bit group 0 start *** */
	/* bit[31:3] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:29; /* 29 bits @ offs 0:0 */
	/* bit[2:0] WO reset = 0x0
	 Volume 1 table 228. CounterSelect: Select phy counter to reset. 
	 Bit 0 : Reset SymbErrCnt 
	 Bit 1 : Reset LinkErrorRecoveryCounter 
	 Bit 2 : Reset LinkDownedCounter 
	 Bit 3 : Reset PCSymbErrCntLane0 
	 Bit 4 : Reset PCSymbErrCntLane1 
	 Bit 5 : Reset PCSymbErrCntLane2 
	 Bit 6 : Reset PCSymbErrCntLane3 
	 Bit 7 : Reset PhyDispErrorCnt 
	 Bit 8 : Reset PhyCodeErrorCnt 
	 Bit 9 : Reset PhyPadErrorCnt 
	 Bit 10 : Reset PhyCntrlInPktErrorCnt 
	 Bit 11 : Reset PhyAlignErrorCnt 
	 Bit 12 : Reset PhyEdplErr0 
	 Bit 13 : Reset PhyEdplErr1 
	 Bit 14 : Reset PhyEdplErr2 
	 Bit 15 : Reset PhyEdplErr3 
	 Bit 16 : Reset PhySynHdrErr 
	 Bit 17 : Reset PhyCinPktErr 
	 Bit 18 : Reset PhyBlkEopErr 
	 Bit 19 : Reset PhyBlkTypeErr 
	 bit 20 : Reset PhyPrbsErr0 
	 bit 21 : Reset PhyPrbsErr1 
	 bit 22 : Reset PhyPrbsErr2 
	 bit 23 : Reset PhyPrbsErr3 
	 */
	u32	pc_phy_cnt_rst:3; /* 3 bits @ offs 0:29 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcphy_cnt_rst [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPHY_CNT_LOAD */
struct psif_csr_ibu_pcphy_cnt_load {
	/* *** 64 bit group 0 start *** */
	/* bit[31:3] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:29; /* 29 bits @ offs 0:0 */
	/* bit[2:0] WO reset = 0x0
	 Volume 1 table 228. CounterSelect: Loadable value is counters maximum value - 8. 
	 Bit 0 : Reset SymbErrCnt 
	 Bit 1 : Reset PCLinkErrRecCnt 
	 Bit 2 : Reset PCLinkDownedCnt 
	 Bit 3 : Reset PCSymbErrCntLane0 
	 Bit 4 : Reset PCSymbErrCntLane1 
	 Bit 5 : Reset PCSymbErrCntLane2 
	 Bit 6 : Reset PCSymbErrCntLane3 
	 Bit 7 : Reset PhyDispErrorCnt 
	 Bit 8 : Reset PhyCodeErrorCnt 
	 Bit 9 : Reset PhyPadErrorCnt 
	 Bit 10 : Reset PhyCntrlInPktErrorCnt 
	 Bit 11 : Reset PhyAlignErrorCnt 
	 Bit 12 : Reset PhyEdplErr0 
	 Bit 13 : Reset PhyEdplErr1 
	 Bit 14 : Reset PhyEdplErr2 
	 Bit 15 : Reset PhyEdplErr3 
	 Bit 16 : Reset PhySynHdrErr 
	 Bit 17 : Reset PhyCinPktErr 
	 Bit 18 : Reset PhyBlkEopErr 
	 Bit 19 : Reset PhyBlkTypeErr 
	 bit 20 : Reset PhyPrbsErr0 
	 bit 21 : Reset PhyPrbsErr1 
	 bit 22 : Reset PhyPrbsErr2 
	 bit 23 : Reset PhyPrbsErr3 
	 */
	u32	pc_phy_cnt_load:3; /* 3 bits @ offs 0:29 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcphy_cnt_load [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCSYMB_ERR_CNT */
struct psif_csr_ibu_pcsymb_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Volume 1 table 228. SymbErrCnt: Total number of minor errors detected on one or more physical lanes. With count greater than 24'hffffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	pc_symb_err_cnt:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcsymb_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCLINK_ERR_REC_CNT */
struct psif_csr_ibu_pclink_err_rec_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0x0
	 Volume 1 table 228: LinkErrorRecoveryCounter
	 */
	u32	pc_link_err_rec_cnt:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pclink_err_rec_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCLINK_DOWNED_CNT */
struct psif_csr_ibu_pclink_downed_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0x0
	 Volume 1 table 228: LinkDownedCounter
	 */
	u32	pc_link_downed_cnt:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pclink_downed_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCSYMB_ERR_CNT_LANE0 */
struct psif_csr_ibu_pcsymb_err_cnt_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:20] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:12; /* 12 bits @ offs 0:0 */
	/* bit[19:0] RO reset = 0x0
	 Symbol error count for lane 0: Total number of minor errors detected on Lane 0. With count greater than 20'hfffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	pc_symb_err_cnt:20; /* 20 bits @ offs 0:12 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcsymb_err_cnt_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCSYMB_ERR_CNT_LANE1 */
struct psif_csr_ibu_pcsymb_err_cnt_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:20] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:12; /* 12 bits @ offs 0:0 */
	/* bit[19:0] RO reset = 0x0
	 Symbol error count for lane 1: Total number of minor errors detected on Lane 1. With count greater than 20'hfffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	pc_symb_err_cnt:20; /* 20 bits @ offs 0:12 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcsymb_err_cnt_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCSYMB_ERR_CNT_LANE2 */
struct psif_csr_ibu_pcsymb_err_cnt_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:20] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:12; /* 12 bits @ offs 0:0 */
	/* bit[19:0] RO reset = 0x0
	 Symbol error count for lane 2: Total number of minor errors detected on Lane 2. With count greater than 20'hfffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	pc_symb_err_cnt:20; /* 20 bits @ offs 0:12 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcsymb_err_cnt_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCSYMB_ERR_CNT_LANE3 */
struct psif_csr_ibu_pcsymb_err_cnt_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:20] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:12; /* 12 bits @ offs 0:0 */
	/* bit[19:0] RO reset = 0x0
	 Symbol error count for lane 3: Total number of minor errors detected on Lane 3. With count greater than 20'hfffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	pc_symb_err_cnt:20; /* 20 bits @ offs 0:12 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcsymb_err_cnt_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT0_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt0_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x80
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_0:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt0_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT1_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt1_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x100
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_1:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt1_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT2_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt2_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x180
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_2:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt2_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT3_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt3_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x200
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_3:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt3_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ALIGN_ERROR_CNT */
struct psif_csr_ibu_phy_align_error_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RC reset = 0x0
	 Total sop/eop alignment error count. See registers PCPhyCntRst PCPhyCntLoad for reset/load. 
	 */
	u32	phy_align_error_cnt:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_align_error_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_CNTRL_IN_PKT_ERROR_CNT */
struct psif_csr_ibu_phy_cntrl_in_pkt_error_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RC reset = 0x0
	 Total control inside packet error count. See registers PCPhyCntRst PCPhyCntLoad for reset/load. 
	 */
	u32	phy_control_in_pkt_error_cnt:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_cntrl_in_pkt_error_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_PAD_ERROR_CNT */
struct psif_csr_ibu_phy_pad_error_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RC reset = 0x0
	 Total pad error count. See registers PCPhyCntRst PCPhyCntLoad for reset/load. 
	 */
	u32	phy_pad_error_cnt:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_pad_error_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EDR_FDR_CONFIG0 */
struct psif_csr_ibu_phy_edr_fdr_config0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_edr_fdr_config0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EDR_FDR_CONFIG1 */
struct psif_csr_ibu_phy_edr_fdr_config1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_edr_fdr_config1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_LEAKY_BKT_THRSH */
struct psif_csr_ibu_phy_leaky_bkt_thrsh {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:8] RW reset = 0x4
	 8 bit value for Leaky bucket error threshold for high speeds edr/fdr. During edr/fdr link up, minor errors above this threshold will trigger retrain. 
	 */
	u16	phy_leaky_bkt_thrsh_edr_fdr:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x3
	 8 bit value for Leaky bucket error threshold for enhanced speeds. During qdr/ddr/sdr link up minor errors above this threshold will trigger retrain. 
	 */
	u16	phy_leaky_bkt_thrsh_qdr_ddr_sdr:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_leaky_bkt_thrsh [64 bits] */

/* CSR automated type for IBU_P{1,2}_RCV_TS3_STATUS_LOW */
struct psif_csr_ibu_rcv_ts3_status_low {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 First 32 bits of last valid Rx TS3.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rcv_ts3_status_low [64 bits] */

/* CSR automated type for IBU_P{1,2}_RCV_TS3_STATUS_HIGH */
struct psif_csr_ibu_rcv_ts3_status_high {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 Last 32 bits of last valid Rx TS3.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rcv_ts3_status_high [64 bits] */

/* CSR automated type for IBU_P{1,2}_GUID0 */
struct psif_csr_ibu_guid0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 Volume 1 5.2
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_guid0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_GUID1 */
struct psif_csr_ibu_guid1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 Volume 1 5.2
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_guid1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PNUM */
struct psif_csr_ibu_pnum {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x0
	 Volume 1 5.2
	 */
	u32	pnum:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pnum [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT4MS */
struct psif_csr_ibu_cnt4ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x20
	 Sets counter limit value used to generate a 4ms time during Link Training equalization in conf.test state for each of 16th Tx Serdes settings of 4ms each. Additionally, for EDR/FDR, this count measures the 4ms default time for Training SM states that require speed change time: Conf.Test, Conf.WEnhanced, Conf.WaitRmtTest states. Default: 0020h Note: 0020h 
	 Bit 11-0 = 4ms Time Out Counter set value
	 */
	u32	cnt_4ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt4ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT36MS */
struct psif_csr_ibu_cnt36ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x120
	 This register sets the value of the counter used to generate a 36ms time during Link Training equalization in conf.test state for the default Tx Serdes setting. Default: 0120h Note: 0120h 
	 Bit 11-0 = 36ms Time Out Counter set value
	 */
	u32	cnt_36ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt36ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_TS3_CONFIG */
struct psif_csr_ibu_phy_ts3_config {
	/* *** 64 bit group 0 start *** */
	/* bit[31:15] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:17; /* 17 bits @ offs 0:0 */
	/* bit[14] RW reset = 0x1
	 Programmable hbr.
	 */
	u32	csr_ts3_config_hbr:1; /* 1 bits @ offs 0:17 */
	/* bit[13] RW reset = 0x1
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_amp:1; /* 1 bits @ offs 0:18 */
	/* bit[12:11] RW reset = 0x1
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_rev:2; /* 2 bits @ offs 0:19 */
	/* bit[10] RW reset = 0x0
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_sct:1; /* 1 bits @ offs 0:21 */
	/* bit[9] RW reset = 0x0
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_tp:1; /* 1 bits @ offs 0:22 */
	/* bit[8] RW reset = 0x0
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_ft:1; /* 1 bits @ offs 0:23 */
	/* bit[7] RW reset = 0x0
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_mpr:1; /* 1 bits @ offs 0:24 */
	/* bit[6] RW reset = 0x1
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_fec:1; /* 1 bits @ offs 0:25 */
	/* bit[5:4] RW reset = 0x0
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_fcu:2; /* 2 bits @ offs 0:26 */
	/* bit[3:0] RW reset = 0x4
	 Volume 2 5.5.2.4
	 */
	u32	csr_ts3_config_tt:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_ts3_config [64 bits] */

/* CSR automated type for IBU_P{1,2}_DDS_WINDOW_START */
struct psif_csr_ibu_dds_window_start {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x2
	 Volume 2, sec 5.6.4.6 : Implementation notes
	 */
	u32	dds_window_start:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_dds_window_start [64 bits] */

/* CSR automated type for IBU_P{1,2}_DDS_WINDOW_END */
struct psif_csr_ibu_dds_window_end {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x20
	 Volume 2, sec 5.6.4.6 : Implementation notes
	 */
	u32	dds_window_end:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_dds_window_end [64 bits] */

/* CSR automated type for IBU_P{1,2}_DDS_DEFAULT_WINDOW_END */
struct psif_csr_ibu_dds_default_window_end {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x20
	 Volume 2, sec 5.6.4.6 : Implementation notes
	 */
	u32	dds_default_window_end:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_dds_default_window_end [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TS3DDS_STATUS */
struct psif_csr_ibu_rx_ts3dds_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0x0
	 Last DUT received TS3 DDSV,MOD,DDS value. Volume 2, sec 5.6.4.6. Bit 7: DDSV, Bit 6:MOD, Bit 5:0: DDS.
	 */
	u32	rx_ts3_dds_status:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_ts3dds_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TS3DDS_STATUS */
struct psif_csr_ibu_tx_ts3dds_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0x0
	 Last DUT transmitted TS3 DDSV,MOD,DDS value. Volume 2, sec 5.6.4.6. Bit 7: DDSV, Bit 6:MOD, Bit 5:0: DDS.
	 */
	u32	tx_ts3_dds_status:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_ts3dds_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT16MS */
struct psif_csr_ibu_cnt16ms {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x80
	 This register sets the value of the counter used to generate a 16ms time during Link Training equalization in conf.test state for the Extended Speed Change time. Default: 0120h Note: 0120h 
	 Bit 11-0 = 16ms Time Out Counter set value
	 */
	u32	cnt_16ms:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt16ms [64 bits] */

/* CSR automated type for IBU_P{1,2}_CONF_TEST4MS_SCT */
struct psif_csr_ibu_conf_test4ms_sct {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x20
	 Default value of the (SCT) Speed Change Time during TS3 rev1 Config.Test. Default 4ms.
	 */
	u32	cnt_4ms_sct:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_conf_test4ms_sct [64 bits] */

/* CSR automated type for IBU_P{1,2}_CONF_TEST16MS_SCT */
struct psif_csr_ibu_conf_test16ms_sct {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x80
	 Extended value of the (SCT) Speed Change Time during TS3 rev1 Config.Test. Default 4ms.
	 */
	u32	cnt_16ms_sct:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_conf_test16ms_sct [64 bits] */

/* CSR automated type for IBU_P{1,2}_LOCAL_ADDTEST_LIMIT */
struct psif_csr_ibu_local_addtest_limit {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x1
	 Total number of ADD iterations for a given speed before down rating to a lower speed. Current default of one allows one iteration. TS3 rev0: Each iteration uses one receiver equalization value through the 17 possible Driver De-emphasis values. TS3 rev1: Each iteration uses one receiver equalization value for one Driver De-emphasis value. 256 max equ/dds pairs.
	 */
	u32	local_add_test_limit:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_local_addtest_limit [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_ADDTEST_LIMIT */
struct psif_csr_ibu_remote_addtest_limit {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x0
	 Total number of ADD iterations for a given speed that the remote node is allowed before DUT down rates to a lower speed. Current default of zero allows the remote node unlimited iterations. CURRENTLY NOT IMPLEMENTED.
	 */
	u32	remote_add_test_limit:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_addtest_limit [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT4_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt4_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x320
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_4:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt4_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT5_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt5_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x400
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_5:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt5_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT6_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt6_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x800
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_6:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt6_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT7_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt7_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0xc00
	 Volume 2 5.5.2.4
	 */
	u32	csr_tt_7:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt7_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT8_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt8_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x1000
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_8; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt8_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT9_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt9_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x1400
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_9; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt9_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT10_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt10_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x1800
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_10; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt10_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT11_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt11_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x1c00
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_11; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt11_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT12_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt12_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x2000
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_12; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt12_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT13_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt13_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x4000
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_13; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt13_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT14_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt14_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x6000
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_14; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt14_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_TS3_REV1_TT15_COUNTER */
struct psif_csr_ibu_ts3_rev1_tt15_counter {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	reseved_0; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x-8000
	 Volume 2 5.5.2.4
	 */
	u16	csr_tt_15; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_ts3_rev1_tt15_counter [64 bits] */

/* CSR automated type for IBU_P{1,2}_CONF_TEST_LANE_ERROR_LIMIT */
struct psif_csr_ibu_conf_test_lane_error_limit {
	/* *** 64 bit group 0 start *** */
	/* bit[31:17] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:15; /* 15 bits @ offs 0:0 */
	/* bit[16:0] RW reset = 0x1
	 Max per lane error count to qualify a dds/equ setting during Link Training Conf.Test as passing.
	 */
	u32	csr_lane_err_limit:17; /* 17 bits @ offs 0:15 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_conf_test_lane_error_limit [64 bits] */

/* CSR automated type for IBU_P{1,2}_CONF_TEST_IDLE_LIMIT */
struct psif_csr_ibu_conf_test_idle_limit {
	/* *** 64 bit group 0 start *** */
	/* bit[31:17] RO reset = 0x0
	 Always read as zero.
	 */
	u32	reseved_0:15; /* 15 bits @ offs 0:0 */
	/* bit[16:0] RW reset = 0x1
	 Minimum idle count from all lanes to qualify Conf.Test as passing. Relevant only when dut add is disabled.
	 */
	u32	csr_idle_limit:17; /* 17 bits @ offs 0:15 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_conf_test_idle_limit [64 bits] */

/* CSR automated type for IBU_P{1,2}_CONF_TEST2MS_SCT */
struct psif_csr_ibu_conf_test2ms_sct {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x10
	 QDR/DDR/SDR value of the (SCT) Speed Change Time during TS3 rev1 Config.Test. Default 2ms.
	 */
	u32	cnt_2ms_sct:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_conf_test2ms_sct [64 bits] */

/* CSR automated type for IBU_P{1,2}_CNT100_MS_HBR */
struct psif_csr_ibu_cnt100_ms_hbr {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RW reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x50
	 Programmable timer for 100ms heart beat send.
	 */
	u32	cnt_100ms_hbr:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cnt100_ms_hbr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMAEQULANE0_STATUS */
struct psif_csr_ibu_pmaequlane0_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Equalization value from DUT to PMA LANE0.
	 */
	u32	pma_equ_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaequlane0_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMAEQULANE1_STATUS */
struct psif_csr_ibu_pmaequlane1_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Equalization value from DUT to PMA LANE1.
	 */
	u32	pma_equ_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaequlane1_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMAEQULANE2_STATUS */
struct psif_csr_ibu_pmaequlane2_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Equalization value from DUT to PMA LANE2.
	 */
	u32	pma_equ_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaequlane2_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMAEQULANE3_STATUS */
struct psif_csr_ibu_pmaequlane3_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Equalization value from DUT to PMA LANE3.
	 */
	u32	pma_equ_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaequlane3_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMADDSLANE0_STATUS */
struct psif_csr_ibu_pmaddslane0_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Driver De-Emphasis value from DUT to PMA LANE0.
	 */
	u32	pma_dds_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaddslane0_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMADDSLANE1_STATUS */
struct psif_csr_ibu_pmaddslane1_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Driver De-Emphasis value from DUT to PMA LANE1.
	 */
	u32	pma_dds_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaddslane1_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMADDSLANE2_STATUS */
struct psif_csr_ibu_pmaddslane2_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Driver De-Emphasis value from DUT to PMA LANE2.
	 */
	u32	pma_dds_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaddslane2_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMADDSLANE3_STATUS */
struct psif_csr_ibu_pmaddslane3_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 Driver De-Emphasis value from DUT to PMA LANE3.
	 */
	u32	pma_dds_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pmaddslane3_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EDPL_ERR0 */
struct psif_csr_ibu_phy_edpl_err0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 EDR/FDR EDPL Error count for lane 0.
	 */
	u32	phy_portcounter_dout_edpl0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_edpl_err0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EDPL_ERR1 */
struct psif_csr_ibu_phy_edpl_err1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 EDR/FDR EDPL Error count for lane 1.
	 */
	u32	phy_portcounter_dout_edpl1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_edpl_err1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EDPL_ERR2 */
struct psif_csr_ibu_phy_edpl_err2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 EDR/FDR EDPL Error count for lane 2.
	 */
	u32	phy_portcounter_dout_edpl2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_edpl_err2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_EDPL_ERR3 */
struct psif_csr_ibu_phy_edpl_err3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RO reset = 0x0
	 EDR/FDR EDPL Error count for lane 3.
	 */
	u32	phy_portcounter_dout_edpl3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_edpl_err3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_BLK_TYPE_ERR */
struct psif_csr_ibu_phy_blk_type_err {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Block Type Error count.
	 */
	u16	phy_portcounter_dout_blk_type; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_blk_type_err [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_BLK_EOP_ERR */
struct psif_csr_ibu_phy_blk_eop_err {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Block End of Packet Error count.
	 */
	u16	phy_portcounter_dout_blk_eop; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_blk_eop_err [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_CIN_PKT_ERR */
struct psif_csr_ibu_phy_cin_pkt_err {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Control inside Paket Error count.
	 */
	u16	phy_portcounter_dout_cinpkt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_cin_pkt_err [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_SYN_HDR_ERR */
struct psif_csr_ibu_phy_syn_hdr_err {
	/* *** 64 bit group 0 start *** */
	/* bit[31:20] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:12; /* 12 bits @ offs 0:0 */
	/* bit[19:0] RO reset = 0x0
	 EDR/FDR Block Sync Header Error count.
	 */
	u32	phy_portcounter_dout_synhdr:20; /* 20 bits @ offs 0:12 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_syn_hdr_err [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_PRBS_ERR0 */
struct psif_csr_ibu_phy_prbs_err0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Conf.Test prbs Error count for lane 0.
	 */
	u16	phy_portcounter_dout_prbs0; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_prbs_err0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_PRBS_ERR1 */
struct psif_csr_ibu_phy_prbs_err1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Conf.Test prbs Error count for lane 1.
	 */
	u16	phy_portcounter_dout_prbs1; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_prbs_err1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_PRBS_ERR2 */
struct psif_csr_ibu_phy_prbs_err2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Conf.Test prbs Error count for lane 2.
	 */
	u16	phy_portcounter_dout_prbs2; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_prbs_err2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_PRBS_ERR3 */
struct psif_csr_ibu_phy_prbs_err3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR Conf.Test prbs Error count for lane 3.
	 */
	u16	phy_portcounter_dout_prbs3; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_prbs_err3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_DESKEW_STATUS */
struct psif_csr_ibu_phy_deskew_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:19] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:13; /* 13 bits @ offs 0:0 */
	/* bit[18:0] RO reset = 0x0
	 Bit 0: sync_status_0, Bit 1: sync_status_1, Bit 2:sync_status_2, Bit 3:sync_status_3, Bit 4: Deskew Status, Bit 5: Deskew 0, Bit 6: Deskew 1, Bit 7: Reserved, Bit 11:8 deskew_sm0, Bit 15:12 deskew_sm1, 17:16 deskew_arb_sm.
	 */
	u32	sync_deskew_status:19; /* 19 bits @ offs 0:13 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_deskew_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECUNC_ERR0 */
struct psif_csr_ibu_phy_fecunc_err0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC uncorrectable Error count for lane 0.
	 */
	u16	phy_portcounter_dout_fec_unc0; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_fecunc_err0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECUNC_ERR1 */
struct psif_csr_ibu_phy_fecunc_err1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC uncorrectable Error count for lane 1.
	 */
	u16	phy_portcounter_dout_fec_unc1; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_fecunc_err1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECUNC_ERR2 */
struct psif_csr_ibu_phy_fecunc_err2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC uncorrectable Error count for lane 2.
	 */
	u16	phy_portcounter_dout_fec_unc2; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_fecunc_err2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECUNC_ERR3 */
struct psif_csr_ibu_phy_fecunc_err3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC uncorrectable Error count for lane 3.
	 */
	u16	phy_portcounter_dout_fec_unc3; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_fecunc_err3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECCOR_ERR0 */
struct psif_csr_ibu_phy_feccor_err0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC correctable Error count for lane 0.
	 */
	u16	phy_portcounter_dout_fec_cor0; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_feccor_err0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECCOR_ERR1 */
struct psif_csr_ibu_phy_feccor_err1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC correctable Error count for lane 1.
	 */
	u16	phy_portcounter_dout_fec_cor1; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_feccor_err1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECCOR_ERR2 */
struct psif_csr_ibu_phy_feccor_err2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC correctable Error count for lane 2.
	 */
	u16	phy_portcounter_dout_fec_cor2; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_feccor_err2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FECCOR_ERR3 */
struct psif_csr_ibu_phy_feccor_err3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 EDR/FDR FEC correctable Error count for lane 3.
	 */
	u16	phy_portcounter_dout_fec_cor3; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_feccor_err3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_SMSTATUS */
struct psif_csr_ibu_phy_smstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:11] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:21; /* 21 bits @ offs 0:0 */
	/* bit[10:9] RO reset = 0x0
	 Phy ctrl rate sm status.
	 */
	u32	phy_rate_sm_status:2; /* 2 bits @ offs 0:21 */
	/* bit[8:4] RO reset = 0x0
	 Phy Rx training sm status.
	 */
	u32	phy_rx_sm_status:5; /* 5 bits @ offs 0:23 */
	/* bit[3:0] RO reset = 0x0
	 Phy Tx sm status.
	 */
	u32	phy_tx_sm_status:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_smstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_TS3_NEGOTIATED_STATUS */
struct psif_csr_ibu_phy_ts3_negotiated_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:8] RO reset = 0x0
	 Netotiated TS3 test time. TS3 rev1 only. Supported for all speeds.
	 */
	u32	tt:4; /* 4 bits @ offs 0:20 */
	/* bit[7] RO reset = 0x0
	 Netotiated TS3 forward error correction. TS3 rev1 only. Supported for EDR/FDR speeds only.
	 */
	u32	fec:1; /* 1 bits @ offs 0:24 */
	/* bit[6] RO reset = 0x0
	 PSIF Unsupported. Negotiated TS3 fine tunning.
	 */
	u32	ft:1; /* 1 bits @ offs 0:25 */
	/* bit[5] RO reset = 0x0
	 Negotiated TS3 test pattern. TS3 rev1 only. Supported for EDR/FDR speeds only.
	 */
	u32	tp:1; /* 1 bits @ offs 0:26 */
	/* bit[4] RO reset = 0x0
	 Negotiated TS3 speed change time. TS3 rev1 only. Supported for all speeds.
	 */
	u32	sct:1; /* 1 bits @ offs 0:27 */
	/* bit[3:2] RO reset = 0x0
	 Negotiated TS3 flow control unit. TS3 rev1 only. Supported for all speeds.
	 */
	u32	fcu:2; /* 2 bits @ offs 0:28 */
	/* bit[1:0] RO reset = 0x0
	 Negotiated TS3 revision. 1:rev1, 0:rev0
	 */
	u32	revision:2; /* 2 bits @ offs 0:30 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_ts3_negotiated_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_TEST */
struct psif_csr_ibu_phy_test {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15] RW reset = 0x0
	 When set, the IBU logic will use the speed/opcode in this CSR instead of Rx TS-T speed/opcode.
	 */
	u16	phy_test_enable:1; /* 1 bits @ offs 0:16 */
	/* bit[14:13] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:2; /* 2 bits @ offs 0:17 */
	/* bit[12:8] RW reset = 0x0
	 Vendor feature: CSR IBTA Test Compliance Vol 2 5.18: speed.
	 */
	u16	phy_test_opcode:5; /* 5 bits @ offs 0:19 */
	/* bit[7:0] RW reset = 0x0
	 Vendor feature: CSR IBTA Test Compliance Vol 2 5.18: opcode: 0000 0000:Skipless, idle data (scrambled) 0000 0001:Skipless, TS1 (scrambled) 0000 0010:Receiver test (scrambled) 0000 0011:High frequency pattern (unscrambled) 0000 0100:PRBS31 (unscrambled) 0000 0101:PRBS11 (unscrambled) 0000 0110:PRBS9 (unscrambled) 0000 0111:TS1 with SKPs (scrambled) 0000 1111:TS1 with SKPs (unscrambled)
	 */
	u16	phy_test_speed:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_test [64 bits] */

/* CSR automated type for IBU_P{1,2}_EDR_FDR_RX_STATUS_REG0 */
struct psif_csr_ibu_edr_fdr_rx_status_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Number of times lane0 skip timeout counter has expired.
	 */
	u16	skip_timeout_count_lane0:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RO reset = 0x0
	 Number of times lane2 skip timeout counter has expired.
	 */
	u16	skip_timeout_count_lane1:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RO reset = 0x0
	 Number of times lane2 skip timeout counter has expired.
	 */
	u16	skip_timeout_count_lane2:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RO reset = 0x0
	 Number of times lane3 skip timeout counter has expired.
	 */
	u16	skip_timeout_count_lane3:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_edr_fdr_rx_status_reg0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_EDR_FDR_RX_STATUS_REG1 */
struct psif_csr_ibu_edr_fdr_rx_status_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:4] RO reset = 0x0
	 edr_rx_deskew_st_a
	 */
	u32	edr_rx_deskew_status_a:4; /* 4 bits @ offs 0:24 */
	/* bit[3:0] RO reset = 0x0
	 edr_rx_deskew_st_b
	 */
	u32	edr_rx_deskew_status_b:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_edr_fdr_rx_status_reg1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_EDR_FDR_RX_STATUS_REG2 */
struct psif_csr_ibu_edr_fdr_rx_status_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:21] RO reset = 0x0
	 edr_rx_lane0_deskew_st_a.
	 */
	u32	edr_rx_lane0_deskew_st_a:3; /* 3 bits @ offs 0:8 */
	/* bit[20:18] RO reset = 0x0
	 edr_rx_lane1_deskew_st_a.
	 */
	u32	edr_rx_lane1_deskew_st_a:3; /* 3 bits @ offs 0:11 */
	/* bit[17:15] RO reset = 0x0
	 edr_rx_lane2_deskew_st_a.
	 */
	u32	edr_rx_lane2_deskew_st_a:3; /* 3 bits @ offs 0:14 */
	/* bit[14:12] RO reset = 0x0
	 edr_rx_lane3_deskew_st_a.
	 */
	u32	edr_rx_lane3_deskew_st_a:3; /* 3 bits @ offs 0:17 */
	/* bit[11:9] RO reset = 0x0
	 edr_rx_lane0_deskew_st_b.
	 */
	u32	edr_rx_lane0_deskew_st_b:3; /* 3 bits @ offs 0:20 */
	/* bit[8:6] RO reset = 0x0
	 edr_rx_lane1_deskew_st_b.
	 */
	u32	edr_rx_lane1_deskew_st_b:3; /* 3 bits @ offs 0:23 */
	/* bit[5:3] RO reset = 0x0
	 edr_rx_lane2_deskew_st_b.
	 */
	u32	edr_rx_lane2_deskew_st_b:3; /* 3 bits @ offs 0:26 */
	/* bit[2:0] RO reset = 0x0
	 edr_rx_lane3_deskew_st_b.
	 */
	u32	edr_rx_lane3_deskew_st_b:3; /* 3 bits @ offs 0:29 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_edr_fdr_rx_status_reg2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_EDR_FDR_TX_STATUS_REG0 */
struct psif_csr_ibu_edr_fdr_tx_status_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 To be defined.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_edr_fdr_tx_status_reg0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_INT_PRIORITY */
struct psif_csr_ibu_int_priority {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x1
	 Interrupt priority for non-fatal interrupts. Matches Status reg addr x10 bit to bit. Setting each bit to one makes corresponding non-fatal interrupt to be high priority. For each bit reset to zero, the corresponding non-fatal interrupt is low priority.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_int_priority [64 bits] */

/* CSR automated type for IBU_P{1,2}_INT_FATAL */
struct psif_csr_ibu_int_fatal {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x30000001
	 Matches Status reg addr x10 bit to bit. Setting each bit to one makes corresponding interrupt to be fatal.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_int_fatal [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_ROUND_TRIP_LATENCY */
struct psif_csr_ibu_link_round_trip_latency {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Link round trip latency in units of system clock cycles:IBTA Vol 2, 5.14.1 Operation of Link Heart Beats.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_round_trip_latency [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_FORCE_LEGACY_MODE */
struct psif_csr_ibu_phy_force_legacy_mode {
	/* *** 64 bit group 0 start *** */
	/* bit[31:6] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:26; /* 26 bits @ offs 0:0 */
	/* bit[5] RW reset = 0x0
	 Enable IBTA legacy mode :IBTA Vol 2, 5.8.4.5 Configuration States-Legacy Operation.
	 */
	u32	phy_vconfig_force_legacy_ena:1; /* 1 bits @ offs 0:26 */
	/* bit[4] RW reset = 0x0
	 Force EDR speed in IBTA legacy mode :IBTA Vol 2, 5.8.4.5 Configuration States-Legacy Operation.
	 */
	u32	phy_vconfig_force_legacy_edr:1; /* 1 bits @ offs 0:27 */
	/* bit[3] RW reset = 0x0
	 Force FDR speed in IBTA legacy mode :IBTA Vol 2, 5.8.4.5 Configuration States-Legacy Operation.
	 */
	u32	phy_vconfig_force_legacy_fdr:1; /* 1 bits @ offs 0:28 */
	/* bit[2] RW reset = 0x0
	 Force QDR speed in IBTA legacy mode :IBTA Vol 2, 5.8.4.5 Configuration States-Legacy Operation.
	 */
	u32	phy_vconfig_force_legacy_qdr:1; /* 1 bits @ offs 0:29 */
	/* bit[1] RW reset = 0x0
	 Force DDR speed in IBTA legacy mode :IBTA Vol 2, 5.8.4.5 Configuration States-Legacy Operation.
	 */
	u32	phy_vconfig_force_legacy_ddr:1; /* 1 bits @ offs 0:30 */
	/* bit[0] RW reset = 0x0
	 Force SDR speed in IBTA legacy mode :IBTA Vol 2, 5.8.4.5 Configuration States-Legacy Operation.
	 */
	u32	phy_vconfig_force_legacy_sdr:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_force_legacy_mode [64 bits] */

/* CSR automated type for IBU_P{1,2}_LID */
struct psif_csr_ibu_lid {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 ....., defined in IB spec.
	 */
	u16	base_lid; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_lid [64 bits] */

/* CSR automated type for IBU_P{1,2}_LMC */
struct psif_csr_ibu_lmc {
	/* *** 64 bit group 0 start *** */
	/* bit[31:3] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:29; /* 29 bits @ offs 0:0 */
	/* bit[2:0] RW reset = 0x0
	 ....., defined in IB spec.
	 */
	u32	lid_mask_count:3; /* 3 bits @ offs 0:29 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_lmc [64 bits] */

/* CSR automated type for IBU_P{1,2}_PORT_STATE */
struct psif_csr_ibu_port_state {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0x0
	 States as defined in IB spec. This is not a conventional RW register. Write is a request to change PortState, while read contains current PortState 
	 */
	u32	port_state:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_port_state [64 bits] */

/* CSR automated type for IBU_P{1,2}_VLCAP */
struct psif_csr_ibu_vlcap {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RO reset = 0x4
	 VLCap =4, VL0-VL7 vol1 14.2.5.6.
	 */
	u32	vlcap:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_vlcap [64 bits] */

/* CSR automated type for IBU_P{1,2}_NEIGHBOR_MTU */
struct psif_csr_ibu_neighbor_mtu {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0x0
	 Volume 1 7.7.8 PktLen. Table 19 Packet Size. NeighborMTU=6 for 10K frames.
	 */
	u32	neighbor_mtu:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_neighbor_mtu [64 bits] */

/* CSR automated type for IBU_P{1,2}_VLHIGH_LIMIT */
struct psif_csr_ibu_vlhigh_limit {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x0
	 Vol 1 Table 146 VLHighLimit.
	 */
	u32	vl_high_limit:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_vlhigh_limit [64 bits] */

/* CSR automated type for IBU_P{1,2}_VLARBITRATION_HIGH_CAP */
struct psif_csr_ibu_vlarbitration_high_cap {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0xa
	 Reads xA. Vol 1 Table 146.
	 */
	u32	vl_arbitration_high_cap:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_vlarbitration_high_cap [64 bits] */

/* CSR automated type for IBU_P{1,2}_VLARBITRATION_LOW_CAP */
struct psif_csr_ibu_vlarbitration_low_cap {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RO reset = 0xa
	 Reads xA. Vol 1 Table 146.
	 */
	u32	vl_arbitration_low_cap:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_vlarbitration_low_cap [64 bits] */

/* CSR automated type for IBU_P{1,2}_MTUCAP */
struct psif_csr_ibu_mtucap {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RO reset = 0x5
	 Vol 1 Table 146. Max MTU supported by this port.
	 */
	u32	mtu_cap:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_mtucap [64 bits] */

/* CSR automated type for IBU_P{1,2}_OPERATIONAL_VLS */
struct psif_csr_ibu_operational_vls {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0x0
	 ....., defined in IB spec.
	 */
	u32	operational_vls:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_operational_vls [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_RCV_ERROR */
struct psif_csr_ibu_pcport_rcv_error {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Volume 1 table 228: PortRcvError. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes.
	 */
	u16	pc_port_rcv_error; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_rcv_error [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_RCV_REMOTE_PHYSICAL_ERRORS */
struct psif_csr_ibu_pcport_rcv_remote_physical_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Volume 1 table 228: PortRcvRemotePhysicalErrors. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes.
	 */
	u16	pc_port_rcv_remote_physical_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_rcv_remote_physical_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_DISCARDS */
struct psif_csr_ibu_pcport_xmit_discards {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Volume 1 table 228: PortXmitDiscards
	 */
	u16	pc_port_xmit_discards; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_discards [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCLOCAL_LINK_INTEGRITY_ERRORS */
struct psif_csr_ibu_pclocal_link_integrity_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RO reset = 0x0
	 Volume 1 table 228: LocalLinkIntegrityErrors counter. Also see LocalPhyErrors register addr x12e.
	 */
	u32	pc_local_link_integrity_errors:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pclocal_link_integrity_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCEXCESSIVE_BUFFER_OVERRUN_ERRORS */
struct psif_csr_ibu_pcexcessive_buffer_overrun_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RO reset = 0x0
	 Volume 1 table 228: ExcessiveBufferOverrunErrors counter. Also see OverrunErrors register addr x12f.
	 */
	u32	pc_excessive_buffer_overrun_errors:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcexcessive_buffer_overrun_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVL15_DROPPED */
struct psif_csr_ibu_pcvl15_dropped {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Volume 1 table 228: VL15Dropped. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes.
	 */
	u16	pc_vl15_dropped; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvl15_dropped [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT */
struct psif_csr_ibu_pcport_xmit_wait {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 228: PortXmitWait. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_DATA_LSQW */
struct psif_csr_ibu_pcport_xmit_data_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 228: PortXmitata 32bit count. With count greater than 32'hffffffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_data_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_ERROR_CHECK_ENABLE */
struct psif_csr_ibu_link_error_check_enable {
	/* *** 64 bit group 0 start *** */
	/* bit[31:10] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:22; /* 22 bits @ offs 0:0 */
	/* bit[9] RW reset = 0x0
	 IBTA Volume Sec 7.4 Data Packet Check: Valid LRH dlid.
	 */
	u32	dlid_chken:1; /* 1 bits @ offs 0:22 */
	/* bit[8] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: ICRC check.
	 */
	u32	icrc_chken:1; /* 1 bits @ offs 0:23 */
	/* bit[7] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: VCRC check.
	 */
	u32	vcrc_chken:1; /* 1 bits @ offs 0:24 */
	/* bit[6] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: Valid LRH LEN.
	 */
	u32	len_chken:1; /* 1 bits @ offs 0:25 */
	/* bit[5] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: Valid LRH lver.
	 */
	u32	lver_chken:1; /* 1 bits @ offs 0:26 */
	/* bit[4] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: Valid LRH virtual lane.
	 */
	u32	vl_chken:1; /* 1 bits @ offs 0:27 */
	/* bit[3] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: Valid VL15.
	 */
	u32	vl15_chken:1; /* 1 bits @ offs 0:28 */
	/* bit[2] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: VL15 fifo has enough space to fit latest Rx vl15 pkt.
	 */
	u32	vl15buf_chken:1; /* 1 bits @ offs 0:29 */
	/* bit[1] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: VL0-7 fifo has space to fit latest Rx vl0-7 pkt.
	 */
	u32	vlxbuf_chken:1; /* 1 bits @ offs 0:30 */
	/* bit[0] RW reset = 0x1
	 IBTA Volume Sec 7.4 Data Packet Check: Control in Packet.
	 */
	u32	cinpk_chken:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_error_check_enable [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_RCV_DATA_LSQW */
struct psif_csr_ibu_pcport_rcv_data_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 228: PortRcvData 32bit count. With count greater than 32'hffffffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_rcv_data_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_PKTS_LSQW */
struct psif_csr_ibu_pcport_xmit_pkts_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 228: PortXmitPkts 32bit count. With count greater than 32'hffffffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_pkts_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_RCV_PKTS_LSQW */
struct psif_csr_ibu_pcport_rcv_pkts_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 228: PortRcvPkts 32bit count. With count greater than 32'hffffffff, counter flags overflow with 8'hff on all bytes
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_rcv_pkts_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_UCXMIT_PKTS_LSQW */
struct psif_csr_ibu_pcport_ucxmit_pkts_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Optional counter currently not supported: Port Counter, Port UniCast Xmit Pkts
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_ucxmit_pkts_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_MCXMIT_PKTS_LSQW */
struct psif_csr_ibu_pcport_mcxmit_pkts_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Optional counter currently not supported: Port Counter, Port MultiCast Xmit Pkts
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_mcxmit_pkts_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_UCRCV_PKTS_LSQW */
struct psif_csr_ibu_pcport_ucrcv_pkts_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Optional: Port Counter, Port UniCast Rcv Pkts. With count greater than 32'hFFFFFFFF, counter flags overflow with 8'hff on all bytes
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_ucrcv_pkts_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_MCRCV_PKTS_LSQW */
struct psif_csr_ibu_pcport_mcrcv_pkts_lsqw {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Optional: Port Counter, Port MultiCast Rcv Pkts. With count greater than 32'hFFFFFFFF, counter flags overflow with 8'hff on all bytes
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_mcrcv_pkts_lsqw [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL0 */
struct psif_csr_ibu_pcport_xmit_wait_vl0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL0. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL1 */
struct psif_csr_ibu_pcport_xmit_wait_vl1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL1. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL2 */
struct psif_csr_ibu_pcport_xmit_wait_vl2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL2. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL3 */
struct psif_csr_ibu_pcport_xmit_wait_vl3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL3. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL4 */
struct psif_csr_ibu_pcport_xmit_wait_vl4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL4. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL5 */
struct psif_csr_ibu_pcport_xmit_wait_vl5 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL5. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl5 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL6 */
struct psif_csr_ibu_pcport_xmit_wait_vl6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL6. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL7 */
struct psif_csr_ibu_pcport_xmit_wait_vl7 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL7. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl7 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCPORT_XMIT_WAIT_VL15 */
struct psif_csr_ibu_pcport_xmit_wait_vl15 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Optional: Volume 1 table 228: PortXmitWait for VL15. With count greater than 16'hffff, counter flags overflow with 8'hff on all bytes. For counter load and reset see PCTxLinkCntRst PCTxLinkCntLoad.
	 */
	u16	pc_portxmitwait; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcport_xmit_wait_vl15 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_LINK_CNT_RST */
struct psif_csr_ibu_pcrx_link_cnt_rst {
	/* *** 64 bit group 0 start *** */
	/* bit[31:19] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:13; /* 13 bits @ offs 0:0 */
	/* bit[18:0] WO reset = 0x0
	 Volume 1 table 228: CounterSelect: 
	 Bit 0 : Reset PCPortRcvErrors 
	 Bit 1 : Reset PCPortRcvRemotePhysicalErrors 
	 Bit 2 : Reset PCPortRcvFCErrors 
	 Bit 3 : Reset PCPortRcvConstraintErrors 
	 Bit 4 : Reset LocalLinkIntegrityErrors 
	 Bit 5 : Reset ExcessiveBufferOverrunErrors 
	 Bit 6 : Reset VL15Dropped 
	 Bit 7 : Reset PCPortRcvData 
	 Bit 8 : Reset PCPortRcvPkts 
	 Bit 9 : Reset PCPortUCRcvPkts 
	 Bit 10 : Reset PCPortMCRcvPkts 
	 bit 12 : Reset PCVcrcRcvErrors 
	 bit 13 : Reset PCIcrcRcvErrors 
	 bit 14 : Reset PCLenRcvErrors 
	 bit 15 : Reset PCDlidRcvErrors 
	 bit 16 : Reset PCBufOverErrors 
	 bit 17 : Reset PCMalFormedErrors 
	 bit 18 : Reset PCPortLocalPhyErrors 
	 */
	u32	pc_rx_link_cnt_rst:19; /* 19 bits @ offs 0:13 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_link_cnt_rst [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_LINK_CNT_LOAD */
struct psif_csr_ibu_pcrx_link_cnt_load {
	/* *** 64 bit group 0 start *** */
	/* bit[31:19] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:13; /* 13 bits @ offs 0:0 */
	/* bit[18:0] WO reset = 0x0
	 Volume 1 table 228: CounterSelect: Loadable value is as indicated per counter 
	 Bit 0 : Reset PortRcvErrors 
	 Bit 1 : Reset PortRcvRemotePhysicalErrors 
	 Bit 2 : Reset PortRcvFCCrcErrors, PortRcvFCLenErrors, PortRcvFCVlErrors 
	 Bit 3 : Reset PortRcvConstraintErrors 
	 Bit 4 : Reset LocalLinkIntegrityErrors 
	 Bit 5 : Reset ExcessiveBufferOverrunErrors 
	 Bit 6 : Reset VL15Dropped 
	 Bit 7 : Reset PCPortRcvData 
	 Bit 8 : Reset PCPortRcvPkts 
	 Bit 9 : Reset PCPortUCRcvPkts 
	 Bit 10 : Reset PCPortMCRcvPkts 
	 bit 12 : Reset PCVcrcRcvErrors 
	 bit 13 : Reset PCIcrcRcvErrors 
	 bit 14 : Reset PCLenRcvErrors 
	 bit 15 : Reset PCDlidRcvErrors 
	 bit 16 : Reset PCBufOverErrors 
	 bit 17 : Reset PCMalFormedErrors 
	 bit 18 : Reset PortLocalPhyErrors.
	 */
	u32	pc_rx_link_cnt_load:19; /* 19 bits @ offs 0:13 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_link_cnt_load [64 bits] */

/* CSR automated type for IBU_P{1,2}_LOCAL_PHY_ERRORS */
struct psif_csr_ibu_local_phy_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0xa
	 Volume 1: table 146 LocalPhyErrors. Table 228 and 7.12.1: LocalLinkIntegrityError threshold. Local physical errors count exceeding this LocalPhyErrors threshold causes a link retrain and increment of the link integrity error counter (PCLocalLinkIntegrityErrors counter) addr=x10f.
	 */
	u32	locak_phy_errors:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_local_phy_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_OVERRUN_ERRORS */
struct psif_csr_ibu_overrun_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:4] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[3:0] RW reset = 0xa
	 Volume 1: table 228 and 7.12.1: ExcessiveBufferOverrunErrors threshold. Buffer overrun error count exceeding this threshold causes a link retrain and increment of the PCExcessiveBufferOverrunErrors couner addr=x110.
	 */
	u32	pc_excess_buff_over_err_thrsh:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_overrun_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSLINK_DLID */
struct psif_csr_ibu_pslink_dlid {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] WO reset = 0x0
	 DLID specification 
	 Used to count packets with specified DLID. 
	 Currently not supported in PSIF. 
	 */
	u16	ps_link_dlid; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pslink_dlid [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSTICK */
struct psif_csr_ibu_pstick {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x0
	 Ref. Volume 1, Table 225 PortSamplesControl. The Tick register is defined as Read Only. But to support debug some values are writable, and valid values are as follows : 
	 h7 : 8 symbol times 
	 hF : 16 symbol times 
	 h3F: 64 symbol times (default) 
	 Write to any other value will select the defualt value (64 symbol times) 
	 */
	u32	ps_tick:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pstick [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSSTATUS */
struct psif_csr_ibu_psstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:2] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:30; /* 30 bits @ offs 0:0 */
	/* bit[1:0] RO reset = 0x0
	 Sample Status Ref. Volume 1 Table 225. 0=Sampling complete. 
	 1=Start timer running. 2=Sampling. 3=Reserved.
	 */
	u32	ps_status:2; /* 2 bits @ offs 0:30 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_psstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSSTART_DELAY */
struct psif_csr_ibu_psstart_delay {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 Volume 1 table 225. Sampling start delay
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_psstart_delay [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSINTERVAL */
struct psif_csr_ibu_psinterval {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 Volume 1 table 225. Sampling interval
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_psinterval [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_SEL0 */
struct psif_csr_ibu_pscnt_sel0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Volume 1 table 225. Select values (from IB spec); 16'h0001 : PortXmitData; 16'h0002 : PortRcvData; 16'h0003 : PortXmitPkt; 16'h0004 : PortRcvPkt
	 */
	u16	ps_cnt_sel0; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_sel0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_SEL1 */
struct psif_csr_ibu_pscnt_sel1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Volume 1 table 225. Select values as defined in PSCntSel0.
	 */
	u16	ps_cnt_sel1; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_sel1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_SEL2 */
struct psif_csr_ibu_pscnt_sel2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Volume 1 table 225. Select values as defined in PSCntSel0.
	 */
	u16	ps_cnt_sel2; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_sel2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_SEL3 */
struct psif_csr_ibu_pscnt_sel3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Volume 1 table 225. Select values as defined in PSCntSel0.
	 */
	u16	ps_cnt_sel3; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_sel3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT0 */
struct psif_csr_ibu_pscnt0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 227. Performance sampling counter 0 value
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT1 */
struct psif_csr_ibu_pscnt1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 227. Performance sampling counter 1 value
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT2 */
struct psif_csr_ibu_pscnt2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 227. Performance sampling counter 2 value
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT3 */
struct psif_csr_ibu_pscnt3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Volume 1 table 227. Performance sampling counter 3 value
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSINIT_SAMPLING */
struct psif_csr_ibu_psinit_sampling {
	/* *** 64 bit group 0 start *** */
	/* bit[31:1] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[0] WO reset = 0x0
	 Volume 1 table 225 SampleStart. Reads 0. Write: Start Port Performance Sampling
	 */
	u32	psinitsampling:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_psinit_sampling [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_LOAD */
struct psif_csr_ibu_pscnt_load {
	/* *** 64 bit group 0 start *** */
	/* bit[31:1] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[0] WO reset = 0x0
	 Always reads 0. Write to load value to (maximum value - 8) 
	 */
	u32	pscntload:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_load [64 bits] */

/* CSR automated type for IBU_P{1,2}_PORT_STATE_CHANGE */
struct psif_csr_ibu_port_state_change {
	/* *** 64 bit group 0 start *** */
	/* bit[31:1] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[0] RW reset = 0x0
	 Port state has chenged. Vol 1 Table 143. Flags transitions from Down to Initialize, Initialize to Down, Armed to Down, or Active to Down as a result of link state machine logic.
	 */
	u32	port_state_change:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_port_state_change [64 bits] */

/* CSR automated type for IBU_P{1,2}_TRAP_REGISTER */
struct psif_csr_ibu_trap_register {
	/* *** 64 bit group 0 start *** */
	/* bit[31:7] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:25; /* 25 bits @ offs 0:0 */
	/* bit[6:0] RW reset = 0x0
	 Trap register
	 */
	u32	trap_register:7; /* 7 bits @ offs 0:25 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_trap_register [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_VCONFIG0 */
struct psif_csr_ibu_link_vconfig0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x840
	 Bit 0: ?link_vconf_portloopen Enable port loopback 
	 Bit 6-1: ?link_vconf_fcthresh Threshold value for fc tx based on received blocks[64B] [0=disable] 
	 Bit 7: ?link_vconf_fcipskip Skip Flow control interval prescaler (8 bit) => timeout ~6.2us 
	 Bit 15-8: ?link_vconf_fcinterval Flow control xmit interval in us (1 eq aprx 1024ns) [0=disable] 
	 */
	u16	link_vconfig0; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_vconfig0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_VCONFIG1 */
struct psif_csr_ibu_link_vconfig1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x400c
	 Bit 3-0: ?link_vconf_fcbufthresh Threshold value for fc tx based rx buffer space [0=disable] 
	 Bit 4: ?link_vconf_porti2arm Force automatic transition of port state from init to arm. 
	 Bit 5: ?link_vconf_portnfrwdinarm Inhibit data xmit in arm 
	 Bit 6: ?link_vconf_rx_rawpkt Enable inbound raw packet enforcement 
	 Bit 7: ?link_vconf_tx_rawpkt Enable outbound raw packet Bit 8: cr_minus_1_opt 
	 Bit 9: lock_ps_dout 
	 Bit 10: lock_pc_dout 
	 Bit 11: link_vconf_dis_retrain Disable retrain caused by link layer error [Test purpose only] 
	 Bit 12: link_vconf_rx_nov15lchk Disable VL15 length check (48h) 
	 Bit 13: EDR Max Packet Rate: Request remote Tx to limit use transmitssion of pkts. to no more than one packet every 64 bytes. 
	 Bit 14: EDR Max Packet Rate: When cleared, IBU Tx will always limit transmission of pkts. to no more than one packet every 64 bytes regardless of remote Rx capability. When set, IBU Tx will use the Rx TS3 mpr value to decide the max packet rate: rx_ts3_mpr=1: allows transmission of back-to-back 64 byte packets. rx_ts3_mpr=0 limits IBU Tx to no more than one packet every 64 bytes. 
	 Bit 15: Reserved 
	 */
	u16	link_vconfig1; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_vconfig1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_VCONFIG2 */
struct psif_csr_ibu_link_vconfig2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Bit 0: Disable Tx eop fc packing 
	 Bit 1: Load/read sram Rx trace addr 
	 Bit 13-2: Sram Rx trace addr 
	 Bit 14: acttr_vl15 
	 Bit 15: Unused 
	 */
	u16	link_vconfig2; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_vconfig2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_CREDIT_VL1_0 */
struct psif_csr_ibu_link_rx_credit_vl1_0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-29 : 0 
	 Bit 28-16 : Rx credit VL1 
	 Bit 15-12 : 0 
	 Bit 11-0 : Rx credit VL0 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_credit_vl1_0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_CREDIT_VL3_2 */
struct psif_csr_ibu_link_rx_credit_vl3_2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-29 : 0 
	 Bit 28-16 : Rx credit VL3 
	 Bit 15-12 : 0 
	 Bit 11-0 : Rx credit VL2
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_credit_vl3_2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_CREDIT_VL5_4 */
struct psif_csr_ibu_link_rx_credit_vl5_4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-29 : 0 
	 Bit 28-16 : Rx credit VL5 
	 Bit 15-12 : 0 
	 Bit 11-0 : Rx credit VL4
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_credit_vl5_4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_CREDIT_VL7_6 */
struct psif_csr_ibu_link_rx_credit_vl7_6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-29 : 0 
	 Bit 28-16 : Rx credit VL7 
	 Bit 15-12 : 0 
	 Bit 11-0 : Rx credit VL6
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_credit_vl7_6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_TX_CREDIT_VL1_0 */
struct psif_csr_ibu_link_tx_credit_vl1_0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Tx credit VL1 
	 Bit 15-12 : 0 
	 Bit 11-0 : Tx credit VL0 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_tx_credit_vl1_0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_TX_CREDIT_VL3_2 */
struct psif_csr_ibu_link_tx_credit_vl3_2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Tx credit VL3 
	 Bit 15-12 : 0 
	 Bit 11-0 : Tx credit VL2 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_tx_credit_vl3_2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_TX_CREDIT_VL5_4 */
struct psif_csr_ibu_link_tx_credit_vl5_4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Tx credit VL5 
	 Bit 15-12 : 0 
	 Bit 11-0 : Tx credit VL4 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_tx_credit_vl5_4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_TX_CREDIT_VL7_6 */
struct psif_csr_ibu_link_tx_credit_vl7_6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Tx credit VL7 
	 Bit 15-12 : 0 
	 Bit 11-0 : Tx credit VL6 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_tx_credit_vl7_6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCTX_LINK_CNT_RST */
struct psif_csr_ibu_pctx_link_cnt_rst {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] WO reset = 0x0
	 Volume 1 table 228: CounterSelect: 
	 Bit 0 : Reset PCPortXmitWait 
	 Bit 1 : Reset PCPortXmitDiscards 
	 Bit 2 : Reset PortXmitConstraintErrors 
	 Bit 3 : Reset PCPortXmitData 
	 Bit 4 : Reset PCPortXmitPkts 
	 Bit 5 : Reset PCPortUCRcvPkts 
	 Bit 6 : Reset PCPortMCRcvPkts 
	 Bit 14:7 : Reset PortVLXmitWait[7:0] 
	 Bit 15 : Reset PortVLXmitWait[15]
	 */
	u16	pc_tx_link_cnt_rst; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pctx_link_cnt_rst [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCTX_LINK_CNT_LOAD */
struct psif_csr_ibu_pctx_link_cnt_load {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] WO reset = 0x0
	 Volume 1 table 228: CounterSelect: Loadable value is as indicated per counter 
	 Bit 0 : Reset PCPortXmitWait 
	 Bit 1 : Reset PCPortXmitDiscards 
	 Bit 2 : Reset PortXmitConstraintErrors 
	 Bit 3 : Reset PCPortXmitData 
	 Bit 4 : Reset PCPortXmitPkts 
	 Bit 5 : Reset PCPortUCRcvPkts 
	 Bit 6 : Reset PCPortMCRcvPkts 
	 Bit 14:7 : Reset PortVLXmitWait[7:0] 
	 Bit 15 : Reset PortVLXmitWait[15]
	 */
	u16	pc_tx_link_cnt_load; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pctx_link_cnt_load [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_WIDTH */
struct psif_csr_ibu_pscnt_width {
	/* *** 64 bit group 0 start *** */
	/* bit[31:3] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:29; /* 29 bits @ offs 0:0 */
	/* bit[2:0] RO reset = 0x11
	 Volume 1, Table 225 PortSamplesControl CounterWidth: 3 = 32 bits
	 */
	u32	ps_cnt_width:3; /* 3 bits @ offs 0:29 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_width [64 bits] */

/* CSR automated type for IBU_P{1,2}_PSCNT_MASK */
struct psif_csr_ibu_pscnt_mask {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:9] RO reset = 0x1
	 Volume 1, Table 225 PortSamplesControl CounterMask1to9: optional counter3 : 1 = Supports Mandatory quantities
	 */
	u32	ps_cnt_mask3:3; /* 3 bits @ offs 0:20 */
	/* bit[8:6] RO reset = 0x1
	 Volume 1, Table 225 PortSamplesControl CounterMask1to9: optional counter2 : 1 = Supports Mandatory quantities
	 */
	u32	ps_cnt_mask2:3; /* 3 bits @ offs 0:23 */
	/* bit[5:3] RO reset = 0x1
	 Volume 1, Table 225 PortSamplesControl CounterMask1to9: optional counter1 : 1 = Supports Mandatory quantities
	 */
	u32	ps_cnt_mask1:3; /* 3 bits @ offs 0:26 */
	/* bit[2:0] RO reset = 0x1
	 Volume 1, Table 225 PortSamplesControl CounterMask0: 1 = Supports Mandatory quantities
	 */
	u32	ps_cnt_mask0:3; /* 3 bits @ offs 0:29 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pscnt_mask [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCICRC_RCV_ERRORS */
struct psif_csr_ibu_pcicrc_rcv_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx data packets failing for icrc errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_icrc_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcicrc_rcv_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVCRC_RCV_ERRORS */
struct psif_csr_ibu_pcvcrc_rcv_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx data packets failing for vcrc errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_vcrc_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvcrc_rcv_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCLEN_RCV_ERRORS */
struct psif_csr_ibu_pclen_rcv_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx data packets failing for length errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_len_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pclen_rcv_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCDLID_RCV_ERRORS */
struct psif_csr_ibu_pcdlid_rcv_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx data packets failing for DLID mismatch errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_dlid_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcdlid_rcv_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRCV_FCLEN_ERRORS */
struct psif_csr_ibu_pcrcv_fclen_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx link packets failing for length errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_fclen_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrcv_fclen_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRCV_FCVL_ERRORS */
struct psif_csr_ibu_pcrcv_fcvl_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx link packets failing for VL mismatch errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_fcvl_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrcv_fcvl_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRCV_FCCRC_ERRORS */
struct psif_csr_ibu_pcrcv_fccrc_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 sec 7.5 : Count of all Rx link packets failing for crc errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_fccrc_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrcv_fccrc_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PORT_LOCAL_PHYSICAL_ERRORS */
struct psif_csr_ibu_port_local_physical_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 Table 226: PortLocalPhysicalErrors : Count of all Rx packets failing for crc and phy errors. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_phy_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_port_local_physical_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCMAL_FORMED_ERRORS */
struct psif_csr_ibu_pcmal_formed_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 Table 226: PortMalformedPacketErrors : Count of all Rx data packets failing for lver, len and vl errors and link packets failing for op, vl and len. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_malformed_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcmal_formed_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCBUF_OVER_ERRORS */
struct psif_csr_ibu_pcbuf_over_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 Table 226: PortBufferOverrunErrors : Count of all Rx data packets discarded due to lack of buffer space. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_buf_overrun_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcbuf_over_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVLMAP_ERRORS */
struct psif_csr_ibu_pcvlmap_errors {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Vol 1 Table 226: PortVLMapErrors : Count of all Rx data packets discarded due VL mapping mismatch. For counter load and reset see PCRxLinkCntLoad PCRxLinkCntRst.
	 */
	u16	pc_rx_vl_map_errors; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvlmap_errors [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVLINIT_CREDIT_VL1_VL0 */
struct psif_csr_ibu_pcvlinit_credit_vl1_vl0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x-3a
	 Bits [23:16]: Rx credits allocated to VL1.
	 */
	u16	pc_vl_init_credit_vl1:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x-3a
	 Bits [7:0]: Rx credits allocated to VL0.
	 */
	u16	pc_vl_init_credit_vl0:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvlinit_credit_vl1_vl0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVLINIT_CREDIT_VL3_VL2 */
struct psif_csr_ibu_pcvlinit_credit_vl3_vl2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x-3a
	 Bits [23:16]: Rx credits allocated to VL3.
	 */
	u16	pc_vl_init_credit_vl3:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x-3a
	 Bits [7:0]: Rx credits allocated to VL2.
	 */
	u16	pc_vl_init_credit_vl2:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvlinit_credit_vl3_vl2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVLINIT_CREDIT_VL5_VL4 */
struct psif_csr_ibu_pcvlinit_credit_vl5_vl4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x-3a
	 Bits [23:16]: Rx credits allocated to VL5.
	 */
	u16	pc_vl_init_credit_vl5:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x-3a
	 Bits [7:0]: Rx credits allocated to VL4.
	 */
	u16	pc_vl_init_credit_vl4:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvlinit_credit_vl5_vl4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCVLINIT_CREDIT_VL7_VL6 */
struct psif_csr_ibu_pcvlinit_credit_vl7_vl6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x-3a
	 Bits [23:16]: Rx credits allocated to VL7.
	 */
	u16	pc_vl_init_credit_vl7:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x-3a
	 Bits [7:0]: Rx credits allocated to VL6.
	 */
	u16	pc_vl_init_credit_vl6:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcvlinit_credit_vl7_vl6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_VL07_ECC_COR_ERR_CNT */
struct psif_csr_ibu_pcrx_vl07_ecc_cor_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Rx link VL0-VL7 buffer ecc correctable errors.
	 */
	u16	pc_vl07_ecc_cor_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_vl07_ecc_cor_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_VL07_ECC_UNC_ERR_CNT */
struct psif_csr_ibu_pcrx_vl07_ecc_unc_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Rx link VL0-VL7 buffer ecc un-correctable errors.
	 */
	u16	pc_vl07_ecc_unc_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_vl07_ecc_unc_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_VL15_ECC_COR_ERR_CNT */
struct psif_csr_ibu_pcrx_vl15_ecc_cor_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Rx link VL15 buffer ecc correctable errors.
	 */
	u16	pc_vl15_ecc_cor_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_vl15_ecc_cor_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_VL15_ECC_UNC_ERR_CNT */
struct psif_csr_ibu_pcrx_vl15_ecc_unc_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Rx link VL15 buffer ecc un-correctable errors.
	 */
	u16	pc_vl15_ecc_unc_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_vl15_ecc_unc_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_LOOP_ECC_COR_ERR_CNT */
struct psif_csr_ibu_pcrx_loop_ecc_cor_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Rx link Loopback buffer ecc correctable errors.
	 */
	u16	pc_loop_ecc_cor_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_loop_ecc_cor_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCRX_LOOP_ECC_UNC_ERR_CNT */
struct psif_csr_ibu_pcrx_loop_ecc_unc_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Rx link loopback buffer ecc un-correctable errors.
	 */
	u16	pc_loop_ecc_unc_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pcrx_loop_ecc_unc_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCECCENA_ERR */
struct psif_csr_ibu_pceccena_err {
	/* *** 64 bit group 0 start *** */
	/* bit[31:6] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:26; /* 26 bits @ offs 0:0 */
	/* bit[5:0] RW reset = 0x0
	 ECC Error checking enable/disable/force: [1:0]: 2'b00: Mission mode ecc error checking on Rx fifos. 2'b01: Force ecc correctable errors on Rx fifos 2'b10: Force ecc un-correctable errors on Rx fifos. 2'b11: Disable ecc error checking on Rx fifos. [3:2]: 2'b00: Mission mode ecc error checking on loopback fifo. 2'b01: Force ecc correctable errors on loopback fifo. 2'b10: Force ecc un-correctable errors on loopback fifo. 2'b11: Disable ecc error checking on loopback fifo. [5:4]: 2'b00: Mission mode ecc error checking on Tx fifo. 2'b01: Force ecc correctable errors on Tx fifo. 2'b10: Force ecc un-correctable errors on Tx fifo. 2'b11: Disable ecc error checking on Tx fifo. 
	 */
	u32	pc_ecc_ena_err:6; /* 6 bits @ offs 0:26 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pceccena_err [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCTX_ECC_COR_ERR_CNT */
struct psif_csr_ibu_pctx_ecc_cor_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Tx link buffer ecc correctable errors.
	 */
	u16	pc_tx_ecc_cor_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pctx_ecc_cor_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_PCTX_ECC_UNC_ERR_CNT */
struct psif_csr_ibu_pctx_ecc_unc_err_cnt {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0x0
	 Count of Tx link buffer ecc un-correctable errors.
	 */
	u16	pc_tx_ecc_unc_err_cnt; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pctx_ecc_unc_err_cnt [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_SRAMSTATUS */
struct psif_csr_ibu_tx_sramstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:22] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:10; /* 10 bits @ offs 0:0 */
	/* bit[21:13] RO reset = 0x0
	 Tx FIFO SRAM write address.
	 */
	u32	pc_tx_sram_write_addr:9; /* 9 bits @ offs 0:10 */
	/* bit[12:4] RO reset = 0x0
	 Tx FIFO SRAM read address.
	 */
	u32	pc_tx_sram_read_addr:9; /* 9 bits @ offs 0:19 */
	/* bit[3:0] RO reset = 0x0
	 Tx FIFO SRAM unload state machine state.
	 */
	u32	pc_tx_sram_unload_sm:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_sramstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_CACHE_STATUS */
struct psif_csr_ibu_tx_cache_status {
	/* *** 64 bit group 0 start *** */
	/* bit[31:14] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:18; /* 18 bits @ offs 0:0 */
	/* bit[13:11] RO reset = 0x0
	 256 bit, Tx cache fifo read address.
	 */
	u32	tx_256b_cache_fifo_read_addr:3; /* 3 bits @ offs 0:18 */
	/* bit[10:8] RO reset = 0x0
	 256 bit, Tx cache fifo write address.
	 */
	u32	tx_256b_cache_fifo_write_addr:3; /* 3 bits @ offs 0:21 */
	/* bit[7:4] RO reset = 0x0
	 64 bit, Tx cache fifo read address.
	 */
	u32	tx_64b_cache_fifo_read_addr:4; /* 4 bits @ offs 0:24 */
	/* bit[3:0] RO reset = 0x0
	 64 bit, Tx cache fifo write address.
	 */
	u32	tx_64b_cache_fifo_write_addr:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_cache_status [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_DEBUG */
struct psif_csr_ibu_tx_debug {
	/* *** 64 bit group 0 start *** */
	/* bit[31:30] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:2; /* 2 bits @ offs 0:0 */
	/* bit[29:26] RO reset = 0x0
	 Tx state machine for 256bit pipeline.
	 */
	u32	tx_256b_state_machine:4; /* 4 bits @ offs 0:2 */
	/* bit[25:22] RO reset = 0x0
	 Tx state machine for 64bit pipeline.
	 */
	u32	tx_64b_state_machine:4; /* 4 bits @ offs 0:6 */
	/* bit[21:18] RO reset = 0x0
	 Tx arbiter state machine.
	 */
	u32	tx_arbiter_sm_state:4; /* 4 bits @ offs 0:10 */
	/* bit[17:9] RO reset = 0x0
	 Tx arbiter read address for vl07, VL15 data.
	 */
	u32	tx_arbiter_read_addr:9; /* 9 bits @ offs 0:14 */
	/* bit[8:0] RO reset = 0x0
	 Tx arbiter write address for VL07, VL15 data.
	 */
	u32	tx_arbiter_write_addr:9; /* 9 bits @ offs 0:23 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_debug [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_VL07_SRAMSTATUS */
struct psif_csr_ibu_rx_vl07_sramstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:30] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:2; /* 2 bits @ offs 0:0 */
	/* bit[29:27] RO reset = 0x0
	 rx vl07 cache read addr.
	 */
	u32	rx_cache_vl07_read_addr:3; /* 3 bits @ offs 0:2 */
	/* bit[26:24] RO reset = 0x0
	 rx vl07 cache write addr.
	 */
	u32	rx_cache_vl07_write_addr:3; /* 3 bits @ offs 0:5 */
	/* bit[23:12] RO reset = 0x0
	 rx vl07 sram read addr.
	 */
	u32	rx_sram_vl07_read_addr:12; /* 12 bits @ offs 0:8 */
	/* bit[11:0] RO reset = 0x0
	 rx vl07 sram write addr.
	 */
	u32	rx_sram_vl07_write_addr:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_vl07_sramstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_VL15_SRAMSTATUS */
struct psif_csr_ibu_rx_vl15_sramstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:20] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:12; /* 12 bits @ offs 0:0 */
	/* bit[19:17] RO reset = 0x0
	 rx vl07 cache read addr.
	 */
	u32	rx_cache_vl07_read_addr:3; /* 3 bits @ offs 0:12 */
	/* bit[16:14] RO reset = 0x0
	 rx vl07 cache write addr.
	 */
	u32	rx_cache_vl07_write_addr:3; /* 3 bits @ offs 0:15 */
	/* bit[13:7] RO reset = 0x0
	 rx vl15 sram read addr.
	 */
	u32	rx_sram_vl15_read_addr:7; /* 7 bits @ offs 0:18 */
	/* bit[6:0] RO reset = 0x0
	 rx vl15 sram write addr.
	 */
	u32	rx_sram_vl15_write_addr:7; /* 7 bits @ offs 0:25 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_vl15_sramstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_LOOPSRAMSTATUS */
struct psif_csr_ibu_loopsramstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:21] RO reset = 0x0
	 loopback cache read addr.
	 */
	u32	loopback_cache_read_addr:3; /* 3 bits @ offs 0:8 */
	/* bit[20:18] RO reset = 0x0
	 loop cache write addr.
	 */
	u32	loopback_cache_write_addr:3; /* 3 bits @ offs 0:11 */
	/* bit[17:9] RO reset = 0x0
	 loopack data sram read addr.
	 */
	u32	loopback_sram_read_addr:9; /* 9 bits @ offs 0:14 */
	/* bit[8:0] RO reset = 0x0
	 loopack data write addr.
	 */
	u32	loopback_sram_write_addr:9; /* 9 bits @ offs 0:23 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_loopsramstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_DEBUG */
struct psif_csr_ibu_rx_debug {
	/* *** 64 bit group 0 start *** */
	/* bit[31:30] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:2; /* 2 bits @ offs 0:0 */
	/* bit[29:26] RO reset = 0x0
	 loopback chace unload state.
	 */
	u16	loopback_cache_unload_state:4; /* 4 bits @ offs 0:2 */
	/* bit[25:24] RO reset = 0x0
	 Loopback sram load state.
	 */
	u16	loopback_sram_load_state:2; /* 2 bits @ offs 0:6 */
	/* bit[23:20] RO reset = 0x0
	 Loopback sram unload state.
	 */
	u16	loopback_sram_unload_state:4; /* 4 bits @ offs 0:8 */
	/* bit[19:16] RO reset = 0x0
	 Rx VL15 chace unload state.
	 */
	u16	rx_vl15_cache_unload_state:4; /* 4 bits @ offs 0:12 */
	/* bit[15:14] RO reset = 0x0
	 Rx VL15 sram load state.
	 */
	u16	rx_vl15_sram_load_state:2; /* 2 bits @ offs 0:16 */
	/* bit[13:10] RO reset = 0x0
	 Rx VL15 sram unload state.
	 */
	u16	rx_vl15_sram_unload_state:4; /* 4 bits @ offs 0:18 */
	/* bit[9:6] RO reset = 0x0
	 Rx VL07 chace unload state.
	 */
	u16	rx_vl07_cache_unload_state:4; /* 4 bits @ offs 0:22 */
	/* bit[5:4] RO reset = 0x0
	 Rx VL07 sram load state.
	 */
	u16	rx_vl07_sram_load_state:2; /* 2 bits @ offs 0:26 */
	/* bit[3:0] RO reset = 0x0
	 Rx VL07 sram unload state.
	 */
	u16	rx_vl07_sram_unload_state:4; /* 4 bits @ offs 0:28 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_debug [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_ARB_LOOPBACK_SRAMSTATUS */
struct psif_csr_ibu_tx_arb_loopback_sramstatus {
	/* *** 64 bit group 0 start *** */
	/* bit[31:18] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:14; /* 14 bits @ offs 0:0 */
	/* bit[17:9] RO reset = 0x0
	 Tx arbitration loopback sram read addr.
	 */
	u32	tx_arb_loopback_sram_read_addr:9; /* 9 bits @ offs 0:14 */
	/* bit[8:0] RO reset = 0x0
	 Tx arbitration loopback sram write addr.
	 */
	u32	tx_arb_loopback_sram_write_addr:9; /* 9 bits @ offs 0:23 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_arb_loopback_sramstatus [64 bits] */

/* CSR automated type for IBU_P{1,2}_VLARB_HI_PRI_TABLE */
struct psif_csr_ibu_vlarb_hi_pri_table {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Write: [3:0]:Unused, [7:4]:VL, [15:8]:Weight. Read: [7:0]:Weight, [11:8]:VL. To Read, use corresponding VLArbLoPriTable CSR address. Weight: each unit is times 16 credits: value of 1=16credits is 16x64=1024bytes
	 */
	u16	vlarbhipritable; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_vlarb_hi_pri_table [64 bits] */

/* CSR automated type for IBU_P{1,2}_VLARB_LO_PRI_TABLE */
struct psif_csr_ibu_vlarb_lo_pri_table {
	/* *** 64 bit group 0 start *** */
	/* bit[31:16] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:16; /* 16 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0x0
	 Write: [3:0]:Unused, [7:4]:VL, [15:8]:Weight. Read: [7:0]:Weight, [11:8]:VL. To Read, use corresponding VLArbHiPriTable CSR address. Weight: each unit is times 16 credits: value of 1=16credits is 16x64=1024bytes
	 */
	u16	vlarblopritable; /* 16 bits @ offs 0:16 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_vlarb_lo_pri_table [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSVL10 */
struct psif_csr_ibu_tx_tbsvl10 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL1 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl1:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL0 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl0:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsvl10 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSVL32 */
struct psif_csr_ibu_tx_tbsvl32 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL3 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl3:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL2 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl2:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsvl32 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSVL54 */
struct psif_csr_ibu_tx_tbsvl54 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL5 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl5:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL4 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl4:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsvl54 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSVL76 */
struct psif_csr_ibu_tx_tbsvl76 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL7 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl7:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL6 Tx TBS total blocks sent to remote node.
	 */
	u16	tx_tbs_vl6:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsvl76 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSARB_VL10 */
struct psif_csr_ibu_tx_tbsarb_vl10 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL1 Tx arbitation TBS.
	 */
	u16	tx_tbs_arb_vl1:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL0 Tx arbitration TBS.
	 */
	u16	tx_tbs_arb_vl0:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsarb_vl10 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSARB_VL32 */
struct psif_csr_ibu_tx_tbsarb_vl32 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL3 Tx arbitation TBS.
	 */
	u16	tx_tbs_arb_vl3:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL2 Tx arbitration TBS.
	 */
	u16	tx_tbs_arb_vl2:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsarb_vl32 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSARB_VL54 */
struct psif_csr_ibu_tx_tbsarb_vl54 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL5 Tx arbitation TBS.
	 */
	u16	tx_tbs_arb_vl5:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL4 Tx arbitration TBS.
	 */
	u16	tx_tbs_arb_vl4:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsarb_vl54 [64 bits] */

/* CSR automated type for IBU_P{1,2}_TX_TBSARB_VL76 */
struct psif_csr_ibu_tx_tbsarb_vl76 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:28] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 0x0
	 DUT VL7 Tx arbitation TBS.
	 */
	u16	tx_tbs_arb_vl7:12; /* 12 bits @ offs 0:4 */
	/* bit[15:12] RO reset = 0x0
	 Always read as zero.
	 */
	u16	:4; /* 4 bits @ offs 0:16 */
	/* bit[11:0] RO reset = 0x0
	 DUT VL6 Tx arbitration TBS.
	 */
	u16	tx_tbs_arb_vl6:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_tx_tbsarb_vl76 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_ENABLE */
struct psif_csr_ibu_rx_trace_capture_enable {
	/* *** 64 bit group 0 start *** */
	/* bit[31:1] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[0] RW reset = 0x0
	 When set, the IBU drops all Rx data packets and uses the Rx fifo to store all Phy Rx trace per trigger mode.
	 */
	u32	csr_rx_trace_capt_ena:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_enable [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_MODE */
struct psif_csr_ibu_rx_trace_capture_mode {
	/* *** 64 bit group 0 start *** */
	/* bit[31:8] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:24; /* 24 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0x0
	 Defines Rx trace capture trigger ... TBD.
	 */
	u32	csr_rx_trace_capt_mode:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_mode [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_RDY */
struct psif_csr_ibu_rx_trace_capture_rdy {
	/* *** 64 bit group 0 start *** */
	/* bit[31:1] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[0] RC reset = 0x0
	 Hardware set when Rx trace is complete. Clears on read.
	 */
	u32	csr_rx_trace_capt_rdy:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_rdy [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_TIMER */
struct psif_csr_ibu_rx_trace_capture_timer {
	/* *** 64 bit group 0 start *** */
	/* bit[31:12] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:20; /* 20 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0x0
	 Delay from trigger to start Rx trace sram store.
	 */
	u32	csr_rx_trace_capt_timer:12; /* 12 bits @ offs 0:20 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_timer [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_START */
struct psif_csr_ibu_rx_trace_capture_start {
	/* *** 64 bit group 0 start *** */
	/* bit[31:1] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[0] RW reset = 0x0
	 Re-start trace.
	 */
	u32	csr_rx_trace_capt_start:1; /* 1 bits @ offs 0:31 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_start [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA1 */
struct psif_csr_ibu_rx_trace_capture_data1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 31:0.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA2 */
struct psif_csr_ibu_rx_trace_capture_data2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 63:32.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA3 */
struct psif_csr_ibu_rx_trace_capture_data3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 95:64.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA4 */
struct psif_csr_ibu_rx_trace_capture_data4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 127:96.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA5 */
struct psif_csr_ibu_rx_trace_capture_data5 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 159:128.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data5 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA6 */
struct psif_csr_ibu_rx_trace_capture_data6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 191:160.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA7 */
struct psif_csr_ibu_rx_trace_capture_data7 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 223:192.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data7 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA8 */
struct psif_csr_ibu_rx_trace_capture_data8 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 255:224.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data8 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA9 */
struct psif_csr_ibu_rx_trace_capture_data9 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 287:256.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data9 [64 bits] */

/* CSR automated type for IBU_P{1,2}_RX_TRACE_CAPTURE_DATA10 */
struct psif_csr_ibu_rx_trace_capture_data10 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Rx trace capture sram data bits 319:288.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_rx_trace_capture_data10 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_FCCL_VL1_0 */
struct psif_csr_ibu_link_rx_fccl_vl1_0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Received FCCL VL1 
	 Bit 15-12 : 0 
	 Bit 11-0 : Received FCCL VL0 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_fccl_vl1_0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_FCCL_VL3_2 */
struct psif_csr_ibu_link_rx_fccl_vl3_2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Received FCCL VL3 
	 Bit 15-12 : 0 
	 Bit 11-0 : Received FCCL VL2 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_fccl_vl3_2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_FCCL_VL5_4 */
struct psif_csr_ibu_link_rx_fccl_vl5_4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Received FCCL VL5 
	 Bit 15-12 : 0 
	 Bit 11-0 : Received FCCL VL4 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_fccl_vl5_4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_LINK_RX_FCCL_VL7_6 */
struct psif_csr_ibu_link_rx_fccl_vl7_6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RO reset = 0x0
	 Bit 31-28 : 0 
	 Bit 27-16 : Received FCCL VL7 
	 Bit 15-12 : 0 
	 Bit 11-0 : Received FCCL VL6 
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_link_rx_fccl_vl7_6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_ADD_DEFAULT_LANE0 */
struct psif_csr_ibu_add_default_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes channel 0 driver de-emphasis pma_dds bits: 
	 Bit 4-0: txc0_fir0[4:0] 
	 Bit 7-3: Currently unused 
	 Bit 10-8: txcn1_fir0[2:0] 
	 Bit 15-11: Currently unused 
	 Bit 19-16: txcp1_fir0[3:0] 
	 Bit 23-20: Currently unused 
	 */
	u32	add_default_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_add_default_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_ADD_DEFAULT_LANE1 */
struct psif_csr_ibu_add_default_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes channel 1 driver de-emphasis pma_dds bits: 
	 Bit 4-0: txc0_fir0[4:0] 
	 Bit 7-3: Currently unused 
	 Bit 10-8: txcn1_fir0[2:0] 
	 Bit 15-11: Currently unused 
	 Bit 19-16: txcp1_fir0[3:0] 
	 Bit 23-20: Currently unused 
	 */
	u32	add_default_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_add_default_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_ADD_DEFAULT_LANE2 */
struct psif_csr_ibu_add_default_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes channel 2 driver de-emphasis pma_dds bits: 
	 Bit 4-0: txc0_fir0[4:0] 
	 Bit 7-3: Currently unused 
	 Bit 10-8: txcn1_fir0[2:0] 
	 Bit 15-11: Currently unused 
	 Bit 19-16: txcp1_fir0[3:0] 
	 Bit 23-20: Currently unused 
	 */
	u32	add_default_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_add_default_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_ADD_DEFAULT_LANE3 */
struct psif_csr_ibu_add_default_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes channel 2 driver de-emphasis pma_dds bits: 
	 Bit 4-0: txc0_fir0[4:0] 
	 Bit 7-3: Currently unused 
	 Bit 10-8: txcn1_fir0[2:0] 
	 Bit 15-11: Currently unused 
	 Bit 19-16: txcp1_fir0[3:0] 
	 Bit 23-20: Currently unused 
	 */
	u32	add_default_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_add_default_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD0_LANE0 */
struct psif_csr_ibu_phy_add0_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_add0_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add0_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD0_LANE1 */
struct psif_csr_ibu_phy_add0_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add0_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add0_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD0_LANE2 */
struct psif_csr_ibu_phy_add0_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add0_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add0_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD0_LANE3 */
struct psif_csr_ibu_phy_add0_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add0_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add0_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD1_LANE0 */
struct psif_csr_ibu_phy_add1_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_add1_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add1_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD1_LANE1 */
struct psif_csr_ibu_phy_add1_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add1_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add1_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD1_LANE2 */
struct psif_csr_ibu_phy_add1_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add1_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add1_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD1_LANE3 */
struct psif_csr_ibu_phy_add1_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add1_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add1_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD2_LANE0 */
struct psif_csr_ibu_phy_add2_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_add2_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add2_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD2_LANE1 */
struct psif_csr_ibu_phy_add2_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add2_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add2_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD2_LANE2 */
struct psif_csr_ibu_phy_add2_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add2_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add2_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD2_LANE3 */
struct psif_csr_ibu_phy_add2_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add2_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add2_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD3_LANE0 */
struct psif_csr_ibu_phy_add3_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_add3_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add3_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD3_LANE1 */
struct psif_csr_ibu_phy_add3_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add3_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add3_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD3_LANE2 */
struct psif_csr_ibu_phy_add3_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add3_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add3_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD3_LANE3 */
struct psif_csr_ibu_phy_add3_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add3_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add3_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD4_LANE0 */
struct psif_csr_ibu_phy_add4_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_add4_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add4_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD4_LANE1 */
struct psif_csr_ibu_phy_add4_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add4_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add4_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD4_LANE2 */
struct psif_csr_ibu_phy_add4_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add4_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add4_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD4_LANE3 */
struct psif_csr_ibu_phy_add4_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add4_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add4_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD5_LANE0 */
struct psif_csr_ibu_phy_add5_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_add5_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add5_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD5_LANE1 */
struct psif_csr_ibu_phy_add5_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add5_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add5_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD5_LANE2 */
struct psif_csr_ibu_phy_add5_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add5_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add5_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD5_LANE3 */
struct psif_csr_ibu_phy_add5_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add5_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add5_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD6_LANE0 */
struct psif_csr_ibu_phy_add6_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bhas 23:0
	 */
	u32	phy_add6_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add6_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD6_LANE1 */
struct psif_csr_ibu_phy_add6_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add6_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add6_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD6_LANE2 */
struct psif_csr_ibu_phy_add6_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add6_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add6_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD6_LANE3 */
struct psif_csr_ibu_phy_add6_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add6_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add6_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD7_LANE0 */
struct psif_csr_ibu_phy_add7_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_add7_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add7_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD7_LANE1 */
struct psif_csr_ibu_phy_add7_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add7_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add7_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD7_LANE2 */
struct psif_csr_ibu_phy_add7_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add7_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add7_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD7_LANE3 */
struct psif_csr_ibu_phy_add7_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add7_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add7_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD8_LANE0 */
struct psif_csr_ibu_phy_add8_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_add8_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add8_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD8_LANE1 */
struct psif_csr_ibu_phy_add8_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add8_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add8_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD8_LANE2 */
struct psif_csr_ibu_phy_add8_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add8_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add8_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD8_LANE3 */
struct psif_csr_ibu_phy_add8_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add8_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add8_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD9_LANE0 */
struct psif_csr_ibu_phy_add9_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_add9_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add9_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD9_LANE1 */
struct psif_csr_ibu_phy_add9_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add9_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add9_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD9_LANE2 */
struct psif_csr_ibu_phy_add9_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add9_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add9_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD9_LANE3 */
struct psif_csr_ibu_phy_add9_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add9_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add9_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD10_LANE0 */
struct psif_csr_ibu_phy_add10_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_add10_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add10_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD10_LANE1 */
struct psif_csr_ibu_phy_add10_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add10_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add10_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD10_LANE2 */
struct psif_csr_ibu_phy_add10_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add10_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add10_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD10_LANE3 */
struct psif_csr_ibu_phy_add10_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add10_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add10_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD11_LANE0 */
struct psif_csr_ibu_phy_add11_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bhas 23:0
	 */
	u32	phy_add11_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add11_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD11_LANE1 */
struct psif_csr_ibu_phy_add11_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add11_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add11_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD11_LANE2 */
struct psif_csr_ibu_phy_add11_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add11_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add11_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD11_LANE3 */
struct psif_csr_ibu_phy_add11_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add11_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add11_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD12_LANE0 */
struct psif_csr_ibu_phy_add12_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bhas 23:0
	 */
	u32	phy_add12_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add12_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD12_LANE1 */
struct psif_csr_ibu_phy_add12_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add12_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add12_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD12_LANE2 */
struct psif_csr_ibu_phy_add12_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add12_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add12_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD12_LANE3 */
struct psif_csr_ibu_phy_add12_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add12_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add12_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD13_LANE0 */
struct psif_csr_ibu_phy_add13_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_add13_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add13_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD13_LANE1 */
struct psif_csr_ibu_phy_add13_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add13_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add13_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD13_LANE2 */
struct psif_csr_ibu_phy_add13_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add13_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add13_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD13_LANE3 */
struct psif_csr_ibu_phy_add13_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add13_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add13_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD14_LANE0 */
struct psif_csr_ibu_phy_add14_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dha bits 23:0
	 */
	u32	phy_add14_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add14_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD14_LANE1 */
struct psif_csr_ibu_phy_add14_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add14_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add14_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD14_LANE2 */
struct psif_csr_ibu_phy_add14_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add14_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add14_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD14_LANE3 */
struct psif_csr_ibu_phy_add14_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add14_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add14_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD15_LANE0 */
struct psif_csr_ibu_phy_add15_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_has bits 23:0
	 */
	u32	phy_add15_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add15_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD15_LANE1 */
struct psif_csr_ibu_phy_add15_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_add15_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add15_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD15_LANE2 */
struct psif_csr_ibu_phy_add15_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_add15_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add15_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_ADD15_LANE3 */
struct psif_csr_ibu_phy_add15_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_add15_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_add15_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD0_LANE0 */
struct psif_csr_ibu_phy_amp1_add0_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_amp1_add0_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add0_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD0_LANE1 */
struct psif_csr_ibu_phy_amp1_add0_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add0_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add0_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD0_LANE2 */
struct psif_csr_ibu_phy_amp1_add0_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add0_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add0_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD0_LANE3 */
struct psif_csr_ibu_phy_amp1_add0_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add0_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add0_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD1_LANE0 */
struct psif_csr_ibu_phy_amp1_add1_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_amp1_add1_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add1_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD1_LANE1 */
struct psif_csr_ibu_phy_amp1_add1_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add1_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add1_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD1_LANE2 */
struct psif_csr_ibu_phy_amp1_add1_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add1_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add1_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD1_LANE3 */
struct psif_csr_ibu_phy_amp1_add1_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add1_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add1_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD2_LANE0 */
struct psif_csr_ibu_phy_amp1_add2_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_amp1_add2_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add2_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD2_LANE1 */
struct psif_csr_ibu_phy_amp1_add2_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add2_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add2_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD2_LANE2 */
struct psif_csr_ibu_phy_amp1_add2_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add2_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add2_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD2_LANE3 */
struct psif_csr_ibu_phy_amp1_add2_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add2_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add2_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD3_LANE0 */
struct psif_csr_ibu_phy_amp1_add3_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_amp1_add3_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add3_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD3_LANE1 */
struct psif_csr_ibu_phy_amp1_add3_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add3_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add3_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD3_LANE2 */
struct psif_csr_ibu_phy_amp1_add3_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add3_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add3_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD3_LANE3 */
struct psif_csr_ibu_phy_amp1_add3_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add3_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add3_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD4_LANE0 */
struct psif_csr_ibu_phy_amp1_add4_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_amp1_add4_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add4_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD4_LANE1 */
struct psif_csr_ibu_phy_amp1_add4_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add4_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add4_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD4_LANE2 */
struct psif_csr_ibu_phy_amp1_add4_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add4_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add4_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD4_LANE3 */
struct psif_csr_ibu_phy_amp1_add4_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add4_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add4_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD5_LANE0 */
struct psif_csr_ibu_phy_amp1_add5_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_amp1_add5_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add5_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD5_LANE1 */
struct psif_csr_ibu_phy_amp1_add5_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add5_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add5_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD5_LANE2 */
struct psif_csr_ibu_phy_amp1_add5_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add5_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add5_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD5_LANE3 */
struct psif_csr_ibu_phy_amp1_add5_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add5_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add5_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD6_LANE0 */
struct psif_csr_ibu_phy_amp1_add6_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bhas 23:0
	 */
	u32	phy_amp1_add6_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add6_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD6_LANE1 */
struct psif_csr_ibu_phy_amp1_add6_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add6_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add6_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD6_LANE2 */
struct psif_csr_ibu_phy_amp1_add6_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add6_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add6_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD6_LANE3 */
struct psif_csr_ibu_phy_amp1_add6_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add6_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add6_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD7_LANE0 */
struct psif_csr_ibu_phy_amp1_add7_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_amp1_add7_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add7_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD7_LANE1 */
struct psif_csr_ibu_phy_amp1_add7_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add7_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add7_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD7_LANE2 */
struct psif_csr_ibu_phy_amp1_add7_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add7_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add7_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD7_LANE3 */
struct psif_csr_ibu_phy_amp1_add7_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add7_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add7_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD8_LANE0 */
struct psif_csr_ibu_phy_amp1_add8_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_amp1_add8_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add8_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD8_LANE1 */
struct psif_csr_ibu_phy_amp1_add8_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add8_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add8_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD8_LANE2 */
struct psif_csr_ibu_phy_amp1_add8_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add8_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add8_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD8_LANE3 */
struct psif_csr_ibu_phy_amp1_add8_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add8_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add8_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD9_LANE0 */
struct psif_csr_ibu_phy_amp1_add9_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_amp1_add9_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add9_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD9_LANE1 */
struct psif_csr_ibu_phy_amp1_add9_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add9_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add9_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD9_LANE2 */
struct psif_csr_ibu_phy_amp1_add9_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add9_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add9_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD9_LANE3 */
struct psif_csr_ibu_phy_amp1_add9_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add9_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add9_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD10_LANE0 */
struct psif_csr_ibu_phy_amp1_add10_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds biha 23:0
	 */
	u32	phy_amp1_add10_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add10_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD10_LANE1 */
struct psif_csr_ibu_phy_amp1_add10_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add10_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add10_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD10_LANE2 */
struct psif_csr_ibu_phy_amp1_add10_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add10_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add10_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD10_LANE3 */
struct psif_csr_ibu_phy_amp1_add10_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add10_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add10_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD11_LANE0 */
struct psif_csr_ibu_phy_amp1_add11_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bhas 23:0
	 */
	u32	phy_amp1_add11_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add11_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD11_LANE1 */
struct psif_csr_ibu_phy_amp1_add11_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add11_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add11_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD11_LANE2 */
struct psif_csr_ibu_phy_amp1_add11_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add11_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add11_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD11_LANE3 */
struct psif_csr_ibu_phy_amp1_add11_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add11_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add11_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD12_LANE0 */
struct psif_csr_ibu_phy_amp1_add12_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bhas 23:0
	 */
	u32	phy_amp1_add12_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add12_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD12_LANE1 */
struct psif_csr_ibu_phy_amp1_add12_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add12_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add12_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD12_LANE2 */
struct psif_csr_ibu_phy_amp1_add12_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add12_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add12_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD12_LANE3 */
struct psif_csr_ibu_phy_amp1_add12_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add12_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add12_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD13_LANE0 */
struct psif_csr_ibu_phy_amp1_add13_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 23:0
	 */
	u32	phy_amp1_add13_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add13_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD13_LANE1 */
struct psif_csr_ibu_phy_amp1_add13_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add13_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add13_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD13_LANE2 */
struct psif_csr_ibu_phy_amp1_add13_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add13_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add13_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD13_LANE3 */
struct psif_csr_ibu_phy_amp1_add13_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add13_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add13_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD14_LANE0 */
struct psif_csr_ibu_phy_amp1_add14_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dha bits 23:0
	 */
	u32	phy_amp1_add14_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add14_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD14_LANE1 */
struct psif_csr_ibu_phy_amp1_add14_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add14_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add14_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD14_LANE2 */
struct psif_csr_ibu_phy_amp1_add14_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add14_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add14_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD14_LANE3 */
struct psif_csr_ibu_phy_amp1_add14_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add14_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add14_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD15_LANE0 */
struct psif_csr_ibu_phy_amp1_add15_lane0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_has bits 23:0
	 */
	u32	phy_amp1_add15_lane0:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add15_lane0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD15_LANE1 */
struct psif_csr_ibu_phy_amp1_add15_lane1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 47:24
	 */
	u32	phy_amp1_add15_lane1:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add15_lane1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD15_LANE2 */
struct psif_csr_ibu_phy_amp1_add15_lane2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 71:48
	 */
	u32	phy_amp1_add15_lane2:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add15_lane2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_PHY_AMP1_ADD15_LANE3 */
struct psif_csr_ibu_phy_amp1_add15_lane3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RO reset = 0x0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:0 */
	/* bit[23:0] RW reset = 0x0
	 TS3 amp=1, Serdes driver de-emphasis pma_dds bits 95:72
	 */
	u32	phy_amp1_add15_lane3:24; /* 24 bits @ offs 0:8 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_phy_amp1_add15_lane3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS0 */
struct psif_csr_ibu_remote_dds0 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 Lane 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds0:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 Lane 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds0:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 Lane 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds0:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 Lane 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds0:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds0 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS1 */
struct psif_csr_ibu_remote_dds1 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds1:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds1:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds1:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds1:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds1 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS2 */
struct psif_csr_ibu_remote_dds2 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds2:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds2:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds2:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds2:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds2 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS3 */
struct psif_csr_ibu_remote_dds3 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds3:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds3:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds3:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds3:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds3 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS4 */
struct psif_csr_ibu_remote_dds4 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds4:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds4:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds4:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds4:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds4 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS5 */
struct psif_csr_ibu_remote_dds5 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds5:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds5:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds5:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds5:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds5 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS6 */
struct psif_csr_ibu_remote_dds6 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds6:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds6:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds6:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds6:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds6 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS7 */
struct psif_csr_ibu_remote_dds7 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds7:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds7:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds7:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds7:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds7 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS8 */
struct psif_csr_ibu_remote_dds8 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds8:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds8:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds8:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds8:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds8 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS9 */
struct psif_csr_ibu_remote_dds9 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds9:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds9:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds9:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds9:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds9 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS10 */
struct psif_csr_ibu_remote_dds10 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds10:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds10:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds10:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds10:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds10 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS11 */
struct psif_csr_ibu_remote_dds11 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds11:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds11:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds11:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds11:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds11 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS12 */
struct psif_csr_ibu_remote_dds12 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds12:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds12:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds12:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds12:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds12 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS13 */
struct psif_csr_ibu_remote_dds13 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds13:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds13:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds13:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds13:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds13 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS14 */
struct psif_csr_ibu_remote_dds14 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds14:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds14:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds14:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds14:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds14 [64 bits] */

/* CSR automated type for IBU_P{1,2}_REMOTE_DDS15 */
struct psif_csr_ibu_remote_dds15 {
	/* *** 64 bit group 0 start *** */
	/* bit[31:24] RW reset = 0x0
	 LANE 3 TS3 settings transmitted to remote node. 31-unused, 30-mod, 29:24-dds
	 */
	u16	remote_lane3_dds15:8; /* 8 bits @ offs 0:0 */
	/* bit[23:16] RW reset = 0x0
	 LANE 2 TS3 settings transmitted to remote node. 23-unused, 22-mod, 21:16-dds
	 */
	u16	remote_lane2_dds15:8; /* 8 bits @ offs 0:8 */
	/* bit[15:8] RW reset = 0x0
	 LANE 1 TS3 settings transmitted to remote node. 15-unused, 14-mod, 13:8-dds
	 */
	u16	remote_lane1_dds15:8; /* 8 bits @ offs 0:16 */
	/* bit[7:0] RW reset = 0x0
	 LANE 0 TS3 settings transmitted to remote node. 7-unused, 6-mod, 5:0-dds
	 */
	u16	remote_lane0_dds15:8; /* 8 bits @ offs 0:24 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_remote_dds15 [64 bits] */

/* CSR automated type for IBU_P{1,2}_BAD_CSR */
struct psif_csr_ibu_bad_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[31:0] RW reset = 0x0
	 Always read as zero.
	 */
	u32	data; /* 32 bits @ offs 0:0 */
	/* 32 bit CSR padding */
	u32	:32; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_bad_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_BAD_CSR */
struct psif_csr_ibu_pma_bad_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 Always read as zero.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_bad_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH0_REG15_CSR */
struct psif_csr_ibu_cetus_ch0_reg15_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 Bit[63:16] Reserved 
	 Bit[15:0] 
	 bit[0] = rxefen_r2a 
	 bit[9:1] = rxspare_r2a[8:0] 
	 bit[10] = Reserved 
	 bit[11] = rx_inv_reg 
	 bit[12] = tx_inv_reg 
	 bit[13] = Reserved 
	 bit[14] = bertok_sel 
	 bit[15] = bert_error_reset 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch0_reg15_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH1_REG15_CSR */
struct psif_csr_ibu_cetus_ch1_reg15_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 Bit[63:16] Reserved 
	 Bit[15:0] 
	 bit[0] = rxefen_r2a 
	 bit[9:1] = rxspare_r2a[8:0] 
	 bit[10] = Reserved 
	 bit[11] = rx_inv_reg 
	 bit[12] = tx_inv_reg 
	 bit[13] = Reserved 
	 bit[14] = bertok_sel 
	 bit[15] = bert_error_reset 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch1_reg15_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH2_REG15_CSR */
struct psif_csr_ibu_cetus_ch2_reg15_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 Bit[63:16] Reserved 
	 Bit[15:0] 
	 bit[0] = rxefen_r2a 
	 bit[9:1] = rxspare_r2a[8:0] 
	 bit[10] = Reserved 
	 bit[11] = rx_inv_reg 
	 bit[12] = tx_inv_reg 
	 bit[13] = Reserved 
	 bit[14] = bertok_sel 
	 bit[15] = bert_error_reset 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch2_reg15_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH3_REG15_CSR */
struct psif_csr_ibu_cetus_ch3_reg15_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 Bit[63:16] Reserved 
	 Bit[15:0] 
	 bit[0] = rxefen_r2a 
	 bit[9:1] = rxspare_r2a[8:0] 
	 bit[10] = Reserved 
	 bit[11] = rx_inv_reg 
	 bit[12] = tx_inv_reg 
	 bit[13] = Reserved 
	 bit[14] = bertok_sel 
	 bit[15] = bert_error_reset 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch3_reg15_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH0_REG102_CSR */
struct psif_csr_ibu_cetus_ch0_reg102_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x7ff
	 Bit[63:16] Reserved 
	 Bit[10:0] channel_override_sel[10:0]: 
	 For each bit, 
	 0 = Use xxxx_pin_override_ci 
	 1 = Use xxxx_pin_override (register) 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch0_reg102_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH1_REG102_CSR */
struct psif_csr_ibu_cetus_ch1_reg102_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x7ff
	 Bit[63:16] Reserved 
	 Bit[10:0] channel_override_sel[10:0]: 
	 For each bit, 
	 0 = Use xxxx_pin_override_ci 
	 1 = Use xxxx_pin_override (register) 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch1_reg102_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH2_REG102_CSR */
struct psif_csr_ibu_cetus_ch2_reg102_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x7ff
	 Bit[63:16] Reserved 
	 Bit[10:0] channel_override_sel[10:0]: 
	 For each bit, 
	 0 = Use xxxx_pin_override_ci 
	 1 = Use xxxx_pin_override (register) 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch2_reg102_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_CH3_REG102_CSR */
struct psif_csr_ibu_cetus_ch3_reg102_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x7ff
	 Bit[63:16] Reserved 
	 Bit[10:0] channel_override_sel[10:0]: 
	 For each bit, 
	 0 = Use xxxx_pin_override_ci 
	 1 = Use xxxx_pin_override (register) 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_ch3_reg102_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_PLLA_REG24_CSR */
struct psif_csr_ibu_cetus_plla_reg24_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x7
	 Bit[63:3] Reserved 
	 Bit[2:0] PLL_override_sel[2:0]: 
	 For each bit, 
	 0 = Use xxxx_pin_override_ci 
	 1 = Use xxxx_pin_override (register) 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_plla_reg24_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_CETUS_PLLB_REG24_CSR */
struct psif_csr_ibu_cetus_pllb_reg24_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x7
	 Bit[63:3] Reserved 
	 Bit[2:0] PLL_override_sel[2:0]: 
	 For each bit, 
	 0 = Use xxxx_pin_override_ci 
	 1 = Use xxxx_pin_override (register) 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_cetus_pllb_reg24_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_RESET_CSR */
struct psif_csr_ibu_pma_reset_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0xc
	 Bit[63:04]: reserved, POR=0 
	 Bit[03] mresetn : serdes MGM state machine reset 
	 Bit[02] hresetn : Serdes CSR reset 
	 Bit[01] reset_n_b : Pllb reset POR=0 
	 Bit[00] reset_n_a : PLLa reset POR=0 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_reset_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_PLLA_CSR */
struct psif_csr_ibu_pma_plla_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x207043580075068
	 [63] pllstable_bypass_ci, POR=1'b0 
	 [62:59] pma_plla_rsv_b62_59, POR=4'b0 
	 [58] vco_set_sel_ci_a, POR=1'b0 
	 [57] fdr_pll_usrcken_ci_a, POR=1'b1 
	 [56] fdr_pll_usrdiv2en_ci_a, POR=1'b0 
	 [55:48] fdr_pll_usrcntr_ci_a[7:0], POR=8'h07 
	 [47] pma_plla_rsv_b47, POR=1'b0 
	 [46] fdr_pll_divp5en_ci_a, POR=1'b0 
	 [45:44] fdr_pll_incntr_ci_a[1:0], POR=2'b00 
	 [43:36] fdr_pll_fbcntr_ci_a[7:0], POR=8'd43 
	 [35] fdr_divby4ena_ci_a, POR=1'b1 
	 [34] edr_pll_divp5en_ci_a, POR=1'b1 
	 [33:32] edr_pll_incntr_ci_a[1:0], POR=2'b01 
	 [31:24] edr_pll_fbcntr_ci_a[7:0], POR=8'd80 
	 [23] edr_divby4ena_ci_a, POR=1'b0 
	 [22:21] pma_plla_rsv_b22_21[1:0], POR=2'b0 
	 [20:16] pll_pllbw_ci_a[4:0], POR=5'b00111 
	 [15:12] pll_plldmp_ci_a[3:0], POR=4'b0101 
	 [11:4] edr_pll_usrcntr_ci_a[7:0], POR=8'h06 
	 [03] edr_pll_usrcken_ci_a, POR=1'b1 
	 [02] edr_pll_usrdiv2en_ci_a, POR=1'b0 
	 [01] refbufpd_ci_a, POR=1'b0 
	 [00] pllpd_ci_a POR=1'b0 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_plla_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_PLLB_CSR */
struct psif_csr_ibu_pma_pllb_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x1e075000
	 Bit[63:36] reserved, POR=0 
	 Bit[35] vco_set_sel_ci_b, POR=1'b0 
	 Bit[34] pll_divp5en_ci_b, POR=1'b0 
	 Bit[33:32] pll_incntr_ci_b[1:0], POR=2'b00 
	 Bit[31:24] pll_fbcntr_ci_b[7:0], POR=8'd30 
	 Bit[23:22] pma_pllb_rsv_b23_22[1:0], POR=2'b0 
	 Bit[21] divby4ena_ci_b, POR=1'b0 
	 Bit[20:16] pll_pllbw_ci_b[4:0], POR=5'b00111 
	 Bit[15:12] pll_plldmp_ci_b[3:0], POR=4'b0101 
	 Bit[11:4] pll_usrcntr_ci_b[7:0], POR=8'h00 
	 Bit[03] pll_usrcken_ci_b, POR=1'b0 
	 Bit[02] pll_usrdiv2en_ci_b POR=1'b0 
	 Bit[01] refbufpd_ci_b, POR=1'b0 
	 Bit[00] pllpd_ci_b, POR=1'b0 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_pllb_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_CMODE_CSR */
struct psif_csr_ibu_pma_cmode_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0xb4102231
	 Bit[63:46] reserved, POR='0 
	 Bit[45] rx1p25g_pin_override_ci, POR=1'b0 
	 Bit[44] tx1p25g_pin_override_ci, POR=1'b0 
	 Bit[43] dcore_pin_override_ci, POR=1'b0 
	 Bit[42] fref_pin_override_ci, POR=1'b0 
	 Bit[41] pd_pin_override_ci, POR=1'b0 
	 Bit[40] pll_pin_override_ci, POR=1'b0 
	 Bit[39] pllsel_pin_override_ci, POR=1'b0 
	 Bit[38] reset_pin_override_ci, POR=1'b0 
	 Bit[37] rx_bkch_pin_override_ci, POR=1'b0 
	 Bit[36] rx_eee_pin_override_ci, POR=1'b0 
	 Bit[35] rx_losen_pin_override_ci, POR=1'b0 
	 Bit[34] tx_eee_pin_override_ci, POR=1'b0 
	 Bit[33] txfir_pin_override_ci, POR=1'b0 
	 Bit[32] txidle_pin_override_ci, POR=1'b0 
	 Bit[31:30] pma_cmode_rsv_b31_30, POR=2'b0 
	 0 Bit[29] tx_swap_en, POR=1'b 
	 0 Bit[28] rx_swap_en, POR=1'b 
	 0 Bit[27] pma_cmode_rsv_b27, POR=1'b 
	 0 Bit[26:24] wordmode6466[2:0], POR=3'b100 
	 Bit[23] pma_cmode_rsv_b23, POR=1'b 
	 0 Bit[22:20] wordmode810[2:0], POR=3'b011 
	 Bit[19] pma_cmode_rsv_b19, POR=1'b 
	 0 Bit[18:16] edr_chratesel[2:0], POR=3'b000 
	 Bit[15] pma_cmode_rsv_b15, POR=1'b 
	 0 Bit[14:12] fdr_chratesel[2:0], POR=3'b000 
	 Bit[11] pma_cmode_rsv_b11, POR=1'b 
	 0 Bit[10:8] qdr_chratesel[2:0], POR=3'b000 
	 Bit[7] pma_cmode_rsv_b7, POR=1'b 
	 0 Bit[6:4] ddr_chratesel[2:0], POR=3'b010 
	 Bit[3] pma_cmode_rsv_b3, POR=1'b 
	 0 Bit[2:0] sdr_chratesel[2:0] POR=3'b011 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_cmode_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_LB_CSR */
struct psif_csr_ibu_pma_lb_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 Bit[63:60] reserved, POR=0 
	 Bit[59] txwclk0cnt_clr, POR=0 
	 Bit[58] txwclk0cnt_ce, POR=0 
	 Bit[57] rxwclk0cnt_clr, POR=0 
	 Bit[56] rxwclk0cnt_ce, POR=0 
	 Bit[55:54] regbus_sel[1:0], POR=0 
	 Bit[53] ratechange_ena_mask, POR=0 
	 Bit[52] force_serdes_rdy, POR=0 
	 Bit[51:44] pma_lb_rsv_b51_44, POR=0 
	 Bit[43] bit_slip_0, POR=0 
	 Bit[42] bit_slip_1, POR=0 
	 Bit[41] bit_slip_2, POR=0 
	 Bit[40] bit_slip_3, POR=0 
	 Bit[39] chlol_0, POR=0 
	 Bit[38] chlol_1, POR=0 
	 Bit[37] chlol_2, POR=0 
	 Bit[36] chlol_3, POR=0 
	 Bit[35] lpen_0, POR=0 Channel_reg_9 bit8 rxlpen_overrride=0 use lpbksel in Channel_reg_0 bit[5:4] 
	 Bit[34] lpen_1, POR=0 
	 Bit[33] lpen_2, POR=0 
	 Bit[32] lpen_3, POR=0 
	 Bit[31] rxc0_ena_0, POR=0 
	 Bit[30] rxc0_ena_1, POR=0 
	 Bit[29] rxc0_ena_2, POR=0 
	 Bit[28] rxc0_ena_3, POR=0 
	 Bit[27] rxc1_ena_0, POR=0 
	 Bit[26] rxc1_ena_1, POR=0 
	 Bit[25] rxc1_ena_2, POR=0 
	 Bit[24] rxc1_ena_3, POR=0 
	 Bit[23] rxcn1_ena_0, POR=0 
	 Bit[22] rxcn1_ena_1, POR=0 
	 Bit[21] rxcn1_ena_2, POR=0 
	 Bit[20] rxcn1_ena_3, POR=0 
	 Bit[19] rxcn2_ena_0, POR=0 
	 Bit[18] rxcn2_ena_1, POR=0 
	 Bit[17] rxcn2_ena_2, POR=0 
	 Bit[16] rxcn2_ena_3, POR=0 
	 Bit[15] rxlosen_r2a_0, POR=0 
	 Bit[14] rxlosen_r2a_1, POR=0 
	 Bit[13] rxlosen_r2a_2, POR=0 
	 Bit[12] rxlosen_r2a_3, POR=0 
	 Bit[11:0] pma_lb_rsv_b11_0 POR=0 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_lb_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_PWR_CSR */
struct psif_csr_ibu_pma_pwr_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x40f0
	 Bit[63:50] reserved, POR=0 
	 Bit[49] rx1p25gena_ci_0, POR=0 
	 Bit[48] rx1p25gena_ci_1, POR=0 
	 Bit[47] rx1p25gena_ci_2, POR=0 
	 Bit[46] rx1p25gena_ci_3, POR=0 
	 Bit[45] rx_inv_0, POR=0 
	 Bit[44] rx_inv_1, POR=0 
	 Bit[43] rx_inv_2, POR=0 
	 Bit[42] rx_inv_3, POR=0 
	 Bit[41] tx1p25gena_ci_0, POR=0 
	 Bit[40] tx1p25gena_ci_1, POR=0 
	 Bit[39] tx1p25gena_ci_2, POR=0 
	 Bit[38] tx1p25gena_ci_3, POR=0 
	 Bit[37] tx_inv_0, POR=0 
	 Bit[36] tx_inv_1, POR=0 
	 Bit[35] tx_inv_2, POR=0 
	 Bit[34] tx_inv_3, POR=0 
	 Bit[33] rxclk6466halfena_3, POR=0 
	 Bit[32] rxclk6466halfena_2, POR=0 
	 Bit[31] rxclk6466halfena_1, POR=0 
	 Bit[30] rxclk6466halfena_0, POR=0 
	 Bit[29:28] pma_pwr_rsv_b2928, POR=0 
	 Bit[27] rx_lpi_active_3, POR=0 
	 Bit[26] rx_lpi_active_2, POR=0 
	 Bit[25] rx_lpi_active_1, POR=0 
	 Bit[24] rx_lpi_active_0, POR=0 
	 Bit[23] rx_quiet_3, POR=0 
	 Bit[22] rx_quiet_2, POR=0 
	 Bit[21] rx_quiet_1, POR=0 
	 Bit[20] rx_quiet_0, POR=0 
	 Bit[19] tx_quiet_3, POR=0 
	 Bit[18] tx_quiet_2, POR=0 
	 Bit[17] tx_quiet_1, POR=0 
	 Bit[16] tx_quiet_0, POR=0 
	 Bit[15] pma_pwr_rsv_b15, POR=0 
	 Bit[14] txcgmode, POR=1 
	 Bit[13] txclk6466halfen_a, POR=0 
	 Bit[12] txclk6466halfen_b, POR=0 
	 Bit[11] txidle_r2a_0, POR=0 
	 Bit[10] txidle_r2a_1, POR=0 
	 Bit[9] txidle_r2a_2, POR=0 
	 Bit[8] txidle_r2a_3, POR=0 
	 Bit[7] mask_txpd0, POR=1 
	 Bit[6] mask_txpd1, POR=1 
	 Bit[5] mask_txpd2, POR=1 
	 Bit[4] mask_txpd3, POR=1 
	 Bit[3] rxpd_0, POR=0 
	 Bit[2] rxpd_1, POR=0 
	 Bit[1] rxpd_2, POR=0 
	 Bit[0] rxpd_3 POR=0 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_pwr_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_STATUS0_CSR */
struct psif_csr_ibu_pma_status0_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RU reset = 0x0
	 Bit[63] speed_change_req, POR=0 
	 Bit[62:60] speed_mode[2:0], POR=0 
	 Bit[59] speed_change_ack, POR=0 
	 Bit[58:56] speed_change_state[2:0] POR=0 
	 Bit[55:54] hresp[1:0], POR=0 
	 Bit[53] sel_sdr_speed, POR=1 
	 Bit[52] sel_ddr_speed, POR=0 
	 Bit[51] sel_qdr_speed, POR=0 
	 Bit[50] sel_fdr_speed, POR=0 
	 Bit[49] sel_edr_speed, POR=0 
	 Bit[48] ratechange_ena, POR=0 
	 Bit[47] 1'b0, POR=0 
	 Bit[46] hsel, POR=0 
	 Bit[45] hwrite, POR=0 
	 Bit[44] hready, POR=1 
	 Bit[43:32] haddr[11:0], POR=x 
	 Bit[31:16] hwdata[15:0], POR=x 
	 Bit[15:0] hrdata[15:0]} POR=x 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_status0_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_STATUS1_CSR */
struct psif_csr_ibu_pma_status1_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0xff
	 Bit[63:60] 4'b0, POR=0 
	 Bit[59:56] rxloscal_done[3:0], POR=0 
	 Bit[55:52] 4'b0, POR=0 
	 Bit[51] rxlosaf_ch_3, POR=0 
	 Bit[50] rxlosaf_ch_2, POR=0 
	 Bit[49] rxlosaf_ch_1, POR=0 
	 Bit[48] rxlosaf_ch_0, POR=0 
	 Bit[47:44] 4'b0, POR=0 
	 Bit[43] rxlatchcaldone_d2r_3, POR=0 
	 Bit[42] rxlatchcaldone_d2r_2, POR=0 
	 Bit[41] rxlatchcaldone_d2r_1, POR=0 
	 Bit[40] rxlatchcaldone_d2r_0, POR=0 
	 Bit[39:38] c0_d2r_3[1:0], POR=0 
	 Bit[37:36] c0_d2r_2[1:0], POR=0 
	 Bit[35:34] c0_d2r_1[1:0], POR=0 
	 Bit[33:32] c0_d2r_0[1:0], POR=0 
	 Bit[31:28] bertok[3:0], POR=0 
	 Bit[27] vcocaldone_a, POR=0 
	 Bit[26] 1'b0, POR=0 
	 Bit[25] PLLLOCK_a, POR=0 
	 Bit[24] 1'b0, POR=0 
	 Bit[23:20] ready_for_tx_quiet[3:0], POR=0 
	 Bit[19] vcocaldone_b, POR=0 
	 Bit[18] 1'b0, POR=0 
	 Bit[17] PLLLOCK_b, POR=0 
	 Bit[16] 1'b0, POR=0 
	 Bit[15] mdio_in, POR=0 
	 Bit[14] mdio_out, POR=0 
	 Bit[13] mdio_outen, POR=0 
	 Bit[12] serdes_rdy, POR=0 
	 Bit[11] 1'b0, POR=0 
	 Bit[10] 1'b0, POR=0 
	 Bit[9] 1'b0, POR=0 
	 Bit[8] 1'b0, POR=0 
	 Bit[7:4] txphyready[3:0], POR=4'hf 
	 Bit[3:0] rxphyready[3:0]} POR=4'hf 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_status1_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_STATUS2_CSR */
struct psif_csr_ibu_pma_status2_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RU reset = 0x0
	 Bit[55:48]: {spareout_3[1:0], spareout_2[1:0], spareout_1[1:0], spareout_0[1:0]}, POR=x 
	 Bit[47:40]: {4'b0, txbc_pre_up3, txbc_pre_up2, txbc_pre_up1, txbc_pre_up0}, POR=x 
	 Bit[39:32]: {4'b0, txbc_pre_dn3, txbc_pre_dn2, txbc_pre_dn1, txbc_pre_dn0}, POR=x 
	 Bit[31:24]: {4'b0, txbc_pre2_up3, txbc_pre2_up2, txbc_pre2_up1, txbc_pre2_up0}, POR=x 
	 Bit[23:16]: {4'b0, txbc_pre2_dn3, txbc_pre2_dn2, txbc_pre2_dn1, txbc_pre2_dn0}, POR=x 
	 Bit[15:8]: {4'b0, txbc_post_up3, txbc_post_up2, txbc_post_up1, txbc_post_up0}, POR=x 
	 Bit[7:0]: {4'b0, txbc_post_dn3, txbc_post_dn2, txbc_post_dn1, txbc_post_dn0} POR=x 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_status2_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_TXWCLK0_CNT_CSR */
struct psif_csr_ibu_pma_txwclk0_cnt_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 This is a debug counter which is used to test the existence of txwclk. 
	 Bit[63:48]: rsvd, POR=0 
	 Bit[49:0]: PMA_TXWCLK0CNT is the static starting value. POR=0. 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_txwclk0_cnt_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_TXWCLK0_CNT_VAL */
struct psif_csr_ibu_pma_txwclk0_cnt_val {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0x0
	 This is a debug counter which is used to test the existence of txwclk. 
	 Bit[63]: Read only status bit that indicates PMA_TXWCLK0CNT_VAL reached maximum value, POR=0 
	 Bit[62:50]: rsvd, POR=0 
	 Bit[49:0]: PMA_TXWCLK0CNT_VAL is the counter value, POR=0. 
	 Set PMA_LB_CSR bit 58 (txwclk0cnt_ce) to 1 to enable count up. 
	 Once reaches maximum value ({50{1'b1}}), it stays there. 
	 Set PMA_LB_CSR bit 59 (txwclk0cnt_clr) to 1 to clear the counter; 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_txwclk0_cnt_val [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_RXWCLK0_CNT_CSR */
struct psif_csr_ibu_pma_rxwclk0_cnt_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x0
	 This is a debug counter which is used to test the existence of rxwclk. 
	 Bit[63:48]: rsvd, POR=0 
	 Bit[49:0]: PMA_RXWCLK0CNT is the static starting value. POR=0. 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_rxwclk0_cnt_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_RXWCLK0_CNT_VAL */
struct psif_csr_ibu_pma_rxwclk0_cnt_val {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0x0
	 This is a debug counter which is used to test the existence of rxwclk. 
	 Bit[63]: Read only status bit that indicates PMA_RXWCLK0CNT_VAL reached maximum value, POR=0 
	 Bit[62:50]: rsvd, POR=0 
	 Bit[49:0]: PMA_RXWCLK0CNT_VAL is the counter value, POR=0. 
	 Set PMA_LB_CSR bit 56 (rxwclk0cnt_ce) to 1 to enable count up. 
	 Once reaches maximum value ({50{1'b1}}), it stays there. 
	 Set PMA_LB_CSR bit 57 (rxwclk0cnt_clr) to 1 to clear the counter; 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_rxwclk0_cnt_val [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_IRQ_STATUS_CSR */
struct psif_csr_ibu_pma_irq_status_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0x0
	 Bit[63:1]: rsvd, POR=0 
	 Bit[0]: The leading/rising edge of speed_change_req sets this bit to indicate that LTSM has issued a speed change request. The actual requested speed can be found on PMA_STATUS0 speed_mode field (bit 62:60). 
	 A speed_change_req level version of the signal can be found in PMA_STATUS0 bit 63. POR=0 
	 If PMA_IRQ_MASK_CSR bit 0 is 1, an interrupt is masked and won't be generated. 
	 If PMA_IRQ_MASK_CSR bit 0 is 0, an interrupt can be generated if the corresponding interrupt status bit is set to 1. 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_irq_status_csr [64 bits] */

/* CSR automated type for IBU_P{1,2}_PMA_IRQ_MASK_CSR */
struct psif_csr_ibu_pma_irq_mask_csr {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0x1
	 Bit[63:1]: rsvd, POR=0 
	 Bit[0]: PMA interrupt request mask bit. It is active high signal. POR=1 
	 If PMA_IRQ_MASK_CSR bit 0 is 1, an interrupt is masked and won't be generated. 
	 If PMA_IRQ_MASK_CSR bit 0 is 0, an interrupt can be generated if the corresponding interrupt status bit is set to 1. 
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_ibu_pma_irq_mask_csr [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG0 */
struct psif_csr_peu_p_req_credit_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 0. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg0 is set to 0, the posted credits for the list 0 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg0 is not 0, the p_return_interval_reg0 determines the rate posted credits are returned to list 0, and p_return_credit_reg0 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg0 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG0 */
struct psif_csr_peu_np_req_credit_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 0. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg0 is set to 0, the non-posted credits for the list 0 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg0 is not 0, the np_return_interval_reg0 determines the rate non-posted credits are returned to list 0, and np_return_credit_reg0 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg0 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG0 */
struct psif_csr_peu_p_return_credit_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 0. The interval at which posted credits are returned to list 0 is set by p_return_interval_reg0 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg0 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG0 */
struct psif_csr_peu_np_return_credit_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 0. The interval at which non-posted credits are returned to list 0 is set by np_return_interval_reg0 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg0 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG0 */
struct psif_csr_peu_p_return_interval_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 0. The amount of posted credits returned is determined by p_return_credit_reg0 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg0 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG0 */
struct psif_csr_peu_np_return_interval_reg0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 0. The amount of non-posted credits returned is determined by np_return_credit_reg0 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg0 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD0 */
struct psif_csr_peu_q_np_tag_cnt_thld0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 0, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 0 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld0 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD0 */
struct psif_csr_peu_xadm_ph_cdts_thld0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 0. If the Posted Header credits falls below this threshold then servicing of posted request out of list 0 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld0 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD0 */
struct psif_csr_peu_xadm_pd_cdts_thld0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 0. If the Posted Data credits falls below this threshold then servicing of posted request out of list 0 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld0 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD0 */
struct psif_csr_peu_xadm_nph_cdts_thld0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 0. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 0 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld0 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD0 */
struct psif_csr_peu_xadm_npd_cdts_thld0 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 0. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 0 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld0 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG1 */
struct psif_csr_peu_p_req_credit_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 1. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg1 is set to 1, the posted credits for the list 1 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg1 is not 1, the p_return_interval_reg1 determines the rate posted credits are returned to list 1, and p_return_credit_reg1 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg1 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG1 */
struct psif_csr_peu_np_req_credit_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 1. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg1 is set to 1, the non-posted credits for the list 1 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg1 is not 1, the np_return_interval_reg1 determines the rate non-posted credits are returned to list 1, and np_return_credit_reg1 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg1 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG1 */
struct psif_csr_peu_p_return_credit_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 1. The interval at which posted credits are returned to list 1 is set by p_return_interval_reg1 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg1 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG1 */
struct psif_csr_peu_np_return_credit_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 1. The interval at which non-posted credits are returned to list 1 is set by np_return_interval_reg1 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg1 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG1 */
struct psif_csr_peu_p_return_interval_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 1. The amount of posted credits returned is determined by p_return_credit_reg1 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg1 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG1 */
struct psif_csr_peu_np_return_interval_reg1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 1. The amount of non-posted credits returned is determined by np_return_credit_reg1 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg1 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD1 */
struct psif_csr_peu_q_np_tag_cnt_thld1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 1, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 1 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld1 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD1 */
struct psif_csr_peu_xadm_ph_cdts_thld1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 1. If the Posted Header credits falls below this threshold then servicing of posted request out of list 1 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld1 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD1 */
struct psif_csr_peu_xadm_pd_cdts_thld1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 1. If the Posted Data credits falls below this threshold then servicing of posted request out of list 1 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld1 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD1 */
struct psif_csr_peu_xadm_nph_cdts_thld1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 1. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 1 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld1 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD1 */
struct psif_csr_peu_xadm_npd_cdts_thld1 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 1. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 1 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld1 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG2 */
struct psif_csr_peu_p_req_credit_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 2. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg2 is set to 2, the posted credits for the list 2 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg2 is not 2, the p_return_interval_reg2 determines the rate posted credits are returned to list 2, and p_return_credit_reg2 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg2 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG2 */
struct psif_csr_peu_np_req_credit_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 2. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg2 is set to 2, the non-posted credits for the list 2 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg2 is not 2, the np_return_interval_reg2 determines the rate non-posted credits are returned to list 2, and np_return_credit_reg2 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg2 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG2 */
struct psif_csr_peu_p_return_credit_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 2. The interval at which posted credits are returned to list 2 is set by p_return_interval_reg2 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg2 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG2 */
struct psif_csr_peu_np_return_credit_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 2. The interval at which non-posted credits are returned to list 2 is set by np_return_interval_reg2 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg2 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG2 */
struct psif_csr_peu_p_return_interval_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 2. The amount of posted credits returned is determined by p_return_credit_reg2 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg2 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG2 */
struct psif_csr_peu_np_return_interval_reg2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 2. The amount of non-posted credits returned is determined by np_return_credit_reg2 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg2 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD2 */
struct psif_csr_peu_q_np_tag_cnt_thld2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 2, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 2 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld2 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD2 */
struct psif_csr_peu_xadm_ph_cdts_thld2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 2. If the Posted Header credits falls below this threshold then servicing of posted request out of list 2 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld2 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD2 */
struct psif_csr_peu_xadm_pd_cdts_thld2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 2. If the Posted Data credits falls below this threshold then servicing of posted request out of list 2 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld2 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD2 */
struct psif_csr_peu_xadm_nph_cdts_thld2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 2. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 2 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld2 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD2 */
struct psif_csr_peu_xadm_npd_cdts_thld2 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 2. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 2 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld2 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG3 */
struct psif_csr_peu_p_req_credit_reg3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 3. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg3 is set to 3, the posted credits for the list 3 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg3 is not 3, the p_return_interval_reg3 determines the rate posted credits are returned to list 3, and p_return_credit_reg3 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg3 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG3 */
struct psif_csr_peu_np_req_credit_reg3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 3. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg3 is set to 3, the non-posted credits for the list 3 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg3 is not 3, the np_return_interval_reg3 determines the rate non-posted credits are returned to list 3, and np_return_credit_reg3 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg3 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG3 */
struct psif_csr_peu_p_return_credit_reg3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 3. The interval at which posted credits are returned to list 3 is set by p_return_interval_reg3 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg3 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG3 */
struct psif_csr_peu_np_return_credit_reg3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 3. The interval at which non-posted credits are returned to list 3 is set by np_return_interval_reg3 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg3 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG3 */
struct psif_csr_peu_p_return_interval_reg3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 3. The amount of posted credits returned is determined by p_return_credit_reg3 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg3 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG3 */
struct psif_csr_peu_np_return_interval_reg3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 3. The amount of non-posted credits returned is determined by np_return_credit_reg3 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg3 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD3 */
struct psif_csr_peu_q_np_tag_cnt_thld3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 3, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 3 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld3 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD3 */
struct psif_csr_peu_xadm_ph_cdts_thld3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 3. If the Posted Header credits falls below this threshold then servicing of posted request out of list 3 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld3 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD3 */
struct psif_csr_peu_xadm_pd_cdts_thld3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 3. If the Posted Data credits falls below this threshold then servicing of posted request out of list 3 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld3 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD3 */
struct psif_csr_peu_xadm_nph_cdts_thld3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 3. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 3 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld3 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD3 */
struct psif_csr_peu_xadm_npd_cdts_thld3 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 3. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 3 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld3 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG4 */
struct psif_csr_peu_p_req_credit_reg4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 4. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg4 is set to 4, the posted credits for the list 4 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg4 is not 4, the p_return_interval_reg4 determines the rate posted credits are returned to list 4, and p_return_credit_reg4 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg4 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG4 */
struct psif_csr_peu_np_req_credit_reg4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 4. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg4 is set to 4, the non-posted credits for the list 4 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg4 is not 4, the np_return_interval_reg4 determines the rate non-posted credits are returned to list 4, and np_return_credit_reg4 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg4 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG4 */
struct psif_csr_peu_p_return_credit_reg4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 4. The interval at which posted credits are returned to list 4 is set by p_return_interval_reg4 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg4 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG4 */
struct psif_csr_peu_np_return_credit_reg4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 4. The interval at which non-posted credits are returned to list 4 is set by np_return_interval_reg4 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg4 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG4 */
struct psif_csr_peu_p_return_interval_reg4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 4. The amount of posted credits returned is determined by p_return_credit_reg4 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg4 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG4 */
struct psif_csr_peu_np_return_interval_reg4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 4. The amount of non-posted credits returned is determined by np_return_credit_reg4 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg4 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD4 */
struct psif_csr_peu_q_np_tag_cnt_thld4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 4, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 4 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld4 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD4 */
struct psif_csr_peu_xadm_ph_cdts_thld4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 4. If the Posted Header credits falls below this threshold then servicing of posted request out of list 4 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld4 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD4 */
struct psif_csr_peu_xadm_pd_cdts_thld4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 4. If the Posted Data credits falls below this threshold then servicing of posted request out of list 4 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld4 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD4 */
struct psif_csr_peu_xadm_nph_cdts_thld4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 4. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 4 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld4 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD4 */
struct psif_csr_peu_xadm_npd_cdts_thld4 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 4. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 4 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld4 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG5 */
struct psif_csr_peu_p_req_credit_reg5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 5. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg5 is set to 5, the posted credits for the list 5 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg5 is not 5, the p_return_interval_reg5 determines the rate posted credits are returned to list 5, and p_return_credit_reg5 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg5 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG5 */
struct psif_csr_peu_np_req_credit_reg5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 5. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg5 is set to 5, the non-posted credits for the list 5 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg5 is not 5, the np_return_interval_reg5 determines the rate non-posted credits are returned to list 5, and np_return_credit_reg5 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg5 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG5 */
struct psif_csr_peu_p_return_credit_reg5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 5. The interval at which posted credits are returned to list 5 is set by p_return_interval_reg5 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg5 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG5 */
struct psif_csr_peu_np_return_credit_reg5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 5. The interval at which non-posted credits are returned to list 5 is set by np_return_interval_reg5 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg5 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG5 */
struct psif_csr_peu_p_return_interval_reg5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 5. The amount of posted credits returned is determined by p_return_credit_reg5 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg5 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG5 */
struct psif_csr_peu_np_return_interval_reg5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 5. The amount of non-posted credits returned is determined by np_return_credit_reg5 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg5 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD5 */
struct psif_csr_peu_q_np_tag_cnt_thld5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 5, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 5 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld5 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD5 */
struct psif_csr_peu_xadm_ph_cdts_thld5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 5. If the Posted Header credits falls below this threshold then servicing of posted request out of list 5 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld5 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD5 */
struct psif_csr_peu_xadm_pd_cdts_thld5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 5. If the Posted Data credits falls below this threshold then servicing of posted request out of list 5 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld5 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD5 */
struct psif_csr_peu_xadm_nph_cdts_thld5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 5. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 5 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld5 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD5 */
struct psif_csr_peu_xadm_npd_cdts_thld5 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 5. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 5 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld5 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG6 */
struct psif_csr_peu_p_req_credit_reg6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 6. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg6 is set to 6, the posted credits for the list 6 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg6 is not 6, the p_return_interval_reg6 determines the rate posted credits are returned to list 6, and p_return_credit_reg6 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg6 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG6 */
struct psif_csr_peu_np_req_credit_reg6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 6. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg6 is set to 6, the non-posted credits for the list 6 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg6 is not 6, the np_return_interval_reg6 determines the rate non-posted credits are returned to list 6, and np_return_credit_reg6 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg6 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG6 */
struct psif_csr_peu_p_return_credit_reg6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 6. The interval at which posted credits are returned to list 6 is set by p_return_interval_reg6 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg6 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG6 */
struct psif_csr_peu_np_return_credit_reg6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 6. The interval at which non-posted credits are returned to list 6 is set by np_return_interval_reg6 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg6 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG6 */
struct psif_csr_peu_p_return_interval_reg6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 6. The amount of posted credits returned is determined by p_return_credit_reg6 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg6 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG6 */
struct psif_csr_peu_np_return_interval_reg6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 6. The amount of non-posted credits returned is determined by np_return_credit_reg6 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg6 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD6 */
struct psif_csr_peu_q_np_tag_cnt_thld6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 6, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 6 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld6 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD6 */
struct psif_csr_peu_xadm_ph_cdts_thld6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 6. If the Posted Header credits falls below this threshold then servicing of posted request out of list 6 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld6 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD6 */
struct psif_csr_peu_xadm_pd_cdts_thld6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 6. If the Posted Data credits falls below this threshold then servicing of posted request out of list 6 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld6 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD6 */
struct psif_csr_peu_xadm_nph_cdts_thld6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 6. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 6 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld6 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD6 */
struct psif_csr_peu_xadm_npd_cdts_thld6 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 6. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 6 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld6 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG7 */
struct psif_csr_peu_p_req_credit_reg7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 7. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg7 is set to 7, the posted credits for the list 7 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg7 is not 7, the p_return_interval_reg7 determines the rate posted credits are returned to list 7, and p_return_credit_reg7 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg7 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG7 */
struct psif_csr_peu_np_req_credit_reg7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 7. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg7 is set to 7, the non-posted credits for the list 7 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg7 is not 7, the np_return_interval_reg7 determines the rate non-posted credits are returned to list 7, and np_return_credit_reg7 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg7 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG7 */
struct psif_csr_peu_p_return_credit_reg7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 7. The interval at which posted credits are returned to list 7 is set by p_return_interval_reg7 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg7 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG7 */
struct psif_csr_peu_np_return_credit_reg7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 7. The interval at which non-posted credits are returned to list 7 is set by np_return_interval_reg7 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg7 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG7 */
struct psif_csr_peu_p_return_interval_reg7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 7. The amount of posted credits returned is determined by p_return_credit_reg7 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg7 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG7 */
struct psif_csr_peu_np_return_interval_reg7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 7. The amount of non-posted credits returned is determined by np_return_credit_reg7 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg7 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD7 */
struct psif_csr_peu_q_np_tag_cnt_thld7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 7, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 7 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld7 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD7 */
struct psif_csr_peu_xadm_ph_cdts_thld7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 7. If the Posted Header credits falls below this threshold then servicing of posted request out of list 7 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld7 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD7 */
struct psif_csr_peu_xadm_pd_cdts_thld7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 7. If the Posted Data credits falls below this threshold then servicing of posted request out of list 7 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld7 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD7 */
struct psif_csr_peu_xadm_nph_cdts_thld7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 7. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 7 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld7 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD7 */
struct psif_csr_peu_xadm_npd_cdts_thld7 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 7. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 7 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld7 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG8 */
struct psif_csr_peu_p_req_credit_reg8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 8. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg8 is set to 8, the posted credits for the list 8 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg8 is not 8, the p_return_interval_reg8 determines the rate posted credits are returned to list 8, and p_return_credit_reg8 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg8 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG8 */
struct psif_csr_peu_np_req_credit_reg8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 8. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg8 is set to 8, the non-posted credits for the list 8 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg8 is not 8, the np_return_interval_reg8 determines the rate non-posted credits are returned to list 8, and np_return_credit_reg8 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg8 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG8 */
struct psif_csr_peu_p_return_credit_reg8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 8. The interval at which posted credits are returned to list 8 is set by p_return_interval_reg8 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg8 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG8 */
struct psif_csr_peu_np_return_credit_reg8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 8. The interval at which non-posted credits are returned to list 8 is set by np_return_interval_reg8 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg8 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG8 */
struct psif_csr_peu_p_return_interval_reg8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 8. The amount of posted credits returned is determined by p_return_credit_reg8 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg8 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG8 */
struct psif_csr_peu_np_return_interval_reg8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 8. The amount of non-posted credits returned is determined by np_return_credit_reg8 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg8 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD8 */
struct psif_csr_peu_q_np_tag_cnt_thld8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 8, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 8 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld8 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD8 */
struct psif_csr_peu_xadm_ph_cdts_thld8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 8. If the Posted Header credits falls below this threshold then servicing of posted request out of list 8 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld8 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD8 */
struct psif_csr_peu_xadm_pd_cdts_thld8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 8. If the Posted Data credits falls below this threshold then servicing of posted request out of list 8 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld8 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD8 */
struct psif_csr_peu_xadm_nph_cdts_thld8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 8. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 8 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld8 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD8 */
struct psif_csr_peu_xadm_npd_cdts_thld8 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 8. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 8 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld8 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG9 */
struct psif_csr_peu_p_req_credit_reg9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 9. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg9 is set to 9, the posted credits for the list 9 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg9 is not 9, the p_return_interval_reg9 determines the rate posted credits are returned to list 9, and p_return_credit_reg9 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg9 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG9 */
struct psif_csr_peu_np_req_credit_reg9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 9. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg9 is set to 9, the non-posted credits for the list 9 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg9 is not 9, the np_return_interval_reg9 determines the rate non-posted credits are returned to list 9, and np_return_credit_reg9 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg9 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG9 */
struct psif_csr_peu_p_return_credit_reg9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 9. The interval at which posted credits are returned to list 9 is set by p_return_interval_reg9 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg9 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG9 */
struct psif_csr_peu_np_return_credit_reg9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 9. The interval at which non-posted credits are returned to list 9 is set by np_return_interval_reg9 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg9 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG9 */
struct psif_csr_peu_p_return_interval_reg9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 9. The amount of posted credits returned is determined by p_return_credit_reg9 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg9 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG9 */
struct psif_csr_peu_np_return_interval_reg9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 9. The amount of non-posted credits returned is determined by np_return_credit_reg9 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg9 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD9 */
struct psif_csr_peu_q_np_tag_cnt_thld9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 9, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 9 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld9 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD9 */
struct psif_csr_peu_xadm_ph_cdts_thld9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 9. If the Posted Header credits falls below this threshold then servicing of posted request out of list 9 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld9 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD9 */
struct psif_csr_peu_xadm_pd_cdts_thld9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 9. If the Posted Data credits falls below this threshold then servicing of posted request out of list 9 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld9 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD9 */
struct psif_csr_peu_xadm_nph_cdts_thld9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 9. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 9 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld9 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD9 */
struct psif_csr_peu_xadm_npd_cdts_thld9 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 9. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 9 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld9 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG10 */
struct psif_csr_peu_p_req_credit_reg10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 10. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg10 is set to 10, the posted credits for the list 10 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg10 is not 10, the p_return_interval_reg10 determines the rate posted credits are returned to list 10, and p_return_credit_reg10 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg10 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG10 */
struct psif_csr_peu_np_req_credit_reg10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 10. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg10 is set to 10, the non-posted credits for the list 10 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg10 is not 10, the np_return_interval_reg10 determines the rate non-posted credits are returned to list 10, and np_return_credit_reg10 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg10 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG10 */
struct psif_csr_peu_p_return_credit_reg10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 10. The interval at which posted credits are returned to list 10 is set by p_return_interval_reg10 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg10 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG10 */
struct psif_csr_peu_np_return_credit_reg10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 10. The interval at which non-posted credits are returned to list 10 is set by np_return_interval_reg10 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg10 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG10 */
struct psif_csr_peu_p_return_interval_reg10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 10. The amount of posted credits returned is determined by p_return_credit_reg10 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg10 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG10 */
struct psif_csr_peu_np_return_interval_reg10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 10. The amount of non-posted credits returned is determined by np_return_credit_reg10 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg10 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD10 */
struct psif_csr_peu_q_np_tag_cnt_thld10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 10, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 10 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld10 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD10 */
struct psif_csr_peu_xadm_ph_cdts_thld10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 10. If the Posted Header credits falls below this threshold then servicing of posted request out of list 10 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld10 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD10 */
struct psif_csr_peu_xadm_pd_cdts_thld10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 10. If the Posted Data credits falls below this threshold then servicing of posted request out of list 10 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld10 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD10 */
struct psif_csr_peu_xadm_nph_cdts_thld10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 10. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 10 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld10 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD10 */
struct psif_csr_peu_xadm_npd_cdts_thld10 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 10. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 10 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld10 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG11 */
struct psif_csr_peu_p_req_credit_reg11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 11. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg11 is set to 11, the posted credits for the list 11 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg11 is not 11, the p_return_interval_reg11 determines the rate posted credits are returned to list 11, and p_return_credit_reg11 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg11 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG11 */
struct psif_csr_peu_np_req_credit_reg11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 11. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg11 is set to 11, the non-posted credits for the list 11 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg11 is not 11, the np_return_interval_reg11 determines the rate non-posted credits are returned to list 11, and np_return_credit_reg11 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg11 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG11 */
struct psif_csr_peu_p_return_credit_reg11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 11. The interval at which posted credits are returned to list 11 is set by p_return_interval_reg11 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg11 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG11 */
struct psif_csr_peu_np_return_credit_reg11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 11. The interval at which non-posted credits are returned to list 11 is set by np_return_interval_reg11 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg11 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG11 */
struct psif_csr_peu_p_return_interval_reg11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 11. The amount of posted credits returned is determined by p_return_credit_reg11 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg11 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG11 */
struct psif_csr_peu_np_return_interval_reg11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 11. The amount of non-posted credits returned is determined by np_return_credit_reg11 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg11 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD11 */
struct psif_csr_peu_q_np_tag_cnt_thld11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 11, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 11 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld11 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD11 */
struct psif_csr_peu_xadm_ph_cdts_thld11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 11. If the Posted Header credits falls below this threshold then servicing of posted request out of list 11 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld11 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD11 */
struct psif_csr_peu_xadm_pd_cdts_thld11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 11. If the Posted Data credits falls below this threshold then servicing of posted request out of list 11 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld11 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD11 */
struct psif_csr_peu_xadm_nph_cdts_thld11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 11. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 11 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld11 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD11 */
struct psif_csr_peu_xadm_npd_cdts_thld11 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 11. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 11 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld11 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG12 */
struct psif_csr_peu_p_req_credit_reg12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 12. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg12 is set to 12, the posted credits for the list 12 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg12 is not 12, the p_return_interval_reg12 determines the rate posted credits are returned to list 12, and p_return_credit_reg12 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg12 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG12 */
struct psif_csr_peu_np_req_credit_reg12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 12. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg12 is set to 12, the non-posted credits for the list 7 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg12 is not 12, the np_return_interval_reg12 determines the rate non-posted credits are returned to list 12, and np_return_credit_reg12 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg12 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG12 */
struct psif_csr_peu_p_return_credit_reg12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 12. The interval at which posted credits are returned to list 12 is set by p_return_interval_reg12 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg12 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG12 */
struct psif_csr_peu_np_return_credit_reg12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 12. The interval at which non-posted credits are returned to list 12 is set by np_return_interval_reg12 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg12 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG12 */
struct psif_csr_peu_p_return_interval_reg12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 12. The amount of posted credits returned is determined by p_return_credit_reg12 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg12 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG12 */
struct psif_csr_peu_np_return_interval_reg12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 12. The amount of non-posted credits returned is determined by np_return_credit_reg12 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg12 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD12 */
struct psif_csr_peu_q_np_tag_cnt_thld12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 12, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 12 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld12 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD12 */
struct psif_csr_peu_xadm_ph_cdts_thld12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 12. If the Posted Header credits falls below this threshold then servicing of posted request out of list 12 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld12 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD12 */
struct psif_csr_peu_xadm_pd_cdts_thld12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 12. If the Posted Data credits falls below this threshold then servicing of posted request out of list 12 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld12 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD12 */
struct psif_csr_peu_xadm_nph_cdts_thld12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 12. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 12 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld12 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD12 */
struct psif_csr_peu_xadm_npd_cdts_thld12 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 12. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 12 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld12 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG13 */
struct psif_csr_peu_p_req_credit_reg13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 13. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg13 is set to 13, the posted credits for the list 13 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg13 is not 13, the p_return_interval_reg13 determines the rate posted credits are returned to list 13, and p_return_credit_reg13 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg13 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG13 */
struct psif_csr_peu_np_req_credit_reg13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 13. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg13 is set to 13, the non-posted credits for the list 13 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg13 is not 13, the np_return_interval_reg13 determines the rate non-posted credits are returned to list 13, and np_return_credit_reg13 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg13 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG13 */
struct psif_csr_peu_p_return_credit_reg13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 13. The interval at which posted credits are returned to list 13 is set by p_return_interval_reg13 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg13 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG13 */
struct psif_csr_peu_np_return_credit_reg13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 13. The interval at which non-posted credits are returned to list 13 is set by np_return_interval_reg13 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg13 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG13 */
struct psif_csr_peu_p_return_interval_reg13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 13. The amount of posted credits returned is determined by p_return_credit_reg13 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg13 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG13 */
struct psif_csr_peu_np_return_interval_reg13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 13. The amount of non-posted credits returned is determined by np_return_credit_reg13 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg13 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD13 */
struct psif_csr_peu_q_np_tag_cnt_thld13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 13, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 13 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld13 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD13 */
struct psif_csr_peu_xadm_ph_cdts_thld13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 13. If the Posted Header credits falls below this threshold then servicing of posted request out of list 13 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld13 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD13 */
struct psif_csr_peu_xadm_pd_cdts_thld13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 13. If the Posted Data credits falls below this threshold then servicing of posted request out of list 13 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld13 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD13 */
struct psif_csr_peu_xadm_nph_cdts_thld13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 13. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 13 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld13 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD13 */
struct psif_csr_peu_xadm_npd_cdts_thld13 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 13. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 13 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld13 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG14 */
struct psif_csr_peu_p_req_credit_reg14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 14. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg14 is set to 14, the posted credits for the list 14 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg14 is not 14, the p_return_interval_reg14 determines the rate posted credits are returned to list 14, and p_return_credit_reg14 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg14 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG14 */
struct psif_csr_peu_np_req_credit_reg14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 14. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg14 is set to 14, the non-posted credits for the list 14 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg14 is not 14, the np_return_interval_reg14 determines the rate non-posted credits are returned to list 14, and np_return_credit_reg14 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg14 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG14 */
struct psif_csr_peu_p_return_credit_reg14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 14. The interval at which posted credits are returned to list 14 is set by p_return_interval_reg14 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg14 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG14 */
struct psif_csr_peu_np_return_credit_reg14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 14. The interval at which non-posted credits are returned to list 14 is set by np_return_interval_reg14 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg14 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG14 */
struct psif_csr_peu_p_return_interval_reg14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 14. The amount of posted credits returned is determined by p_return_credit_reg14 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg14 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG14 */
struct psif_csr_peu_np_return_interval_reg14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 14. The amount of non-posted credits returned is determined by np_return_credit_reg14 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg14 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD14 */
struct psif_csr_peu_q_np_tag_cnt_thld14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 14, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 14 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld14 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD14 */
struct psif_csr_peu_xadm_ph_cdts_thld14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 14. If the Posted Header credits falls below this threshold then servicing of posted request out of list 14 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld14 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD14 */
struct psif_csr_peu_xadm_pd_cdts_thld14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 14. If the Posted Data credits falls below this threshold then servicing of posted request out of list 14 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld14 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD14 */
struct psif_csr_peu_xadm_nph_cdts_thld14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 14. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 14 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld14 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD14 */
struct psif_csr_peu_xadm_npd_cdts_thld14 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 14. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 14 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld14 [64 bits] */

/* CSR automated type for PEU_P_REQ_CREDIT_REG15 */
struct psif_csr_peu_p_req_credit_reg15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for posted requests for list 15. Each time XIU transmits a posted request the Posted credits for the list are decremented by number of DW's in the posted request. If p_return_interval_reg15 is set to 15, the posted credits for the list 15 are set to the value in this register once all lists have used up their credits or when all lists are empty. If p_return_interval_reg15 is not 15, the p_return_interval_reg15 determines the rate posted credits are returned to list 15, and p_return_credit_reg15 determines the amount of credit returned.
	 */
	u64	p_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_credit_reg15 [64 bits] */

/* CSR automated type for PEU_NP_REQ_CREDIT_REG15 */
struct psif_csr_peu_np_req_credit_reg15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = -1
	 This field sets the initial DW credits for non-posted requests for list 15. Each time XIU transmits a non-posted request the Non-Posted credits for the list are decremented by number of DW's in the non-posted request. If np_return_interval_reg15 is set to 15, the non-posted credits for the list 15 are set to the value in this register once all lists have used up their credits or when all lists are empty. If np_return_interval_reg15 is not 15, the np_return_interval_reg15 determines the rate non-posted credits are returned to list 15, and np_return_credit_reg15 determines the amount of credit returned.
	 */
	u64	np_req_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_credit_reg15 [64 bits] */

/* CSR automated type for PEU_P_RETURN_CREDIT_REG15 */
struct psif_csr_peu_p_return_credit_reg15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of posted credits, in DW units, returned to list 15. The interval at which posted credits are returned to list 15 is set by p_return_interval_reg15 register.
	 */
	u64	p_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_credit_reg15 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_CREDIT_REG15 */
struct psif_csr_peu_np_return_credit_reg15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field sets the amount of non-posted credits, in DW units, returned to list 15. The interval at which non-posted credits are returned to list 15 is set by np_return_interval_reg15 register.
	 */
	u64	np_return_credit:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_credit_reg15 [64 bits] */

/* CSR automated type for PEU_P_RETURN_INTERVAL_REG15 */
struct psif_csr_peu_p_return_interval_reg15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which posted credits are returned to list 15. The amount of posted credits returned is determined by p_return_credit_reg15 register.
	 */
	u32	p_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_return_interval_reg15 [64 bits] */

/* CSR automated type for PEU_NP_RETURN_INTERVAL_REG15 */
struct psif_csr_peu_np_return_interval_reg15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 This field sets the interval at which non-posted credits are returned to list 15. The amount of non-posted credits returned is determined by np_return_credit_reg15 register.
	 */
	u32	np_return_credit_interval; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_return_interval_reg15 [64 bits] */

/* CSR automated type for PEU_Q_NP_TAG_CNT_THLD15 */
struct psif_csr_peu_q_np_tag_cnt_thld15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:9] RO reset = 0
	 Always read as zero.
	 */
	u64	:55; /* 55 bits @ offs 0:0 */
	/* bit[8:0] RW reset = 0
	 This field sets the min threshold, for list 15, of total number of PCIe tags available for non-posted request. If the number of available PCIe tags, for non-posted requests, falls below this threshold then servicing of non-posted request out of list 15 is halted.
	 */
	u64	q_np_tag_cnt_thld:9; /* 9 bits @ offs 0:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_q_np_tag_cnt_thld15 [64 bits] */

/* CSR automated type for PEU_XADM_PH_CDTS_THLD15 */
struct psif_csr_peu_xadm_ph_cdts_thld15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Posted Header credits for list 15. If the Posted Header credits falls below this threshold then servicing of posted request out of list 15 is halted.
	 */
	u64	xadm_ph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_ph_cdts_thld15 [64 bits] */

/* CSR automated type for PEU_XADM_PD_CDTS_THLD15 */
struct psif_csr_peu_xadm_pd_cdts_thld15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Posted Data credits for list 15. If the Posted Data credits falls below this threshold then servicing of posted request out of list 15 is halted.
	 */
	u64	xadm_pd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_pd_cdts_thld15 [64 bits] */

/* CSR automated type for PEU_XADM_NPH_CDTS_THLD15 */
struct psif_csr_peu_xadm_nph_cdts_thld15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Header credits for list 15. If the Non-Posted Header credits falls below this threshold then servicing of non-posted request out of list 15 is halted.
	 */
	u64	xadm_nph_cdts_thld:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_nph_cdts_thld15 [64 bits] */

/* CSR automated type for PEU_XADM_NPD_CDTS_THLD15 */
struct psif_csr_peu_xadm_npd_cdts_thld15 {
	/* *** 64 bit group 0 start *** */
	/* bit[63:12] RO reset = 0
	 Always read as zero.
	 */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* bit[11:0] RW reset = 0
	 This field sets the min threshold of Non-Posted Data credits for list 15. If the Non-Posted Data credits falls below this threshold then servicing of non-posted request out of list 15 is halted.
	 */
	u64	xadm_npd_cdts_thld:12; /* 12 bits @ offs 0:52 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_xadm_npd_cdts_thld15 [64 bits] */

/* CSR automated type for PEU_HPRI_Q_REG */
struct psif_csr_peu_hpri_q_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 These bits form a vector for high priority queue. Each bit in this field corresponds to a list within the XIU LLQ. Lists which are designated as high priority are serviced 1st before low priority lists are serviced.
	 */
	u64	hi_pri_q:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_hpri_q_reg [64 bits] */

/* CSR automated type for PEU_HPRI_RR_WEIGHT_REG */
struct psif_csr_peu_hpri_rr_weight_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 This field controls the weight of servicing high priority lists within XIU LLQ. Initially the value in this field is loaded into a counter for high priority requests, and each time a high priority list is serviced the counter is decremented. Once the counter reaches 0, the low priority lists are sampled for service. The weight counter is reloaded when low priority lists are serviced once. If the value in this register is set to 0 then the high priority list are serviced 1st, and when there are no high priority requests the low priority lists are serviced.
	 */
	u64	hi_pri_rr_wt:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_hpri_rr_weight_reg [64 bits] */

/* CSR automated type for PEU_MAX_RD_REQ_SIZE_REG */
struct psif_csr_peu_max_rd_req_size_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:3] RO reset = 0
	 Always read as zero.
	 */
	u64	:61; /* 61 bits @ offs 0:0 */
	/* bit[2:0] RW reset = 5
	 This register can override the value set in PCIe config register 'Max Read Size' (set by OS), if the value in this register is smaller. The following are different values this register can take: 
	 3'b000 : max read size = 128 
	 3'b001 : max read size = 256 
	 3'b010 : max read size = 512 
	 3'b011 : max read size = 1024 
	 3'b100 : max read size = 2048 
	 3'b101 : max read size = 4096 
	 3'b110 : max read size = 4096 
	 3'b111 : max read size = 4096 
	 */
	u64	max_rd_req_size:3; /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_max_rd_req_size_reg [64 bits] */

/* CSR automated type for PEU_DIRTY_PCI_TAG_CTL_REG */
struct psif_csr_peu_dirty_pci_tag_ctl_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RW reset = 0
	 This field sets the number of clocks it takes before a PCI tag is freed from dirty pool. A value of 0 disables freeing of 'dirty' PCI tags.
	 */
	u32	drty_tag_period; /* 32 bits @ offs 0:0 */
	/* bit[31:1] RO reset = 0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:32 */
	/* bit[0] RW reset = 0
	 This bit, when set to 1, frees all 'dirty' PCI tags.
	 */
	u32	clr_drty_tag:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_dirty_pci_tag_ctl_reg [64 bits] */

/* CSR automated type for PEU_MASTER_VEC_ST_REG */
struct psif_csr_peu_master_vec_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:34] RO reset = 0
	 Always read as zero.
	 */
	u64	:30; /* 30 bits @ offs 0:0 */
	/* bit[33] W_1_C reset = 0
	 This bit, when set to 1, indicate memory space enable has been de-asserted.
	 */
	u64	mem_space_negedge:1; /* 1 bits @ offs 0:30 */
	/* bit[32:0] W_1_C reset = 0
	 These bit, when set to 1, indicate bus master enable for the corresponding UF has been de-asserted.
	 */
	u64	bme_negedge:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_master_vec_st_reg [64 bits] */

/* CSR automated type for PEU_MASTER_VEC_MSK_REG */
struct psif_csr_peu_master_vec_msk_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:34] RO reset = 0
	 Always read as zero.
	 */
	u64	:30; /* 30 bits @ offs 0:0 */
	/* bit[33:0] RW reset = 17179869183
	 These bit, when set to 1, mask the setting of fatal error due to assertion of the corresponding bit in the master_vec_st_reg register.
	 */
	u64	master_fatal_mask:34; /* 34 bits @ offs 0:30 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_master_vec_msk_reg [64 bits] */

/* CSR automated type for PEU_FLR_REQ_DBG_REG */
struct psif_csr_peu_flr_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 These bit, when set to 1, indicate the FLR request for the corresponding UF is asserted.
	 */
	u64	flr_active:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_flr_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_FLR_DONE_DBG_REG */
struct psif_csr_peu_flr_done_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 These bit, when set to 1, indicate the FLR done for the corresponding UF is asserted.
	 */
	u64	flr_done:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_flr_done_dbg_reg [64 bits] */

/* CSR automated type for PEU_FLR_REQ_VEC_ST_REG */
struct psif_csr_peu_flr_req_vec_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] W_1_C reset = 0
	 These bit, when set to 1, indicate the FLR request for the corresponding UF has detected a positive edge. EPS should use this register to detect onset of FLR's.
	 */
	u64	flr_req_posedge:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_flr_req_vec_st_reg [64 bits] */

/* CSR automated type for PEU_FLR_DONE_VEC_ST_REG */
struct psif_csr_peu_flr_done_vec_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] W_1_C reset = 0
	 These bit, when set to 1, indicate the FLR done for the corresponding UF has detected a positive edge. EPS should use this register to detect completion of FLR's.
	 */
	u64	flr_done_posedge:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_flr_done_vec_st_reg [64 bits] */

/* CSR automated type for PEU_TAG_POOL_DBG_REG */
struct psif_csr_peu_tag_pool_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:47] RO reset = 0
	 Always read as zero.
	 */
	u64	:17; /* 17 bits @ offs 0:0 */
	/* bit[46] RO reset = 0
	 When set to 1, this bit indicates the PIO tag pool is empty.
	 */
	u64	pio_tag_empty:1; /* 1 bits @ offs 0:17 */
	/* bit[45] RO reset = 1
	 When set to 1, this bit indicates the Quick PCIe tag pool is empty.
	 */
	u64	pci_quick_tag_empty:1; /* 1 bits @ offs 0:18 */
	/* bit[44:36] RO reset = 0
	 Count of Quick PCIe tags.
	 */
	u64	pci_quick_tag_cnt:9; /* 9 bits @ offs 0:19 */
	/* bit[35:34] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:28 */
	/* bit[33] RO reset = 1
	 When set to 1, this bit indicates the Dirty PCIe tag pool is empty.
	 */
	u64	pci_dirty_tag_empty:1; /* 1 bits @ offs 0:30 */
	/* bit[32:24] RO reset = 0
	 Count of Dirty PCIe tags.
	 */
	u64	pci_dirty_tag_cnt:9; /* 9 bits @ offs 0:31 */
	/* bit[23:22] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:40 */
	/* bit[21] RO reset = 0
	 When set to 1, this bit indicates the free PCIe tag pool is empty.
	 */
	u64	pci_tag_empty:1; /* 1 bits @ offs 0:42 */
	/* bit[20:12] RO reset = 256
	 Count of free PCIe tags.
	 */
	u64	pci_tag_cnt:9; /* 9 bits @ offs 0:43 */
	/* bit[11] RO reset = 0
	 Always read as zero.
	 */
	u64	:1; /* 1 bits @ offs 0:52 */
	/* bit[10] RO reset = 0
	 When set to 1, this bit indicates the free meta tag pool is empty.
	 */
	u64	meta_tag_empty:1; /* 1 bits @ offs 0:53 */
	/* bit[9:0] RO reset = 512
	 Count of free meta tags.
	 */
	u64	meta_tag_cnt:10; /* 10 bits @ offs 0:54 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_tag_pool_dbg_reg [64 bits] */

/* CSR automated type for PEU_LTSSM_DBG_REG */
struct psif_csr_peu_ltssm_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:36] RO reset = 0
	 Always read as zero.
	 */
	u64	:28; /* 28 bits @ offs 0:0 */
	/* bit[35:20] W_1_C reset = 0
	 These bits indicate the corresponding lane has detected an invalid dirfeedback value. Each bit correspond to a PCIe lane.
	 */
	u64	invalid_dirfeedback:16; /* 16 bits @ offs 0:28 */
	/* bit[19] RO reset = 0
	 Always read as zero.
	 */
	u64	:1; /* 1 bits @ offs 0:44 */
	/* bit[18:12] RO reset = 0
	 These bits indicate the count of LTSSM states in the LTSSM debug FIFO. There can be maximum of 128 states in this FIFO.
	 */
	u64	ltssm_dbg_ff_dc:7; /* 7 bits @ offs 0:45 */
	/* bit[11:10] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:52 */
	/* bit[9] RO reset = 0
	 When set to 1, this bit indicates the LTSSM debug FIFO is full.
	 */
	u64	ltssm_dbg_ff_full:1; /* 1 bits @ offs 0:54 */
	/* bit[8] RO reset = 0
	 When set to 1, this bit indicates the LTSSM debug FIFO is empty.
	 */
	u64	ltssm_dbg_ff_empty:1; /* 1 bits @ offs 0:55 */
	/* bit[7] RO reset = 0
	 Always read as zero.
	 */
	u64	:1; /* 1 bits @ offs 0:56 */
	/* bit[6:0] RO reset = 0
	 Head of LTSSM debug FIFO.
	 */
	u64	ltssm_dbg_ff_do:7; /* 7 bits @ offs 0:57 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ltssm_dbg_reg [64 bits] */

/* CSR automated type for PEU_TSU_REQ_DBG_REG */
struct psif_csr_peu_tsu_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 8589934591
	 This bit vector, when set to 1, indicate zero TSU requests for the corresponding UF in the XIU entry FIFO.
	 */
	u64	tsu_entry_ff_req_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_tsu_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_EPS_REQ_DBG_REG */
struct psif_csr_peu_eps_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 8589934591
	 This bit vector, when set to 1, indicate zero EPS requests for the corresponding UF in the XIU entry FIFO.
	 */
	u64	eps_entry_ff_req_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_eps_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_P_REQ_DBG_REG */
struct psif_csr_peu_p_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 8589934591
	 This bit vector, when set to 1, indicate zero Posted requests for the corresponding UF stored in XIU.
	 */
	u64	p_stored_req_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_p_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_NP_REQ_DBG_REG */
struct psif_csr_peu_np_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 8589934591
	 This bit vector, when set to 1, indicate zero Non-Posted requests for the corresponding UF stored in XIU.
	 */
	u64	np_stored_req_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_np_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_DBI_CSR_WDAT_REG */
struct psif_csr_peu_dbi_csr_wdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 Write data of the DBI interface to the EP core. This register should be written first, in-case of write command, before the dbi_csr_cmd_reg register is written
	 */
	u32	dbi_wdata; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_dbi_csr_wdat_reg [64 bits] */

/* CSR automated type for PEU_DBI_CSR_CMD_REG */
struct psif_csr_peu_dbi_csr_cmd_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:43] RO reset = 0
	 Always read as zero.
	 */
	u32	:21; /* 21 bits @ offs 0:0 */
	/* bit[42] RW reset = 0
	 State of CS2 for the command being issued on the DBI interface to the EP core
	 */
	u32	dbi_cs2:1; /* 1 bits @ offs 0:21 */
	/* bit[41:36] RW reset = 0
	 Function ID of the command being issued on the DBI interface to the EP core: 
	 0 = PF 
	 1 = VF0 
	 .... 
	 32 = VF31 
	 */
	u32	dbi_uf:6; /* 6 bits @ offs 0:22 */
	/* bit[35:32] RW reset = 0
	 Command being issued to the DBI interface of the EP core: 
	 0 = Read 
	 1 = Write B0 
	 2 = Write B1 
	 4 = Write B2 
	 8 = Write B3 
	 F = Write B3-B0 
	 */
	u32	dbi_cmd:4; /* 4 bits @ offs 0:28 */
	/* bit[31:0] RW reset = 0
	 EP core register address on the DBI interface. In case of write command, this register should be written after dbi_csr_wdat_reg register is written
	 */
	u32	dbi_addr; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_dbi_csr_cmd_reg [64 bits] */

/* CSR automated type for PEU_DBI_CSR_STATUS_REG */
struct psif_csr_peu_dbi_csr_status_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:2] RO reset = 0
	 Always read as zero.
	 */
	u64	:62; /* 62 bits @ offs 0:0 */
	/* bit[1] RO reset = 0
	 DBI Busy indicator. This bit is set to 1 when a transaction on the DBI bus is in progress. No new command should be issued while this bit is set to 1, otherwise the command will be ignored
	 */
	u64	dbi_busy:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 DBI Command Completion indicator. This bit is set to 1 when a transaction on the DBI bus is completed. No new command should be issued to the EP core until this bit is set to 1. Software has to write 1 to clear this bit.
	 */
	u64	dbi_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_dbi_csr_status_reg [64 bits] */

/* CSR automated type for PEU_DBI_CSR_RDAT_REG */
struct psif_csr_peu_dbi_csr_rdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RO reset = 0
	 Read data from the DBI interface to the EP core. The content of the register read from the EP core is saved in this register until another register within the EP core is read again. The new value is valid only when the DBI_ACK bit is set to 1 and all other bits within the dbi_csr_status_reg register are set to 0.
	 */
	u32	dbi_rdata; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_dbi_csr_rdat_reg [64 bits] */

/* CSR automated type for PEU_CPL_BUF_WATER_MARK_REG */
struct psif_csr_peu_cpl_buf_water_mark_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:26] RO reset = 0
	 Always read as zero.
	 */
	u64	:38; /* 38 bits @ offs 0:0 */
	/* bit[25:15] RW reset = 65
	 This field sets the water-mark for completion header buffer within the EP core. If the space within CPL header buffer falls below this water-mark all NP request generations are halted
	 */
	u64	cpl_hdr_wm:11; /* 11 bits @ offs 0:38 */
	/* bit[14:13] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:49 */
	/* bit[12:0] RW reset = 129
	 This field sets the water-mark for completion data buffer within the EP core. If the space within CPL data buffer falls below this water-mark all NP request generations are halted
	 */
	u64	cpl_dat_wm:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_cpl_buf_water_mark_reg [64 bits] */

/* CSR automated type for PEU_ARB_CPL_BUF_THLD_REG */
struct psif_csr_peu_arb_cpl_buf_thld_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:26] RO reset = 0
	 Always read as zero.
	 */
	u64	:38; /* 38 bits @ offs 0:0 */
	/* bit[25:15] RW reset = 128
	 This field sets the TSU arbitration threshold for space left in the completion header buffer within the EP core. If the space within CPL header buffer falls below this threshold, the TSU request arbiter will stop selecting NP requests
	 */
	u64	arb_cpl_hdr_th:11; /* 11 bits @ offs 0:38 */
	/* bit[14:13] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:49 */
	/* bit[12:0] RW reset = 256
	 This field sets the TSU arbitration threshold for space left in the completion data buffer within the EP core. If the space within CPL data buffer falls below this threshold, the TSU request arbiter will stop selecting NP requests
	 */
	u64	arb_cpl_dat_th:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_arb_cpl_buf_thld_reg [64 bits] */

/* CSR automated type for PEU_CPL_BUF_CREDIT_REG */
struct psif_csr_peu_cpl_buf_credit_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:28] RO reset = 0
	 Always read as zero.
	 */
	u64	:36; /* 36 bits @ offs 0:0 */
	/* bit[27:16] RO reset = 1024
	 This field indicates the total number of credits left in the completion header buffer within the EP core.
	 */
	u64	cpl_hdr_crdt:12; /* 12 bits @ offs 0:36 */
	/* bit[15:14] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:48 */
	/* bit[13:0] RO reset = 2048
	 This field indicates the total number of credits left in the completion data buffer within the EP core.
	 */
	u64	cpl_dat_crdt:14; /* 14 bits @ offs 0:50 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_cpl_buf_credit_reg [64 bits] */

/* CSR automated type for PEU_CPL_MAX_CREDIT_REG */
struct psif_csr_peu_cpl_max_credit_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:28] RO reset = 0
	 Always read as zero.
	 */
	u64	:36; /* 36 bits @ offs 0:0 */
	/* bit[27:16] RW reset = 1024
	 This field sets the maximum number of credits in the completion header buffer within the EP core.
	 */
	u64	max_cpl_hdr_crdt:12; /* 12 bits @ offs 0:36 */
	/* bit[15:14] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:48 */
	/* bit[13:0] RW reset = 2048
	 This field sets the maximum number of credits in the completion data buffer within the EP core.
	 */
	u64	max_cpl_dat_crdt:14; /* 14 bits @ offs 0:50 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_cpl_max_credit_reg [64 bits] */

/* CSR automated type for PEU_PCIE_PHY_CTL_REG */
struct psif_csr_peu_pcie_phy_ctl_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:48] RO reset = 0
	 These bits indicate the state of serdes bit_lock_done.
	 */
	u16	ser_bit_lock_done; /* 16 bits @ offs 0:0 */
	/* bit[47] RO reset = 0
	 This bit indicate the state of serdes config_done.
	 */
	u16	ser_config_done:1; /* 1 bits @ offs 0:16 */
	/* bit[46] RO reset = 0
	 Always read as zero.
	 */
	u16	:1; /* 1 bits @ offs 0:17 */
	/* bit[45:43] RO reset = 0
	 These bits indicate the Power Management D State.
	 */
	u16	pm_dstate:3; /* 3 bits @ offs 0:18 */
	/* bit[42:40] RO reset = 0
	 These bits indicate the current state of Power Management.
	 */
	u16	pm_curnt_state:3; /* 3 bits @ offs 0:21 */
	/* bit[39] RO reset = 0
	 Always read as zero.
	 */
	u16	:1; /* 1 bits @ offs 0:24 */
	/* bit[38] RO reset = 0
	 This bit indicates the state power management PM_STATUS.
	 */
	u16	pm_status:1; /* 1 bits @ offs 0:25 */
	/* bit[37] RO reset = 0
	 This bit indicates the state of aux_pm_en.
	 */
	u16	aux_pm_en:1; /* 1 bits @ offs 0:26 */
	/* bit[36] RO reset = 0
	 This bit indicates the state power management PME_EN.
	 */
	u16	pm_pme_en:1; /* 1 bits @ offs 0:27 */
	/* bit[35] RO reset = 0
	 Always read as zero.
	 */
	u16	:1; /* 1 bits @ offs 0:28 */
	/* bit[34] RO reset = 0
	 This bit, when set to 1, indicates link is in L2 state.
	 */
	u16	pm_linkst_in_l2:1; /* 1 bits @ offs 0:29 */
	/* bit[33] RO reset = 0
	 This bit, when set to 1, indicates link is in L1 state.
	 */
	u16	pm_linkst_in_l1:1; /* 1 bits @ offs 0:30 */
	/* bit[32] RO reset = 0
	 This bit, when set to 1, indicates link is in L0s state.
	 */
	u16	pm_linkst_in_l0s:1; /* 1 bits @ offs 0:31 */
	/* bit[31] RW reset = 0
	 This bit, when set to 1, forces EP core to exit from L1 state.
	 */
	u16	app_req_exit_l1:1; /* 1 bits @ offs 0:32 */
	/* bit[30] RO reset = 0
	 This bit indicate the state of xmlh_ltssm_state_rcvry_eq.
	 */
	u16	xmlh_ltssm_state_rcvry_eq:1; /* 1 bits @ offs 0:33 */
	/* bit[29:24] RO reset = 0
	 These bits indicate the state of LTSSM.
	 */
	u16	xmlh_ltssm_state:6; /* 6 bits @ offs 0:34 */
	/* bit[23] RW reset = 0
	 This bit, when set to 1, enables setting of IDO bit in TLP header of all completions generated by PEU.
	 */
	u16	cpl_ido:1; /* 1 bits @ offs 0:40 */
	/* bit[22:18] RW reset = 0
	 This field control muxing of the diag_status interface of the EP core to the ep_diag_dbg register.
	 */
	u16	ep_diag_mux_ctl:5; /* 5 bits @ offs 0:41 */
	/* bit[17:16] RW reset = 0
	 This field controls the diagnostic input of EP core: 
	 00 = Do nothing 
	 01 = Insert LCRC error 
	 10 = Insert ECRC error 
	 */
	u16	ep_core_diag_ctrl_bus:2; /* 2 bits @ offs 0:46 */
	/* bit[15:8] RW reset = 40
	 This field programs the minimum delay inserted between assertion of PIPE mac_phy_txelecidle and changing of rate input to PIPE block.
	 */
	u16	pipe_rate_delay:8; /* 8 bits @ offs 0:48 */
	/* bit[7] RW reset = 0
	 This bit, when set to 1, enables setting of IDO bit in TLP header of all requests generated by PEU.
	 */
	u16	req_ido:1; /* 1 bits @ offs 0:56 */
	/* bit[6] RW reset = 0
	 This bit, when set to 1, enables the use of BlockAlignControl signal at PEU PIPE interface.
	 */
	u16	pipe_en_blkalign:1; /* 1 bits @ offs 0:57 */
	/* bit[5] RW reset = 0
	 This bit, when set to 1, enables reporting of request with poison bit set from the host.
	 */
	u16	en_poison_rep:1; /* 1 bits @ offs 0:58 */
	/* bit[4] RW reset = 0
	 This bit, when set to 1, enables reporting of unsupported MEMWR requests from the host.
	 */
	u16	en_ur_memwr_rep:1; /* 1 bits @ offs 0:59 */
	/* bit[3] RW reset = 0
	 This bit, when set to 1, causes PEU to return completion status of CA for reads to CBU BAR. If set to 0, PEU will return completion status of SU and data value of 0 for reads to CBU BAR of length less than or equal to 64 bytes. For reads to CBU BAR greater than 64 bytes, PEU will always return completion status of CA.
	 */
	u16	ca_cbu_rd:1; /* 1 bits @ offs 0:60 */
	/* bit[2] RW reset = 0
	 Power Management Wake Up. When set to 1 it asserts apps_pm_xmt_pme input to EP core for 1 pcie_clock.
	 */
	u16	apps_pm_xmt_pme:1; /* 1 bits @ offs 0:61 */
	/* bit[1] RW reset = 0
	 This bit is not used.
	 */
	u16	l1_clk_removal_en:1; /* 1 bits @ offs 0:62 */
	/* bit[0] RW reset = 0
	 This bit, when set to 1, enables LTSSM for link training.
	 */
	u16	ltssm_enable:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_pcie_phy_ctl_reg [64 bits] */

/* CSR automated type for PEU_FORCE_ERR_REG */
struct psif_csr_peu_force_err_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:29] RO reset = 0
	 Always read as zero.
	 */
	u64	:35; /* 35 bits @ offs 0:0 */
	/* bit[28] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core CPL Data Memory.
	 */
	u64	cpl_d_mem_frc_err:1; /* 1 bits @ offs 0:35 */
	/* bit[27] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core CPL Header Memory.
	 */
	u64	cpl_h_mem_frc_err:1; /* 1 bits @ offs 0:36 */
	/* bit[26] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core P Data Memory.
	 */
	u64	p_d_mem_frc_err:1; /* 1 bits @ offs 0:37 */
	/* bit[25] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core P Header Memory.
	 */
	u64	p_h_mem_frc_err:1; /* 1 bits @ offs 0:38 */
	/* bit[24] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core NP Data Memory.
	 */
	u64	np_d_mem_frc_err:1; /* 1 bits @ offs 0:39 */
	/* bit[23] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core NP Header Memory.
	 */
	u64	np_h_mem_frc_err:1; /* 1 bits @ offs 0:40 */
	/* bit[22] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core SOTBUF Memory.
	 */
	u64	sotbuf_mem_frc_err:1; /* 1 bits @ offs 0:41 */
	/* bit[21] RW reset = 0
	 This bit, when set to 1, will force parity error in EP core RBUF Memory.
	 */
	u64	rbuf_mem_frc_err:1; /* 1 bits @ offs 0:42 */
	/* bit[20] RW reset = 1
	 This bit, when set to 1, masks generation of fatal error due to EP Core memory uncorrectable errors.
	 */
	u64	mask_ep_mem_fatal_err:1; /* 1 bits @ offs 0:43 */
	/* bit[19] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in TSU Pulled data FIFO Memory.
	 */
	u64	tsu_req_dat_ff_frc_derr:1; /* 1 bits @ offs 0:44 */
	/* bit[18] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in EPS Pulled data FIFO Memory.
	 */
	u64	eps_req_dat_ff_frc_derr:1; /* 1 bits @ offs 0:45 */
	/* bit[17] RW reset = 1
	 This bit, when set to 1, masks generation of fatal error due to Pulled Meta Data memory uncorrectable errors.
	 */
	u64	mask_req_data_fatal_err:1; /* 1 bits @ offs 0:46 */
	/* bit[16] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in TSU request FIFO Memory.
	 */
	u64	tsu_p_np_req_tlp_h_ff_frc_derr:1; /* 1 bits @ offs 0:47 */
	/* bit[15] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in EPS request FIFO Memory.
	 */
	u64	eps_p_np_req_tlp_h_ff_frc_derr:1; /* 1 bits @ offs 0:48 */
	/* bit[14] RW reset = 1
	 This bit, when set to 1, masks generation of fatal error in Meta request path.
	 */
	u64	mask_req_fatal_err:1; /* 1 bits @ offs 0:49 */
	/* bit[13] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in MSIX Table Memory.
	 */
	u64	msix_table_mem_frc_derr:1; /* 1 bits @ offs 0:50 */
	/* bit[12] RW reset = 0
	 This bit, when set to 1, will force single bit ECC error in MSIX Table Memory.
	 */
	u64	msix_table_mem_frc_serr:1; /* 1 bits @ offs 0:51 */
	/* bit[11] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in eprom read FIFO Memory.
	 */
	u64	eprm_rd_dat_ff_frc_derr:1; /* 1 bits @ offs 0:52 */
	/* bit[10] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in PCIe UF Memory.
	 */
	u64	pci_uf_mem_frc_derr:1; /* 1 bits @ offs 0:53 */
	/* bit[9] RW reset = 0
	 This bit, when set to 1, will force single bit ECC error in PCIe UF Memory.
	 */
	u64	pci_uf_mem_frc_serr:1; /* 1 bits @ offs 0:54 */
	/* bit[8] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in shadow Meta Context Memory.
	 */
	u64	shd_meta_cntxt_mem_frc_derr:1; /* 1 bits @ offs 0:55 */
	/* bit[7] RW reset = 0
	 This bit, when set to 1, will force single bit ECC error in shadow Meta Context Memory.
	 */
	u64	shd_meta_cntxt_mem_frc_serr:1; /* 1 bits @ offs 0:56 */
	/* bit[6] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in Meta Context Memory.
	 */
	u64	meta_cntxt_mem_frc_derr:1; /* 1 bits @ offs 0:57 */
	/* bit[5] RW reset = 0
	 This bit, when set to 1, will force single bit ECC error in Meta Context Memory.
	 */
	u64	meta_cntxt_mem_frc_serr:1; /* 1 bits @ offs 0:58 */
	/* bit[4] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in shadow PCIe Context Memory.
	 */
	u64	shd_pci_cntxt_mem_frc_derr:1; /* 1 bits @ offs 0:59 */
	/* bit[3] RW reset = 0
	 This bit, when set to 1, will force single bit ECC error in shadow PCIe Context Memory.
	 */
	u64	shd_pci_cntxt_mem_frc_serr:1; /* 1 bits @ offs 0:60 */
	/* bit[2] RW reset = 0
	 This bit, when set to 1, will force double bit ECC error in PCIe Context Memory.
	 */
	u64	pci_cntxt_mem_frc_derr:1; /* 1 bits @ offs 0:61 */
	/* bit[1] RW reset = 0
	 This bit, when set to 1, will force single bit ECC error in PCIe Context Memory.
	 */
	u64	pci_cntxt_mem_frc_serr:1; /* 1 bits @ offs 0:62 */
	/* bit[0] RW reset = 0
	 This bit, when set to 1, masks generation of fatal error in Meta Response data path.
	 */
	u64	mask_cpl_fatal_err:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_force_err_reg [64 bits] */

/* CSR automated type for PEU_MSG_GEN_QW0_REG */
struct psif_csr_peu_msg_gen_qw0_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:46] RO reset = 0
	 Always read as zero.
	 */
	u32	:18; /* 18 bits @ offs 0:0 */
	/* bit[45:40] RW reset = 0
	 This field specifies the Vendor Message Function ID.
	 */
	u32	ven_msg_uf:6; /* 6 bits @ offs 0:18 */
	/* bit[39:37] RO reset = 0
	 Always read as zero.
	 */
	u32	:3; /* 3 bits @ offs 0:24 */
	/* bit[36:32] RW reset = 0
	 This field specifies the Vendor Message Type in the message TLP header.
	 */
	u32	ven_msg_type:5; /* 5 bits @ offs 0:27 */
	/* bit[31:30] RO reset = 0
	 Always read as zero.
	 */
	u16	:2; /* 2 bits @ offs 0:32 */
	/* bit[29:20] RW reset = 0
	 This field specifies the Vendor Message Length in the message TLP header.
	 */
	u16	ven_msg_len:10; /* 10 bits @ offs 0:34 */
	/* bit[19] RW reset = 0
	 This bit specifies the Vendor Message TD in the message TLP header.
	 */
	u16	ven_msg_td:1; /* 1 bits @ offs 0:44 */
	/* bit[18:16] RW reset = 0
	 This field specifies the Vendor Message Attribute in the message TLP header.
	 */
	u16	ven_msg_attr:3; /* 3 bits @ offs 0:45 */
	/* bit[15:8] RW reset = 0
	 This field specifies the Vendor Message Tag in the message TLP header.
	 */
	u16	ven_msg_tag:8; /* 8 bits @ offs 0:48 */
	/* bit[7:0] RW reset = 0
	 This field specifies the Vendor Message Code in the message TLP header.
	 */
	u16	ven_msg_code:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_msg_gen_qw0_reg [64 bits] */

/* CSR automated type for PEU_MSG_GEN_QW1_REG */
struct psif_csr_peu_msg_gen_qw1_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 0
	 This field specifies the Vendor Message Data in the message TLP. A CSR write to this register will cause a vendor TLP to be transmitted
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_msg_gen_qw1_reg [64 bits] */

/* CSR automated type for PEU_MSG_STATUS_REG */
struct psif_csr_peu_msg_status_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:44] RO reset = 0
	 Always read as zero.
	 */
	u64	:20; /* 20 bits @ offs 0:0 */
	/* bit[43:28] RC reset = 0
	 This field indicates the count of PM_TOFF Messages received. This counter rolls over once max value is reached.
	 */
	u64	pm_toff_msg_cnt:16; /* 16 bits @ offs 0:20 */
	/* bit[27:20] RC reset = 0
	 This field indicates the count of Unlock Messages received. This counter rolls over once max value is reached.
	 */
	u64	unlock_msg_cnt:8; /* 8 bits @ offs 0:36 */
	/* bit[19:12] RC reset = 0
	 This field indicates the count of Vendor Messages received. This counter rolls over once max value is reached.
	 */
	u64	vendor_msg_cnt:8; /* 8 bits @ offs 0:44 */
	/* bit[11] RO reset = 0
	 Always read as zero.
	 */
	u64	:1; /* 1 bits @ offs 0:52 */
	/* bit[10:4] RO reset = 0
	 This field indicates the number of entries in ATS message FIFO.
	 */
	u64	ats_msg_ff_dc:7; /* 7 bits @ offs 0:53 */
	/* bit[3] RO reset = 0
	 Always read as zero.
	 */
	u64	:1; /* 1 bits @ offs 0:60 */
	/* bit[2] RO reset = 0
	 This bit, when set to 1, indicates ATS message FIFO is full.
	 */
	u64	ats_msg_ff_full:1; /* 1 bits @ offs 0:61 */
	/* bit[1] RO reset = 1
	 This bit, when set to 1, indicates ATS message FIFO is empty.
	 */
	u64	ats_msg_ff_empty:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 This bit, when set to 1, indicates a Vendor Message was transmitted to the host on PCIe.
	 */
	u64	ven_msg_tx_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_msg_status_reg [64 bits] */

/* CSR automated type for PEU_ATS_MSG_QW0_REG */
struct psif_csr_peu_ats_msg_qw0_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:46] RO reset = 0
	 Always read as zero.
	 */
	u64	:18; /* 18 bits @ offs 0:0 */
	/* bit[45:40] RO reset = 0
	 This field indicates the function ID (UF) of the received ATS message at the head of the ATS message FIFO.
	 */
	u64	ats_msg_uf:6; /* 6 bits @ offs 0:18 */
	/* bit[39:24] RO reset = 0
	 This field indicates the request ID of the received ATS message at the head of the ATS message FIFO.
	 */
	u64	ats_msg_reqid:16; /* 16 bits @ offs 0:24 */
	/* bit[23:8] RO reset = 0
	 This field indicates the device ID of the received ATS message at the head of the ATS message FIFO.
	 */
	u64	ats_msg_devid:16; /* 16 bits @ offs 0:40 */
	/* bit[7:0] RO reset = 0
	 This field indicates the tag ID of the received ATS message at the head of the ATS message FIFO.
	 */
	u64	ats_msg_itag:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ats_msg_qw0_reg [64 bits] */

/* CSR automated type for PEU_ATS_MSG_QW1_REG */
struct psif_csr_peu_ats_msg_qw1_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:53] RO reset = 0
	 Always read as zero.
	 */
	u64	:11; /* 11 bits @ offs 0:0 */
	/* bit[52:1] RO reset = 0
	 This field indicates the Untranslated address field of the received ATS Invalidate Request message at the head of the ATS message FIFO. Read of this register removes the entry at the head of the ATS message FIFO.
	 */
	u64	ats_msg_untran_addr:52; /* 52 bits @ offs 0:11 */
	/* bit[0] RO reset = 0
	 This bit indicates the state of the S bit in the received ATS Invalidate Request message at the head of the ATS message FIFO. Read of this register removes the entry at the head of the ATS message FIFO.
	 */
	u64	ats_msg_s:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ats_msg_qw1_reg [64 bits] */

/* CSR automated type for PEU_SRAM_CORR_ERR_STATUS_REG */
struct psif_csr_peu_sram_corr_err_status_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:7] RO reset = 0
	 Always read as zero.
	 */
	u64	:57; /* 57 bits @ offs 0:0 */
	/* bit[6] W_1_C reset = 0
	 This bit, when set to 1, indicates an uncorrectable error in the Timeout Response FIFO memory.
	 */
	u64	tout_resp_ff_err_st:1; /* 1 bits @ offs 0:57 */
	/* bit[5] W_1_C reset = 0
	 This bit, when set to 1, indicates a single bit error in the MSIX table memory was corrected.
	 */
	u64	msix_table_mem_corr_err_st:1; /* 1 bits @ offs 0:58 */
	/* bit[4] W_1_C reset = 0
	 This bit, when set to 1, indicates a single bit error in the PCI context memory was corrected.
	 */
	u64	pci_cntxt_mem_corr_err_st:1; /* 1 bits @ offs 0:59 */
	/* bit[3] W_1_C reset = 0
	 This bit, when set to 1, indicates a single bit error in the shadow PCI context memory was corrected.
	 */
	u64	shd_pci_cntxt_mem_corr_err_st:1; /* 1 bits @ offs 0:60 */
	/* bit[2] W_1_C reset = 0
	 This bit, when set to 1, indicates a single bit error in the meta context memory was corrected.
	 */
	u64	meta_cntxt_mem_corr_err_st:1; /* 1 bits @ offs 0:61 */
	/* bit[1] W_1_C reset = 0
	 This bit, when set to 1, indicates a single bit error in the shadow meta context memory was corrected.
	 */
	u64	shd_meta_cntxt_mem_corr_err_st:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 This bit, when set to 1, indicates a single bit error in the PCI UF memory was corrected.
	 */
	u64	pci_uf_mem_corr_err_st:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_sram_corr_err_status_reg [64 bits] */

/* CSR automated type for PEU_HI_PRI_MSK_REG */
struct psif_csr_peu_hi_pri_msk_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7:0] RW reset = -1
	 This is a bit vector which can mask the corresponding bit in the hi_pri_intr_vec_reg register from generating a high priority interrupt. A value of 1 will disable generation of interrupt.
	 */
	u64	hi_pri_intr_msk:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_hi_pri_msk_reg [64 bits] */

/* CSR automated type for PEU_HI_PRI_INTR_VEC_REG */
struct psif_csr_peu_hi_pri_intr_vec_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:8] RO reset = 0
	 Always read as zero.
	 */
	u64	:56; /* 56 bits @ offs 0:0 */
	/* bit[7] RO reset = 0
	 This bit, when set to 1, indicates at least 1 FLR done has been asserted.
	 */
	u64	flr_done_st:1; /* 1 bits @ offs 0:56 */
	/* bit[6] RO reset = 0
	 This bit, when set to 1, indicates at least 1 FLR request has been asserted.
	 */
	u64	flr_req_st:1; /* 1 bits @ offs 0:57 */
	/* bit[5] RO reset = 0
	 This bit, when set to 1, indicates the PM Toff message count is not zero.
	 */
	u64	pm_toff_msg_cnt_not_zero:1; /* 1 bits @ offs 0:58 */
	/* bit[4] RO reset = 0
	 This bit, when set to 1, indicates the Unlock message count is not zero.
	 */
	u64	unlock_msg_cnt_not_zero:1; /* 1 bits @ offs 0:59 */
	/* bit[3] RO reset = 0
	 This bit, when set to 1, indicates the Vendor message count is not zero.
	 */
	u64	vend_msg_cnt_not_zero:1; /* 1 bits @ offs 0:60 */
	/* bit[2] RO reset = 0
	 This bit, when set to 1, indicates the ATS message FIFO is not empty, and at least one ATS Invalidate Request message is received.
	 */
	u64	ats_msg_ff_not_empty:1; /* 1 bits @ offs 0:61 */
	/* bit[1] RO reset = 0
	 This bit, when set to 1, indicates a Vendor Message was transmitted on PCIe.
	 */
	u64	ven_msg_tx_ack:1; /* 1 bits @ offs 0:62 */
	/* bit[0] RO reset = 0
	 This bit, when set to 1, indicates DBI CSR access has received an ACK.
	 */
	u64	dbi_csr_resp_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_hi_pri_intr_vec_reg [64 bits] */

/* CSR automated type for PEU_FATAL_INTR_MSK_REG */
struct psif_csr_peu_fatal_intr_msk_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:27] RO reset = 0
	 Always read as zero.
	 */
	u64	:37; /* 37 bits @ offs 0:0 */
	/* bit[26:0] RW reset = 134217727
	 This is a bit vector which can mask the corresponding bit in the fatal_intr_vec_reg register from generating a fatal interrupt. A value of 1 will disable generation of interrupt.
	 */
	u64	fatal_intr_msk:27; /* 27 bits @ offs 0:37 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_fatal_intr_msk_reg [64 bits] */

/* CSR automated type for PEU_FATAL_INTR_VEC_REG */
struct psif_csr_peu_fatal_intr_vec_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:27] RO reset = 0
	 Always read as zero.
	 */
	u64	:37; /* 37 bits @ offs 0:0 */
	/* bit[26] RO reset = 0
	 This bit, when set to 1, indicates one of the BME bits was de-asserted.
	 */
	u64	master_vec_fatal:1; /* 1 bits @ offs 0:37 */
	/* bit[25] W_1_C reset = 0
	 This bit, when set to 1, indicates the TSU LLQ memory detected an uncorrectable ECC error.
	 */
	u64	tsu_llq_mem_uncorr_err_st:1; /* 1 bits @ offs 0:38 */
	/* bit[24] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core CPL Header memory detected a parity error.
	 */
	u64	cpl_hdr_mem_uncorr_err_st:1; /* 1 bits @ offs 0:39 */
	/* bit[23] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core CPL Data memory detected a parity error.
	 */
	u64	cpl_dat_mem_uncorr_err_st:1; /* 1 bits @ offs 0:40 */
	/* bit[22] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core P Data memory detected a parity error.
	 */
	u64	p_dat_mem_uncorr_err_st:1; /* 1 bits @ offs 0:41 */
	/* bit[21] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core P header memory detected a parity error.
	 */
	u64	p_hdr_mem_uncorr_err_st:1; /* 1 bits @ offs 0:42 */
	/* bit[20] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core NP Data memory detected a parity error.
	 */
	u64	np_dat_mem_uncorr_err_st:1; /* 1 bits @ offs 0:43 */
	/* bit[19] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core NP header memory detected a parity error.
	 */
	u64	np_hdr_mem_uncorr_err_st:1; /* 1 bits @ offs 0:44 */
	/* bit[18] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core SOTBUF memory detected a parity error.
	 */
	u64	sotbuf_mem_uncorr_err_st:1; /* 1 bits @ offs 0:45 */
	/* bit[17] W_1_C reset = 0
	 This bit, when set to 1, indicates the EP core RBUF memory detected a parity error.
	 */
	u64	rbuf_mem_uncorr_err_st:1; /* 1 bits @ offs 0:46 */
	/* bit[16] W_1_C reset = 0
	 This bit, when set to 1, indicates the EPS Pulled data FIFO memory detected an uncorrectable ECC error.
	 */
	u64	eps_req_dat_ff_uncorr_err_st:1; /* 1 bits @ offs 0:47 */
	/* bit[15] W_1_C reset = 0
	 This bit, when set to 1, indicates an error response was received on Pulled data read interface from EPS.
	 */
	u64	eps_req_dat_ff_rcvd_err_st:1; /* 1 bits @ offs 0:48 */
	/* bit[14] W_1_C reset = 0
	 This bit, when set to 1, indicates the TSU Pulled data FIFO memory detected an uncorrectable ECC error.
	 */
	u64	tsu_req_dat_ff_uncorr_err_st:1; /* 1 bits @ offs 0:49 */
	/* bit[13] W_1_C reset = 0
	 This bit, when set to 1, indicates an error response was received on Pulled data read interface from TSU.
	 */
	u64	tsu_req_dat_ff_rcvd_err_st:1; /* 1 bits @ offs 0:50 */
	/* bit[12] W_1_C reset = 0
	 This bit, when set to 1, indicates the TSU request header FIFO memory detected an uncorrectable ECC error.
	 */
	u64	tsu_req_hdr_ff_mem_uncorr_err_st:1; /* 1 bits @ offs 0:51 */
	/* bit[11] W_1_C reset = 0
	 This bit, when set to 1, indicates the EPS request header FIFO memory detected an uncorrectable ECC error.
	 */
	u64	eps_req_hdr_ff_mem_uncorr_err_st:1; /* 1 bits @ offs 0:52 */
	/* bit[10] W_1_C reset = 0
	 This bit, when set to 1, indicates the MSIX table memory detected an uncorrectable ECC error.
	 */
	u64	msix_table_mem_uncorr_err_st:1; /* 1 bits @ offs 0:53 */
	/* bit[9] W_1_C reset = 0
	 This bit, when set to 1, indicates a bad request TLP was received from PCIe RC.
	 */
	u64	trgt1_bad_eop_st:1; /* 1 bits @ offs 0:54 */
	/* bit[8] W_1_C reset = 0
	 This bit, when set to 1, indicates the EPROM Read Data FIFO memory detected an uncorrectable ECC error.
	 */
	u64	eprm_rd_dat_mem_uncorr_err_st:1; /* 1 bits @ offs 0:55 */
	/* bit[7] W_1_C reset = 0
	 This bit, when set to 1, indicates PCI context memory detected an uncorrectable ECC error.
	 */
	u64	pci_cntx_mem_uncorr_err_st:1; /* 1 bits @ offs 0:56 */
	/* bit[6] W_1_C reset = 0
	 This bit, when set to 1, indicates shadow PCI context memory detected an uncorrectable ECC error.
	 */
	u64	shd_pci_cntx_mem_uncorr_err_st:1; /* 1 bits @ offs 0:57 */
	/* bit[5] W_1_C reset = 0
	 This bit, when set to 1, indicates Meta context memory detected an uncorrectable ECC error.
	 */
	u64	meta_cntx_mem_uncorr_err_st:1; /* 1 bits @ offs 0:58 */
	/* bit[4] W_1_C reset = 0
	 This bit, when set to 1, indicates shadow Meta context memory detected an uncorrectable ECC error.
	 */
	u64	shd_meta_cntx_mem_uncorr_err_st:1; /* 1 bits @ offs 0:59 */
	/* bit[3] W_1_C reset = 0
	 This bit, when set to 1, indicates PCI UF memory detected an uncorrectable ECC error.
	 */
	u64	pci_uf_mem_uncorr_err_st:1; /* 1 bits @ offs 0:60 */
	/* bit[2] W_1_C reset = 0
	 This bit, when set to 1, indicates a bad completion TLP was received from PCIe.
	 */
	u64	cpl_bad_eop_st:1; /* 1 bits @ offs 0:61 */
	/* bit[1:0] W_1_C reset = 0
	 These bits, when set to 1, indicates PEU received a CA or UR in completion status.
	 */
	u64	cpl_bad_resp_cmd_st:2; /* 2 bits @ offs 0:62 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_fatal_intr_vec_reg [64 bits] */

/* CSR automated type for PEU_INTR_REQ_DBG_REG */
struct psif_csr_peu_intr_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 This is a bit vector, each bit corresponding to a function. When a bit is set to 1 it indicates the corresponding function does not have any outstanding interrupts.
	 */
	u64	intr_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_intr_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_TSU_PIO_REQ_DBG_REG */
struct psif_csr_peu_tsu_pio_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 This is a bit vector, each bit corresponding to a function. When a bit is set to 1 it indicates the corresponding function does not have any outstanding PIO completions.
	 */
	u64	pio_tsu_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_tsu_pio_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_EPRM_PIO_REQ_DBG_REG */
struct psif_csr_peu_eprm_pio_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:56] RO reset = 0
	 Always read as zero.
	 */
	u64	:8; /* 8 bits @ offs 0:0 */
	/* bit[55:44] RO reset = 0
	 This is field indicates the amount of Posted Data credits available from RC.
	 */
	u64	xadm_pd_cdts:12; /* 12 bits @ offs 0:8 */
	/* bit[43:36] RO reset = 0
	 This is field indicates the amount of Posted Header credits available from RC.
	 */
	u64	xadm_ph_cdts:8; /* 8 bits @ offs 0:20 */
	/* bit[35:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:3; /* 3 bits @ offs 0:28 */
	/* bit[32:0] RO reset = 0
	 This is a bit vector, each bit corresponding to a function. When a bit is set to 1 it indicates the corresponding function does not have any outstanding PIO requests to EPROM.
	 */
	u64	pio_eprm_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_eprm_pio_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_INTR_PIO_REQ_DBG_REG */
struct psif_csr_peu_intr_pio_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:56] RO reset = 0
	 Always read as zero.
	 */
	u64	:8; /* 8 bits @ offs 0:0 */
	/* bit[55:44] RO reset = 0
	 This is field indicates the amount of Non-Posted Data credits available from RC.
	 */
	u64	xadm_npd_cdts:12; /* 12 bits @ offs 0:8 */
	/* bit[43:36] RO reset = 0
	 This is field indicates the amount of Non-Posted Header credits available from RC.
	 */
	u64	xadm_nph_cdts:8; /* 8 bits @ offs 0:20 */
	/* bit[35:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:3; /* 3 bits @ offs 0:28 */
	/* bit[32:0] RO reset = 0
	 This is a bit vector, each bit corresponding to a function. When a bit is set to 1 it indicates the corresponding function does not have any outstanding PIO requests to MSIX table.
	 */
	u64	pio_intr_cnt_zero:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_intr_pio_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_CPL_FLUSH_DBG_REG */
struct psif_csr_peu_cpl_flush_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:56] RO reset = 0
	 Always read as zero.
	 */
	u64	:8; /* 8 bits @ offs 0:0 */
	/* bit[55:44] RO reset = 0
	 This is field indicates the amount of Completion Data credits available from RC.
	 */
	u64	xadm_cpld_cdts:12; /* 12 bits @ offs 0:8 */
	/* bit[43:36] RO reset = 0
	 This is field indicates the amount of Completion Header credits available from RC.
	 */
	u64	xadm_cplh_cdts:8; /* 8 bits @ offs 0:20 */
	/* bit[35:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:3; /* 3 bits @ offs 0:28 */
	/* bit[32:0] RO reset = 0
	 This is a bit vector, each bit corresponding to a function. When a bit is set to 1 it indicates the corresponding function does not have any outstanding Non-posted tags.
	 */
	u64	cpl_flushed:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_cpl_flush_dbg_reg [64 bits] */

/* CSR automated type for PEU_EP_DIAG_DBG_REG */
struct psif_csr_peu_ep_diag_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0
	 This field shows the content of the EP core Muxed diagnostics bus. The mux setting is controlled via EP_DIAG_MUX_CTL field of the pcie_phy_ctl_reg register.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ep_diag_dbg_reg [64 bits] */

/* CSR automated type for PEU_CXPL_EI_DBG_REG */
struct psif_csr_peu_cxpl_ei_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0
	 This field shows the content of the EP core CXPL_DEBUG_INFO_EI bus.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_cxpl_ei_dbg_reg [64 bits] */

/* CSR automated type for PEU_CXPL_DBG_REG */
struct psif_csr_peu_cxpl_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RO reset = 0
	 This field shows the content of the EP core CXPL_DEBUG_INFO bus.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_cxpl_dbg_reg [64 bits] */

/* CSR automated type for PEU_FF_DC_1_DBG_REG */
struct psif_csr_peu_ff_dc_1_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:51] RO reset = 0
	 Always read as zero.
	 */
	u64	:13; /* 13 bits @ offs 0:0 */
	/* bit[50:46] RO reset = 0
	 This is field indicates the number of entries in tsu_req_cmd_ff FIFO.
	 */
	u64	tsu_req_cmd_ff_dc:5; /* 5 bits @ offs 0:13 */
	/* bit[45:40] RO reset = 0
	 This is field indicates the number of entries in tsu_req_dat_ff FIFO.
	 */
	u64	tsu_req_dat_ff_dc:6; /* 6 bits @ offs 0:18 */
	/* bit[39:38] RO reset = 0
	 Always read as zero.
	 */
	u64	:2; /* 2 bits @ offs 0:24 */
	/* bit[37:35] RO reset = 0
	 This is field indicates the number of entries in eps_p_np_cmd_ff FIFO.
	 */
	u64	eps_p_np_cmd_ff_dc:3; /* 3 bits @ offs 0:26 */
	/* bit[34:30] RO reset = 0
	 This is field indicates the number of entries in eps_req_cmd_ff FIFO.
	 */
	u64	eps_req_cmd_ff_dc:5; /* 5 bits @ offs 0:29 */
	/* bit[29:24] RO reset = 0
	 This is field indicates the number of entries in eps_req_dat_ff FIFO.
	 */
	u64	eps_req_dat_ff_dc:6; /* 6 bits @ offs 0:34 */
	/* bit[23:20] RO reset = 0
	 This is field indicates the number of entries in xiu_tsu_pull_ff FIFO.
	 */
	u64	xiu_tsu_pull_ff_dc:4; /* 4 bits @ offs 0:40 */
	/* bit[19:16] RO reset = 0
	 This is field indicates the number of entries in xiu_eps_pull_ff FIFO.
	 */
	u64	xiu_eps_pull_ff_dc:4; /* 4 bits @ offs 0:44 */
	/* bit[15:0] RO reset = 0
	 This is a bit vector, each bit corresponding to one of the 16 TSU receive queues. When a bit is set to 1 it indicates the corresponding TSU receive queue is not empty.
	 */
	u64	llq_not_empty_vec:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ff_dc_1_dbg_reg [64 bits] */

/* CSR automated type for PEU_FF_DC_2_DBG_REG */
struct psif_csr_peu_ff_dc_2_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:28] RO reset = 0
	 Always read as zero.
	 */
	u64	:36; /* 36 bits @ offs 0:0 */
	/* bit[27:25] RO reset = 0
	 This is field indicates the number of entries in tsu_p_req_tlp_d_ff FIFO.
	 */
	u64	tsu_p_req_tlp_d_ff_dc:3; /* 3 bits @ offs 0:36 */
	/* bit[24:18] RO reset = 0
	 This is field indicates the number of entries in tsu_p_np_req_tlp_h_ff FIFO.
	 */
	u64	tsu_p_np_req_tlp_h_ff_dc:7; /* 7 bits @ offs 0:39 */
	/* bit[17:15] RO reset = 0
	 This is field indicates the number of entries in eps_p_req_tlp_d_ff FIFO.
	 */
	u64	eps_p_req_tlp_d_ff_dc:3; /* 3 bits @ offs 0:46 */
	/* bit[14:8] RO reset = 0
	 This is field indicates the number of entries in eps_p_np_req_tlp_h_ff FIFO.
	 */
	u64	eps_p_np_req_tlp_h_ff_dc:7; /* 7 bits @ offs 0:49 */
	/* bit[7:0] RO reset = 0
	 Always read as zero.
	 */
	u64	:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ff_dc_2_dbg_reg [64 bits] */

/* CSR automated type for PEU_FORCE_FLR_REG */
struct psif_csr_peu_force_flr_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RW reset = 0
	 This is a bit vector, each bit corresponding to a function. When a bit is set to 1 it forces FLR done on the corresponding function.
	 */
	u64	flr_done_force:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_force_flr_reg [64 bits] */

/* CSR automated type for PEU_CSR_PEU_CTL_ST_REG */
struct psif_csr_peu_csr_peu_ctl_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:13] RO reset = 0
	 Always read as zero.
	 */
	u64	:51; /* 51 bits @ offs 0:0 */
	/* bit[12] RO reset = 0
	 This bit reflects the state of ser_pllstable_a_1.
	 */
	u64	ser_pllstable_a_1:1; /* 1 bits @ offs 0:51 */
	/* bit[11] RO reset = 0
	 This bit reflects the state of ser_pllstable_a.
	 */
	u64	ser_pllstable_a:1; /* 1 bits @ offs 0:52 */
	/* bit[10] RO reset = 0
	 This bit reflects the state of ser_bit_lock_done.
	 */
	u64	ser_bit_lock_done:1; /* 1 bits @ offs 0:53 */
	/* bit[9] RO reset = 0
	 This bit reflects the state of ser_config_done.
	 */
	u64	ser_config_done:1; /* 1 bits @ offs 0:54 */
	/* bit[8] RO reset = 0
	 This bit reflects the state of ser_txphyready. This applies to lanes 8 to 15. Set to 1 when all 8 lanes are ready.
	 */
	u64	ser_txphyready_1:1; /* 1 bits @ offs 0:55 */
	/* bit[7] RO reset = 0
	 This bit reflects the state of ser_txphyready. This applies to lanes 0 to 7. Set to 1 when all 8 lanes are ready.
	 */
	u64	ser_txphyready:1; /* 1 bits @ offs 0:56 */
	/* bit[6] RO reset = 0
	 This bit reflects the state of ser_rxphyready. This applies to lanes 8 to 15. Set to 1 when all 8 lanes are ready.
	 */
	u64	ser_rxphyready_1:1; /* 1 bits @ offs 0:57 */
	/* bit[5] RO reset = 0
	 This bit reflects the state of ser_rxphyready. This applies to lanes 0 to 7. Set to 1 when all 8 lanes are ready.
	 */
	u64	ser_rxphyready:1; /* 1 bits @ offs 0:58 */
	/* bit[4] RO reset = 0
	 This bit reflects the state of pci_core_rst. When set to 1 pci_core_rst is asserted.
	 */
	u64	pcie_core_rst:1; /* 1 bits @ offs 0:59 */
	/* bit[3] RO reset = 0
	 Always read as zero.
	 */
	u64	:1; /* 1 bits @ offs 0:60 */
	/* bit[2] RW reset = 1
	 This bit, when set to 1, will assert the reset to Serdes reset_a.
	 */
	u64	serdes_reset_a:1; /* 1 bits @ offs 0:61 */
	/* bit[1] RW reset = 1
	 This bit, when set to 1, will assert the reset to Serdes reset_a. This bit and PIPE_HRESET bit should be set the same.
	 */
	u64	ser_hreset:1; /* 1 bits @ offs 0:62 */
	/* bit[0] RW reset = 1
	 This bit, when set to 1, will assert the reset to PIPE AHB block. This bit and SER_HRESET bit should be set the same.
	 */
	u64	pipe_hreset:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_peu_ctl_st_reg [64 bits] */

/* CSR automated type for PEU_CSR_PEU_INT_ST_REG */
struct psif_csr_peu_csr_peu_int_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:5] RO reset = 0
	 Always read as zero.
	 */
	u64	:59; /* 59 bits @ offs 0:0 */
	/* bit[4] RO reset = 0
	 This bit, when set to 1, indicates a low priority event has occurred within PEU. This bit can cause interrupt if corresponding mask bit in csr_peu_int_msk_reg is set to 0.
	 */
	u64	peu_lo_pri_int:1; /* 1 bits @ offs 0:59 */
	/* bit[3] W_1_C reset = 0
	 This bit, when set to 1, indicates a high priority event has occurred within PEU. This bit can cause interrupt if corresponding mask bit in csr_peu_int_msk_reg is set to 0.
	 */
	u64	peu_hi_pri_int:1; /* 1 bits @ offs 0:60 */
	/* bit[2] W_1_C reset = 0
	 This bit, when set to 1, indicates a fatal event has occurred within PEU. This bit can cause interrupt if corresponding mask bit in csr_peu_int_msk_reg is set to 0.
	 */
	u64	peu_fatal_int:1; /* 1 bits @ offs 0:61 */
	/* bit[1] W_1_C reset = 0
	 This bit, when set to 1, indicates Serdes are configured and PCIE core reset is de-asserted. This bit can cause interrupt if corresponding mask bit in csr_peu_int_msk_reg is set to 0.
	 */
	u64	peu_gain_lock_int:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 1
	 This bit, when set to 1, indicates Serdes have lost configuration or PCIE core reset This bit can cause interrupt if corresponding mask bit in csr_peu_int_msk_reg is set to 0.
	 */
	u64	peu_lost_lock_int:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_peu_int_st_reg [64 bits] */

/* CSR automated type for PEU_CSR_PEU_INT_MSK_REG */
struct psif_csr_peu_csr_peu_int_msk_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:5] RO reset = 0
	 Always read as zero.
	 */
	u64	:59; /* 59 bits @ offs 0:0 */
	/* bit[4:0] RW reset = 31
	 Each bit in this register is the interrupt mask bit for the corresponding bit in csr_peu_int_st_reg. When set to 1 the corresponding interrupt to EPS is masked.
	 */
	u64	csr_peu_int_mask:5; /* 5 bits @ offs 0:59 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_peu_int_msk_reg [64 bits] */

/* CSR automated type for PEU_CSR_LP_INTR_VEC_REG */
struct psif_csr_peu_csr_lp_intr_vec_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:3] RO reset = 0
	 Always read as zero.
	 */
	u64	:61; /* 61 bits @ offs 0:0 */
	/* bit[2] W_1_C reset = 0
	 This bit, when set to 1, indicates access to Serdes (block 1) AHB bus has returned an ack. This bit can cause interrupt if corresponding mask bit in ahb_lp_int_msk_reg is set to 0.
	 */
	u64	ser_1_ahb_ack:1; /* 1 bits @ offs 0:61 */
	/* bit[1] W_1_C reset = 0
	 This bit, when set to 1, indicates access to Serdes (block 0) AHB bus has returned an ack. This bit can cause interrupt if corresponding mask bit in ahb_lp_int_msk_reg is set to 0.
	 */
	u64	ser_ahb_ack:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 This bit, when set to 1, indicates access to PIPE AHB bus has returned an ack. This bit can cause interrupt if corresponding mask bit in ahb_lp_int_msk_reg is set to 0.
	 */
	u64	pipe_ahb_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_lp_intr_vec_reg [64 bits] */

/* CSR automated type for PEU_CSR_LPRI_INT_MSK_REG */
struct psif_csr_peu_csr_lpri_int_msk_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:4] RO reset = 0
	 Always read as zero.
	 */
	u64	:60; /* 60 bits @ offs 0:0 */
	/* bit[3] RW reset = 1
	 This bit is the interrupt mask bit for the Serdes bit_lock_lost. When set to 1 the corresponding interrupt to EPS is masked.
	 */
	u64	ser_lp_int_mask:1; /* 1 bits @ offs 0:60 */
	/* bit[2:0] RW reset = 7
	 Each bit in this register is the interrupt mask bit for the corresponding bit in csr_lp_intr_vec_reg. When set to 1 the corresponding interrupt to EPS is masked.
	 */
	u64	ahb_lp_int_mask:3; /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_lpri_int_msk_reg [64 bits] */

/* CSR automated type for PEU_CSR_SER_INT_ST_REG */
struct psif_csr_peu_csr_ser_int_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:1] RO reset = 0
	 Always read as zero.
	 */
	u64	:63; /* 63 bits @ offs 0:0 */
	/* bit[0] W_1_C reset = 0
	 This bit, when set to 1, indicates at least one of the 16 PCIe serdes has lost lock. This bit can cause interrupt if corresponding mask bit in ahb_lp_int_msk_reg is set to 0.
	 */
	u64	bit_lock_lost:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_ser_int_st_reg [64 bits] */

/* CSR automated type for PEU_TSU_FLR_REQ_DBG_REG */
struct psif_csr_peu_tsu_flr_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 This field indicates the state of FLR request from XIU to TSU. Each bit corresponds to a UF: bit 0 - PF bit 1 - VF0 bit 2 - VF1 bit 31- VF31
	 */
	u64	xiu_tsu_flr_req:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_tsu_flr_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_TSU_FLR_DONE_DBG_REG */
struct psif_csr_peu_tsu_flr_done_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 This field indicates the state of FLR done from TSU to XIU. Each bit corresponds to a UF: bit 0 - PF bit 1 - VF0 bit 2 - VF1 bit 31- VF31
	 */
	u64	xiu_tsu_flr_done:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_tsu_flr_done_dbg_reg [64 bits] */

/* CSR automated type for PEU_EPS_FLR_REQ_DBG_REG */
struct psif_csr_peu_eps_flr_req_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 This field indicates the state of FLR request from XIU to EPS. Each bit corresponds to a UF: bit 0 - PF bit 1 - VF0 bit 2 - VF1 bit 31- VF31
	 */
	u64	xiu_eps_flr_req:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_eps_flr_req_dbg_reg [64 bits] */

/* CSR automated type for PEU_EPS_FLR_DONE_DBG_REG */
struct psif_csr_peu_eps_flr_done_dbg_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u64	:31; /* 31 bits @ offs 0:0 */
	/* bit[32:0] RO reset = 0
	 This field indicates the state of FLR done from EPS to XIU. Each bit corresponds to a UF: bit 0 - PF bit 1 - VF0 bit 2 - VF1 bit 31- VF31
	 */
	u64	xiu_eps_flr_done:33; /* 33 bits @ offs 0:31 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_eps_flr_done_dbg_reg [64 bits] */

/* CSR automated type for PEU_PIPE_CSR_WDAT_REG */
struct psif_csr_peu_pipe_csr_wdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RW reset = 0
	 Write data of the AHB interface to the PIPE core. This register should be written first, in-case of write command, before the pipe_csr_cmd_reg register is written
	 */
	u32	pipe_ahb_wdata; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_pipe_csr_wdat_reg [64 bits] */

/* CSR automated type for PEU_PIPE_CSR_CMD_REG */
struct psif_csr_peu_pipe_csr_cmd_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[32] RW reset = 0
	 Command being issued to the AHB interface of the PIPE core:
	 0 = Read 
	 1 = Write 
	 */
	u32	pipe_ahb_cmd:1; /* 1 bits @ offs 0:31 */
	/* bit[31:24] RO reset = 0
	 Always read as zero.
	 */
	u32	:8; /* 8 bits @ offs 0:32 */
	/* bit[23:0] RW reset = 0
	 PIPE core register address on the AHB interface. In case of write command, this register should be written after pipe_csr_wdat_reg register is written
	 */
	u32	pipe_ahb_addr:24; /* 24 bits @ offs 0:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_pipe_csr_cmd_reg [64 bits] */

/* CSR automated type for PEU_PIPE_CSR_STATUS_REG */
struct psif_csr_peu_pipe_csr_status_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:4] RO reset = 0
	 Always read as zero.
	 */
	u64	:60; /* 60 bits @ offs 0:0 */
	/* bit[3] RO reset = 0
	 PIPE AHB Busy indicator. This bit is set to 1 when a transaction on the PIPE AHB bus is in progress. No new command should be issued while this bit is set to 1, otherwise the command will be ignored
	 */
	u64	pipe_ahb_busy:1; /* 1 bits @ offs 0:60 */
	/* bit[2] W_1_C reset = 0
	 PIPE AHB Command Retry indicator. This bit is set to 1 when a transaction on the PIPE AHB bus receives a retry from the PIPE core. Software has to write 1 to clear this bit.
	 */
	u64	pipe_ahb_rtry:1; /* 1 bits @ offs 0:61 */
	/* bit[1] W_1_C reset = 0
	 PIPE AHB Command Error indicator. This bit is set to 1 when a transaction on the PIPE AHB bus is completed and an error occurred. Software has to write 1 to clear this bit.
	 */
	u64	pipe_ahb_err:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 PIPE AHB Command Completion indicator. This bit is set to 1 when a transaction on the PIPE AHB bus is completed. No new command should be issued to the PIPE core until this bit is set to 1. Software has to write 1 to clear this bit.
	 */
	u64	pipe_ahb_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_pipe_csr_status_reg [64 bits] */

/* CSR automated type for PEU_PIPE_CSR_RDAT_REG */
struct psif_csr_peu_pipe_csr_rdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RO reset = 0
	 Read data from the AHB interface to the PIPE core. The content of the register read from the PIPE core is saved in this register until another register within the PIPE core is read again. The new value is valid only when the PIPE_AHB_ACK bit is set to 1 and all other bits within the pipe_csr_status_reg register are set to 0.
	 */
	u32	pipe_ahb_rdata; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_pipe_csr_rdat_reg [64 bits] */

/* CSR automated type for PEU_SER_CSR_WDAT_REG */
struct psif_csr_peu_ser_csr_wdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 Write data of the AHB interface to the Serdes0 core. This register should be written first, in-case of write command, before the ser_csr_cmd_reg register is written
	 */
	u64	ser_ahb_wdata:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_csr_wdat_reg [64 bits] */

/* CSR automated type for PEU_SER_CSR_CMD_REG */
struct psif_csr_peu_ser_csr_cmd_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[32] RW reset = 0
	 Command being issued to the AHB interface of the Serdes0 core: 
	 0 = Read 
	 1 = Write 
	 */
	u32	ser_ahb_cmd:1; /* 1 bits @ offs 0:31 */
	/* bit[31:13] RO reset = 0
	 Always read as zero.
	 */
	u32	:19; /* 19 bits @ offs 0:32 */
	/* bit[12:0] RW reset = 0
	 Serdes0 core register address on the AHB interface. In case of write command, this register should be written after ser_csr_wdat_reg register is written
	 */
	u32	ser_ahb_addr:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_csr_cmd_reg [64 bits] */

/* CSR automated type for PEU_SER_CSR_STATUS_REG */
struct psif_csr_peu_ser_csr_status_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:4] RO reset = 0
	 Always read as zero.
	 */
	u64	:60; /* 60 bits @ offs 0:0 */
	/* bit[3] RO reset = 0
	 Serdes0 AHB Busy indicator. This bit is set to 1 when a transaction on the Serdes0 AHB bus is in progress. No new command should be issued while this bit is set to 1, otherwise the command will be ignored
	 */
	u64	ser_ahb_busy:1; /* 1 bits @ offs 0:60 */
	/* bit[2] W_1_C reset = 0
	 Serdes0 AHB Command Retry indicator. This bit is set to 1 when a transaction on the Serdes0 AHB bus receives a retry from the Serdes0 core. Software has to write 1 to clear this bit.
	 */
	u64	ser_ahb_rtry:1; /* 1 bits @ offs 0:61 */
	/* bit[1] W_1_C reset = 0
	 Serdes0 AHB Command Error indicator. This bit is set to 1 when a transaction on the Serdes0 AHB bus is completed and an error occurred. Software has to write 1 to clear this bit.
	 */
	u64	ser_ahb_err:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 Serdes0 AHB Command Completion indicator. This bit is set to 1 when a transaction on the Serdes0 AHB bus is completed. No new command should be issued to the Serdes0 core until this bit is set to 1. Software has to write 1 to clear this bit.
	 */
	u64	ser_ahb_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_csr_status_reg [64 bits] */

/* CSR automated type for PEU_SER_CSR_RDAT_REG */
struct psif_csr_peu_ser_csr_rdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0
	 Read data from the AHB interface to the Serdes0 core. The content of the register read from the Serdes0 core is saved in this register until another register within the Serdes0 core is read again. The new value is valid only when the SER_AHB_ACK bit is set to 1 and all other bits within the ser_csr_status_reg register are set to 0.
	 */
	u64	ser_ahb_rdata:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_csr_rdat_reg [64 bits] */

/* CSR automated type for PEU_SER_1_CSR_WDAT_REG */
struct psif_csr_peu_ser_1_csr_wdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RW reset = 0
	 Write data of the AHB interface to the Serdes1 core. This register should be written first, in-case of write command, before the ser_1_csr_cmd_reg register is written
	 */
	u64	ser_1_ahb_wdata:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_1_csr_wdat_reg [64 bits] */

/* CSR automated type for PEU_SER_1_CSR_CMD_REG */
struct psif_csr_peu_ser_1_csr_cmd_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:33] RO reset = 0
	 Always read as zero.
	 */
	u32	:31; /* 31 bits @ offs 0:0 */
	/* bit[32] RW reset = 0
	 Command being issued to the AHB interface of the Serdes1 core: 
	 0 = Read 
	 1 = Write 
	 */
	u32	ser_1_ahb_cmd:1; /* 1 bits @ offs 0:31 */
	/* bit[31:13] RO reset = 0
	 Always read as zero.
	 */
	u32	:19; /* 19 bits @ offs 0:32 */
	/* bit[12:0] RW reset = 0
	 Serdes1 core register address on the AHB interface. In case of write command, this register should be written after ser_1_csr_wdat_reg register is written
	 */
	u32	ser_1_ahb_addr:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_1_csr_cmd_reg [64 bits] */

/* CSR automated type for PEU_SER_1_CSR_STATUS_REG */
struct psif_csr_peu_ser_1_csr_status_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:4] RO reset = 0
	 Always read as zero.
	 */
	u64	:60; /* 60 bits @ offs 0:0 */
	/* bit[3] RO reset = 0
	 Serdes1 AHB Busy indicator. This bit is set to 1 when a transaction on the Serdes1 AHB bus is in progress. No new command should be issued while this bit is set to 1, otherwise the command will be ignored
	 */
	u64	ser_1_ahb_busy:1; /* 1 bits @ offs 0:60 */
	/* bit[2] W_1_C reset = 0
	 Serdes1 AHB Command Retry indicator. This bit is set to 1 when a transaction on the Serdes1 AHB bus receives a retry from the Serdes1 core. Software has to write 1 to clear this bit.
	 */
	u64	ser_1_ahb_rtry:1; /* 1 bits @ offs 0:61 */
	/* bit[1] W_1_C reset = 0
	 Serdes1 AHB Command Error indicator. This bit is set to 1 when a transaction on the Serdes1 AHB bus is completed and an error occurred. Software has to write 1 to clear this bit.
	 */
	u64	ser_1_ahb_err:1; /* 1 bits @ offs 0:62 */
	/* bit[0] W_1_C reset = 0
	 Serdes1 AHB Command Completion indicator. This bit is set to 1 when a transaction on the Serdes1 AHB bus is completed. No new command should be issued to the Serdes1 core until this bit is set to 1. Software has to write 1 to clear this bit.
	 */
	u64	ser_1_ahb_ack:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_1_csr_status_reg [64 bits] */

/* CSR automated type for PEU_SER_1_CSR_RDAT_REG */
struct psif_csr_peu_ser_1_csr_rdat_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:16] RO reset = 0
	 Always read as zero.
	 */
	u64	:48; /* 48 bits @ offs 0:0 */
	/* bit[15:0] RO reset = 0
	 Read data from the AHB interface to the Serdes1 core. The content of the register read from the Serdes1 core is saved in this register until another register within the Serdes1 core is read again. The new value is valid only when the SER_1_AHB_ACK bit is set to 1 and all other bits within the ser_1_csr_status_reg register are set to 0.
	 */
	u64	ser_1_ahb_rdata:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_1_csr_rdat_reg [64 bits] */

/* CSR automated type for PEU_SER_DFE_ST_SEL_REG */
struct psif_csr_peu_ser_dfe_st_sel_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 This field sets the Serdes block 1 (lanes 8 to 15) dfe_status mux select.
	 */
	u32	dfe_status_sel_ci_1; /* 32 bits @ offs 0:0 */
	/* bit[31:0] RO reset = 0
	 This field sets the Serdes block 0 (lanes 0 to 7) dfe_status mux select.
	 */
	u32	dfe_status_sel_ci; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_dfe_st_sel_reg [64 bits] */

/* CSR automated type for PEU_SER_DFE_ST_0_REG */
struct psif_csr_peu_ser_dfe_st_0_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:61] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:0 */
	/* bit[60:48] RO reset = 0
	 This field reflects the state of dfe_status_out3 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out3:13; /* 13 bits @ offs 0:3 */
	/* bit[47:45] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:16 */
	/* bit[44:32] RO reset = 0
	 This field reflects the state of dfe_status_out2 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out2:13; /* 13 bits @ offs 0:19 */
	/* bit[31:29] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:32 */
	/* bit[28:16] RO reset = 0
	 This field reflects the state of dfe_status_out1 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out1:13; /* 13 bits @ offs 0:35 */
	/* bit[15:13] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:48 */
	/* bit[12:0] RO reset = 0
	 This field reflects the state of dfe_status_out0 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out0:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_dfe_st_0_reg [64 bits] */

/* CSR automated type for PEU_SER_DFE_ST_1_REG */
struct psif_csr_peu_ser_dfe_st_1_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:61] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:0 */
	/* bit[60:48] RO reset = 0
	 This field reflects the state of dfe_status_out7 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out7:13; /* 13 bits @ offs 0:3 */
	/* bit[47:45] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:16 */
	/* bit[44:32] RO reset = 0
	 This field reflects the state of dfe_status_out6 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out6:13; /* 13 bits @ offs 0:19 */
	/* bit[31:29] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:32 */
	/* bit[28:16] RO reset = 0
	 This field reflects the state of dfe_status_out5 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out5:13; /* 13 bits @ offs 0:35 */
	/* bit[15:13] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:48 */
	/* bit[12:0] RO reset = 0
	 This field reflects the state of dfe_status_out4 for Serdes block 0 (lanes 0 to 7).
	 */
	u16	dfe_status_out4:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_dfe_st_1_reg [64 bits] */

/* CSR automated type for PEU_SER_DFE_ST_2_REG */
struct psif_csr_peu_ser_dfe_st_2_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:61] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:0 */
	/* bit[60:48] RO reset = 0
	 This field reflects the state of dfe_status_out3_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out3_1:13; /* 13 bits @ offs 0:3 */
	/* bit[47:45] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:16 */
	/* bit[44:32] RO reset = 0
	 This field reflects the state of dfe_status_out2_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out2_1:13; /* 13 bits @ offs 0:19 */
	/* bit[31:29] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:32 */
	/* bit[28:16] RO reset = 0
	 This field reflects the state of dfe_status_out1_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out1_1:13; /* 13 bits @ offs 0:35 */
	/* bit[15:13] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:48 */
	/* bit[12:0] RO reset = 0
	 This field reflects the state of dfe_status_out0_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out0_1:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_dfe_st_2_reg [64 bits] */

/* CSR automated type for PEU_SER_DFE_ST_3_REG */
struct psif_csr_peu_ser_dfe_st_3_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:61] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:0 */
	/* bit[60:48] RO reset = 0
	 This field reflects the state of dfe_status_out7_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out7_1:13; /* 13 bits @ offs 0:3 */
	/* bit[47:45] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:16 */
	/* bit[44:32] RO reset = 0
	 This field reflects the state of dfe_status_out6_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out6_1:13; /* 13 bits @ offs 0:19 */
	/* bit[31:29] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:32 */
	/* bit[28:16] RO reset = 0
	 This field reflects the state of dfe_status_out5_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out5_1:13; /* 13 bits @ offs 0:35 */
	/* bit[15:13] RO reset = 0
	 Always read as zero.
	 */
	u16	:3; /* 3 bits @ offs 0:48 */
	/* bit[12:0] RO reset = 0
	 This field reflects the state of dfe_status_out4_1 for Serdes block 1 (lanes 8 to 15).
	 */
	u16	dfe_status_out4_1:13; /* 13 bits @ offs 0:51 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_dfe_st_3_reg [64 bits] */

/* CSR automated type for PEU_SER_POWERDOWN_CTL_REG */
struct psif_csr_peu_ser_powerdown_ctl_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:32] RO reset = 0
	 Always read as zero.
	 */
	u32	:32; /* 32 bits @ offs 0:0 */
	/* bit[31:24] RW reset = 0
	 This field is a bit vector controlling the RX serdes (lane 8 to 15) power-down. When a bit is set to 1 the corresponding RX serdes is powered down. Bit 0 corresponds to lane 8 and bit 8 corresponds to lane 15.
	 */
	u16	rxpd_1:8; /* 8 bits @ offs 0:32 */
	/* bit[23:16] RW reset = 0
	 This field is a bit vector controlling the TX serdes (lane 8 to 15) power-down. When a bit is set to 1 the corresponding TX serdes is powered down. Bit 0 corresponds to lane 8 and bit 8 corresponds to lane 15.
	 */
	u16	txpd_1:8; /* 8 bits @ offs 0:40 */
	/* bit[15:8] RW reset = 0
	 This field is a bit vector controlling the RX serdes (lane 0 to 7) power-down. When a bit is set to 1 the corresponding RX serdes is powered down. Bit 0 corresponds to lane 0 and bit 7 corresponds to lane 7.
	 */
	u16	rxpd:8; /* 8 bits @ offs 0:48 */
	/* bit[7:0] RW reset = 0
	 This field is a bit vector controlling the TX serdes (lane 0 to 7) power-down. When a bit is set to 1 the corresponding TX serdes is powered down. Bit 0 corresponds to lane 0 and bit 7 corresponds to lane 7.
	 */
	u16	txpd:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_powerdown_ctl_reg [64 bits] */

/* CSR automated type for PEU_SER_CFG0_REG */
struct psif_csr_peu_ser_cfg0_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 8748268776163838994
	 This field is used to set the serdes configuration bus, bits 0 to 63. The value of this register should only be changed while LTSSM_ENABLE bit, in pcie_phy_ctl_reg, is 0. After changing the content of this register, HRESET should be asserted via csr_peu_ctl_st_reg register.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_cfg0_reg [64 bits] */

/* CSR automated type for PEU_SER_CFG1_REG */
struct psif_csr_peu_ser_cfg1_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 4629378277224509781
	 This field is used to set the serdes configuration bus, bits 64 to 127. The value of this register should only be changed while LTSSM_ENABLE bit, in pcie_phy_ctl_reg, is 0. After changing the content of this register, HRESET should be asserted via csr_peu_ctl_st_reg register.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_cfg1_reg [64 bits] */

/* CSR automated type for PEU_SER_CFG2_REG */
struct psif_csr_peu_ser_cfg2_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 5950435494423689218
	 This field is used to set the serdes configuration bus, bits 128 to 191. The value of this register should only be changed while LTSSM_ENABLE bit, in pcie_phy_ctl_reg, is 0. After changing the content of this register, HRESET should be asserted via csr_peu_ctl_st_reg register.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_cfg2_reg [64 bits] */

/* CSR automated type for PEU_SER_CFG3_REG */
struct psif_csr_peu_ser_cfg3_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:0] RW reset = 9042381481574528
	 This field is used to set the serdes configuration bus, bits 192 to 255. The value of this register should only be changed while LTSSM_ENABLE bit, in pcie_phy_ctl_reg, is 0. After changing the content of this register, HRESET should be asserted via csr_peu_ctl_st_reg register.
	 */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_ser_cfg3_reg [64 bits] */

/* CSR automated type for PEU_CSR_SER_CTL_REG */
struct psif_csr_peu_csr_ser_ctl_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63] RW reset = 0
	 This bit, when set to 1, disables the PCS coefficient pingpong mode. The recommended value for this bit is 0.
	 */
	u16	coeff_pigpong_dis:1; /* 1 bits @ offs 0:0 */
	/* bit[62] RO reset = 0
	 Always read as zero.
	 */
	u16	:1; /* 1 bits @ offs 0:1 */
	/* bit[61] RO reset = 0
	 This bit indicates the state of serdes output ser_plltable_1 for lanes 8 to 15.
	 */
	u16	ser_pllstable_1:1; /* 1 bits @ offs 0:2 */
	/* bit[60] RO reset = 0
	 This bit indicates the state of serdes output ser_plltable for lanes 0 to 7.
	 */
	u16	ser_pllstable:1; /* 1 bits @ offs 0:3 */
	/* bit[59] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch7_1 for lane 15.
	 */
	u16	ser_rxlosaf_ch7_1:1; /* 1 bits @ offs 0:4 */
	/* bit[58] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch6_1 for lane 14.
	 */
	u16	ser_rxlosaf_ch6_1:1; /* 1 bits @ offs 0:5 */
	/* bit[57] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch5_1 for lane 13.
	 */
	u16	ser_rxlosaf_ch5_1:1; /* 1 bits @ offs 0:6 */
	/* bit[56] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch4_1 for lane 12.
	 */
	u16	ser_rxlosaf_ch4_1:1; /* 1 bits @ offs 0:7 */
	/* bit[55] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch3_1 for lane 11.
	 */
	u16	ser_rxlosaf_ch3_1:1; /* 1 bits @ offs 0:8 */
	/* bit[54] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch2_1 for lane 10.
	 */
	u16	ser_rxlosaf_ch2_1:1; /* 1 bits @ offs 0:9 */
	/* bit[53] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch1_1 for lane 9.
	 */
	u16	ser_rxlosaf_ch1_1:1; /* 1 bits @ offs 0:10 */
	/* bit[52] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch0_1 for lane 8.
	 */
	u16	ser_rxlosaf_ch0_1:1; /* 1 bits @ offs 0:11 */
	/* bit[51] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch7 for lane 7.
	 */
	u16	ser_rxlosaf_ch7:1; /* 1 bits @ offs 0:12 */
	/* bit[50] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch6 for lane 6.
	 */
	u16	ser_rxlosaf_ch6:1; /* 1 bits @ offs 0:13 */
	/* bit[49] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch5 for lane 5.
	 */
	u16	ser_rxlosaf_ch5:1; /* 1 bits @ offs 0:14 */
	/* bit[48] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch4 for lane 4.
	 */
	u16	ser_rxlosaf_ch4:1; /* 1 bits @ offs 0:15 */
	/* bit[47] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch3 for lane 3.
	 */
	u16	ser_rxlosaf_ch3:1; /* 1 bits @ offs 0:16 */
	/* bit[46] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch2 for lane 2.
	 */
	u16	ser_rxlosaf_ch2:1; /* 1 bits @ offs 0:17 */
	/* bit[45] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch1 for lane 1.
	 */
	u16	ser_rxlosaf_ch1:1; /* 1 bits @ offs 0:18 */
	/* bit[44] RO reset = 0
	 This bit indicates the state of serdes output ser_rxlosaf_ch0 for lane 0.
	 */
	u16	ser_rxlosaf_ch0:1; /* 1 bits @ offs 0:19 */
	/* bit[43] RW reset = 0
	 This bit controls the serdes input ser_txcdrusrclksel_1 for lanes 8 to 15.
	 */
	u16	ser_txcdrusrclksel_1:1; /* 1 bits @ offs 0:20 */
	/* bit[42] RW reset = 0
	 This bit controls the serdes input ser_txcdrusrclksel for lanes 0 to 7.
	 */
	u16	ser_txcdrusrclksel:1; /* 1 bits @ offs 0:21 */
	/* bit[41] RW reset = 0
	 This bit controls the serdes input ser_txcdr2tclksel_1 for lanes 8 to 15.
	 */
	u16	ser_txcdr2tclksel_1:1; /* 1 bits @ offs 0:22 */
	/* bit[40] RW reset = 0
	 This bit controls the serdes input ser_txcdr2tclksel for lanes 0 to 7.
	 */
	u16	ser_txcdr2tclksel:1; /* 1 bits @ offs 0:23 */
	/* bit[39:32] RW reset = 0
	 These bits controls the serdes input bus ser_tx_inv for lanes 8 to 15; bit 0 corresponds to lane 8 and bit 7 to lane 15.
	 */
	u16	ser_tx_inv_1:8; /* 8 bits @ offs 0:24 */
	/* bit[31:24] RW reset = 0
	 These bits controls the serdes input bus ser_tx_inv for lanes 0 to 7; bit 0 corresponds to lane 0 and bit 7 to lane 7.
	 */
	u16	ser_tx_inv:8; /* 8 bits @ offs 0:32 */
	/* bit[23:22] RW reset = 2
	 These bits controls the serdes inputs ser_chnl_bifur_1 for lanes 8 to 15. These bits should never be altered from their power-on default value.
	 */
	u16	ser_chnl_bifur_1:2; /* 2 bits @ offs 0:40 */
	/* bit[21:20] RW reset = 2
	 These bits controls the serdes inputs ser_chnl_bifur for lanes 0 to 7. These bits should never be altered from their power-on default value.
	 */
	u16	ser_chnl_bifur:2; /* 2 bits @ offs 0:42 */
	/* bit[19:18] RW reset = 0
	 These bits controls the serdes inputs ser_regbus_sel for lanes 8 to 15.
	 */
	u16	ser_regbus_sel_1:2; /* 2 bits @ offs 0:44 */
	/* bit[17:16] RW reset = 0
	 These bits controls the serdes inputs ser_regbus_sel for lanes 0 to 7.
	 */
	u16	ser_regbus_sel:2; /* 2 bits @ offs 0:46 */
	/* bit[15:0] RW reset = 0
	 These bits controls the serdes input bus ser_lpbk_ena. Each bit corresponds to a PCIe lane; bit 0 corresponds to lane 0 and bit 15 to lane 15.
	 */
	u16	ser_lpbk_ena; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_ser_ctl_reg [64 bits] */

/* CSR automated type for PEU_CSR_SER_ST_REG */
struct psif_csr_peu_csr_ser_st_reg {
	/* *** 64 bit group 0 start *** */
	/* bit[63:36] RO reset = 0
	 Always read as zero.
	 */
	u32	:28; /* 28 bits @ offs 0:0 */
	/* bit[35:34] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r7_1 signal.
	 */
	u32	ser_c0_d2r7_1:2; /* 2 bits @ offs 0:28 */
	/* bit[33:32] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r6_1 signal.
	 */
	u32	ser_c0_d2r6_1:2; /* 2 bits @ offs 0:30 */
	/* bit[31:30] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r5_1 signal.
	 */
	u16	ser_c0_d2r5_1:2; /* 2 bits @ offs 0:32 */
	/* bit[29:28] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r4_1 signal.
	 */
	u16	ser_c0_d2r4_1:2; /* 2 bits @ offs 0:34 */
	/* bit[27:26] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r3_1 signal.
	 */
	u16	ser_c0_d2r3_1:2; /* 2 bits @ offs 0:36 */
	/* bit[25:24] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r2_1 signal.
	 */
	u16	ser_c0_d2r2_1:2; /* 2 bits @ offs 0:38 */
	/* bit[23:22] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r1_1 signal.
	 */
	u16	ser_c0_d2r1_1:2; /* 2 bits @ offs 0:40 */
	/* bit[21:20] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 8 to 15) ser_c0_d2r0_1 signal.
	 */
	u16	ser_c0_d2r0_1:2; /* 2 bits @ offs 0:42 */
	/* bit[19:18] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r7 signal.
	 */
	u16	ser_c0_d2r7:2; /* 2 bits @ offs 0:44 */
	/* bit[17:16] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r6 signal.
	 */
	u16	ser_c0_d2r6:2; /* 2 bits @ offs 0:46 */
	/* bit[15:14] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r5 signal.
	 */
	u16	ser_c0_d2r5:2; /* 2 bits @ offs 0:48 */
	/* bit[13:12] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r4 signal.
	 */
	u16	ser_c0_d2r4:2; /* 2 bits @ offs 0:50 */
	/* bit[11:10] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r3 signal.
	 */
	u16	ser_c0_d2r3:2; /* 2 bits @ offs 0:52 */
	/* bit[9:8] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r2 signal.
	 */
	u16	ser_c0_d2r2:2; /* 2 bits @ offs 0:54 */
	/* bit[7:6] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r1 signal.
	 */
	u16	ser_c0_d2r1:2; /* 2 bits @ offs 0:56 */
	/* bit[5:4] RO reset = 0
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_c0_d2r0 signal.
	 */
	u16	ser_c0_d2r0:2; /* 2 bits @ offs 0:58 */
	/* bit[3] RO reset = 1
	 This bit indicates the state serdes block 1 (lanes 8 to 15) ser_txphyready signal.
	 */
	u16	ser_txphyready_1:1; /* 1 bits @ offs 0:60 */
	/* bit[2] RO reset = 1
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_txphyready signal.
	 */
	u16	ser_txphyready:1; /* 1 bits @ offs 0:61 */
	/* bit[1] RO reset = 1
	 This bit indicates the state serdes block 1 (lanes 8 to 15) ser_rxphyready signal.
	 */
	u16	ser_rxphyready_1:1; /* 1 bits @ offs 0:62 */
	/* bit[0] RO reset = 1
	 This bit indicates the state serdes block 0 (lanes 0 to 7) ser_rxphyready signal.
	 */
	u16	ser_rxphyready:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_peu_csr_ser_st_reg [64 bits] */

/* This is the portion of the descriptor which is updated by hardware. */
struct psif_rq_no_pad {
	/* *** 64 bit group 0 start *** */
	/*
	 * If set to something greater than zero, event notification is armed. An
	 * Affiliated Synchronous Event will be sent when number of WQE are less than
	 * srq_lim.
	 */
	u32	srq_lim:14; /* 14 bits @ offs 0:0 */
	/*
	 * Hardware modified index pointing to the head of the receive queue. TSU is
	 * using this to find the address of the receive queue entry.
	 */
	u32	head_indx:14; /* 14 bits @ offs 0:14 */
	/* This is the shift value to use to find start of the receive queue element. */
	u32	extent_log2:4; /* 4 bits @ offs 0:28 */
	/* pd(24[0] bits)Protection domain. */
	u32	pd:24; /* 24 bits @ offs 0:32 */
	/* This is indicating how many scatter entries are valid. */
	u32	scatter:4; /* 4 bits @ offs 0:56 */
	/* Reserved */
	u32	:1; /* 1 bits @ offs 0:60 */
	/* The shared receive queue is in error. */
	u32	srq_err:1; /* 1 bits @ offs 0:61 */
	/* This is a shared receive queue. For XRC SRQ this bit is ignored. */
	u32	srq:1; /* 1 bits @ offs 0:62 */
	/*
	 * Do not evict this entry if this bit is set. There can only be a fixed
	 * number of descriptors with this bit set. XXX: Should this be used as a
	 * hint, or should it be fixed?
	 */
	u32	sticky:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	/* Base address for the receive queue in host memory. */
	u64	base_addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Warn: Padding added in alignment check */
	u64	:55; /* 55 bits @ offs 3:0 */
	/* The desciptor is valid. */
	u64	valid:1; /* 1 bits @ offs 3:55 */
	/*
	 * Pre-fetch threshold (clog2) indicating when to read the software portion
	 * of the descriptor. If there are less entries than indicated by this
	 * threshold, the software portion of the descriptor must be read.
	 */
	u64	prefetch_threshold_log2:4; /* 4 bits @ offs 3:56 */
	/*
	 * Log2 size of the receive queue. Maximum number of entries in the receive
	 * queue. This is used for calculating when to wrap the head and tail
	 * indexes.
	 */
	u64	size_log2:4; /* 4 bits @ offs 3:60 */
} PSIF_PACKED_ALIGNED; /* struct psif_rq_no_pad [256 bits] */

/* Descriptor for hardware updated portion of XRC receive queue. */
struct psif_xrq_hw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * If set to something greater than zero, event notification is armed. An
	 * Affiliated Synchronous Event will be sent when number of WQE are less than
	 * srq_lim.
	 */
	u32	srq_lim:14; /* 14 bits @ offs 0:0 */
	/*
	 * Hardware modified index pointing to the head of the receive queue. TSU is
	 * using this to find the address of the receive queue entry.
	 */
	u32	head_indx:14; /* 14 bits @ offs 0:14 */
	/* This is the shift value to use to find start of the receive queue element. */
	u32	extent_log2:4; /* 4 bits @ offs 0:28 */
	/* pd(24[0] bits)Protection domain. */
	u32	pd:24; /* 24 bits @ offs 0:32 */
	/* This is indicating how many scatter entries are valid. */
	u32	scatter:4; /* 4 bits @ offs 0:56 */
	/* Reserved */
	u32	:1; /* 1 bits @ offs 0:60 */
	/* The shared receive queue is in error. */
	u32	srq_err:1; /* 1 bits @ offs 0:61 */
	/* This is a shared receive queue. For XRC SRQ this bit is ignored. */
	u32	srq:1; /* 1 bits @ offs 0:62 */
	/*
	 * Do not evict this entry if this bit is set. There can only be a fixed
	 * number of descriptors with this bit set. XXX: Should this be used as a
	 * hint, or should it be fixed?
	 */
	u32	sticky:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	/* Inlined rq : struct psif_rq_no_pad (256 bits) */ /* 256 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/* Base address for the receive queue in host memory. */
	u64	base_addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Completion queue to use for the incoming packet. */
	u64	cqd_id:24; /* 24 bits @ offs 3:0 */
	/*
	 * XRC domain used to check if this descriptor can be used for the incoming
	 * packet.
	 */
	u64	xrc_domain:24; /* 24 bits @ offs 3:24 */
	/* Reserved */
	u64	:7; /* 7 bits @ offs 3:48 */
	/* The desciptor is valid. */
	u64	valid:1; /* 1 bits @ offs 3:55 */
	/*
	 * Pre-fetch threshold (clog2) indicating when to read the software portion
	 * of the descriptor. If there are less entries than indicated by this
	 * threshold, the software portion of the descriptor must be read.
	 */
	u64	prefetch_threshold_log2:4; /* 4 bits @ offs 3:56 */
	/*
	 * Log2 size of the receive queue. Maximum number of entries in the receive
	 * queue. This is used for calculating when to wrap the head and tail
	 * indexes.
	 */
	u64	size_log2:4; /* 4 bits @ offs 3:60 */
} PSIF_PACKED_ALIGNED; /* struct psif_xrq_hw [256 bits] */

/* Temp.definition of Shared receive queue content */
struct psif_xrq { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Content pt. not defined in ASIC XML */
	u64	something_tbd; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_xrq [64 bits] */

/*
 * Generic header for work requests to PSIF. This is present for all packet
 * types.
 */
struct psif_wr_common {
	/* *** 64 bit group 0 start *** */
	/*
	 * Send queue sequence number. Used to map request to a particular work
	 * request in the send queue.
	 */
	u16	sq_seq; /* 16 bits @ offs 0:0 */
	/* Length (number of bytes of valid data in the collect payload buffer). */
	u16	collect_length:9; /* 9 bits @ offs 0:16 */
	/*
	 * High Bandwidth/Low Latency BAR. The QoSL must be matched against the QoSL
	 * in the QP State. If it is unequal, the QP should be in error.
	 */
	#if defined(__arm__) /* enum psif_tsu_qos */
		u16	tsu_qosl:1;
	#else /* !__arm__ */
		enum psif_tsu_qos	tsu_qosl:1;
	#endif	 /* 1 bits @ offs 0:25 */
	/* Only applicable to UD. This is an indication that AHA should be used. */
	#if defined(__arm__) /* enum psif_use_ah */
		u16	ud_pkt:1;
	#else /* !__arm__ */
		enum psif_use_ah	ud_pkt:1;
	#endif	 /* 1 bits @ offs 0:26 */
	/* Port number to use for QP0/1 packets. This field is ignored if not QP0/1. */
	#if defined(__arm__) /* enum psif_port */
		u16	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 0:27 */
	/*
	 * The TSL (Tsu SL) must be matched against the TSL in the QP State (XXX: or
	 * in the AHA?). If it is unequal, the QP should be put in error.
	 */
	u16	tsu_sl:4; /* 4 bits @ offs 0:28 */
	/*
	 * QP sending this request. XXX: Should name be own_qp_num as defined in QP
	 * state?
	 */
	u32	local_qp:24; /* 24 bits @ offs 0:32 */
	/*
	 * XXX: Naming - do we want to use opcode for this also, or should we use
	 * pkt_type.
	 */
	#if defined(__arm__) /* enum psif_wr_type */
		u32	op:8;
	#else /* !__arm__ */
		enum psif_wr_type	op:8;
	#endif	 /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/*
	 * Completion queue descriptor index. This index points to the completion
	 * queue to be used with this work request.
	 */
	u32	cqd_id:24; /* 24 bits @ offs 1:0 */
	/* UF used for all EPS-C QP0/1 packets. This field is ignored otherwise. */
	u32	srcuf:6; /* 6 bits @ offs 1:24 */
	/* Fence indicator. */
	u32	fence:1; /* 1 bits @ offs 1:30 */
	/* Completion notification identifier. */
	u32	completion:1; /* 1 bits @ offs 1:31 */
	/*
	 * EPS tag - used by EPS to associate process and work request. This field is
	 * not used by non-EPS work requests.
	 */
	u16	eps_tag; /* 16 bits @ offs 1:32 */
	/*
	 * VLAN ID index. Index into the VLAN table. This is not used in this first
	 * version of PSIF.
	 */
	u16	vid_index:2; /* 2 bits @ offs 1:48 */
	/* UF used for DR loopback packets. This field is ignored otherwise. */
	u16	destuf:6; /* 6 bits @ offs 1:50 */
	/* Number of SGL entries are valid for this request. */
	u16	num_sgl:4; /* 4 bits @ offs 1:56 */
	/* L4 checksum enabled when set. This is used for EoIB and IPoIB packets. */
	u16	l4_checksum_en:1; /* 1 bits @ offs 1:60 */
	/* L3 checksum enabled when set. This is used for EoIB and IPoIB packets. */
	u16	l3_checksum_en:1; /* 1 bits @ offs 1:61 */
	/* VLAN bypass mode. This is not used in first version of PSIF. */
	u16	vlan_bypass:1; /* 1 bits @ offs 1:62 */
	/* Solicited event bit to be set in IB packet. */
	u16	se:1; /* 1 bits @ offs 1:63 */
	/* *** 64 bit group 2 start *** */
	/* Warn: Padding added in alignment check */
	u32	space1; /* 32 bits @ offs 2:0 */
	/*
	 * Checksum used for data protection and consistency between work request and
	 * QP state.
	 */
	u32	checksum; /* 32 bits @ offs 2:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_common [192 bits] */

struct psif_wr_qp {
	/* *** 64 bit group 0 start *** */
	/* Q-Key for the remote node. */
	u32	qkey; /* 32 bits @ offs 0:0 */
	/* QP number for the remote node. */
	u32	remote_qp:24; /* 24 bits @ offs 0:32 */
	/* Reserved */
	u32	:8; /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_qp [64 bits] */

/* Local address structure. */
struct psif_wr_local {
	/* *** 64 bit group 0 start *** */
	/* Host address. */
	u64	addr; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* This is the total length of the message. */
	u32	length; /* 32 bits @ offs 1:0 */
	/* Local key used to validate the memory region this address is pointing to. */
	u32	lkey; /* 32 bits @ offs 1:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_local [128 bits] */

struct psif_wr_addr {
	/* *** 64 bit group 0 start *** */
	/* Index into the Address Handle Array. */
	u32	ah_indx:24; /* 24 bits @ offs 0:0 */
	/* Reserved */
	u32	:8; /* 8 bits @ offs 0:24 */
} PSIF_PACKED; /* struct psif_wr_addr [32 bits] */

/*
 * This is a unioned UD Send header. It will be used by all UD send
 * operations, and can have either QP0 specific header or a header used for
 * all other QPs.
 */
struct psif_wr_ud_send {
	/* *** 64 bit group 0 start *** */
	struct psif_wr_qp	qp; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_wr_local	local_addr; /* 128 bits @ offs 1:0 */
	/* *** 64 bit group 3 start *** */
	struct psif_wr_addr	remote_addr; /* 32 bits @ offs 3:0 */
} PSIF_PACKED; /* struct psif_wr_ud_send [224 bits] */

/*
 * This header is used for IB send operations. The header is a union and
 * consists of either a connected mode header or a datagram mode header. The
 * following opcodes are using this header: PSIF_WR_SEND PSIF_WR_SEND_IMM
 * PSIF_WR_SPECIAL_QP_SEND PSIF_WR_QP0_SEND_DR_XMIT
 * PSIF_WR_QP0_SEND_DR_LOOPBACK PSIF_WR_EPS_SPECIAL_QP_SEND
 * PSIF_WR_EPS_QP0_SEND_DR_XMIT PSIF_WR_EPS_QP0_SEND_DR_LOOPBACK PSIF_WR_LSO
 */
struct psif_wr_send_header_ud {
	/* *** 64 bit group 0 start *** */
	struct psif_wr_qp	qp; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Header used for IB send commands using UD mode. */
	/* Inlined ud : struct psif_wr_ud_send (224 bits) */ /* 224 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_wr_local	local_addr; /* 128 bits @ offs 1:0 */
	/* *** 64 bit group 3 start *** */
	/*
	 * Max segment size used for PSIF_WR_LSO. This field is not used for other
	 * operations.
	 */
	u32	mss:12; /* 12 bits @ offs 3:0 */
	/* Reserved */
	u32	:20; /* 20 bits @ offs 3:12 */
	struct psif_wr_addr	remote_addr; /* 32 bits @ offs 3:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_send_header_ud [256 bits] */

/*
 * This is a connected mode IB Send header. This header is used for the
 * following opcodes: XXX
 */
struct psif_wr_cm {
	/* *** 64 bit group 0 start *** */
	struct psif_wr_local	local_addr; /* 128 bits @ offs 0:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * Reserved. XXX: FIX ME - calculation of this field based on constant, not
	 * psif_wr_local_address_header as it should.
	 */
	u32	reserved10[3]; /* 32 bits @ offs 2:0 */
} PSIF_PACKED; /* struct psif_wr_cm [224 bits] */

/*
 * This header is used for IB send operations. The header is a union and
 * consists of either a connected mode header or a datagram mode header. The
 * following opcodes are using this header: PSIF_WR_SEND PSIF_WR_SEND_IMM
 * PSIF_WR_SPECIAL_QP_SEND PSIF_WR_QP0_SEND_DR_XMIT
 * PSIF_WR_QP0_SEND_DR_LOOPBACK PSIF_WR_EPS_SPECIAL_QP_SEND
 * PSIF_WR_EPS_QP0_SEND_DR_XMIT PSIF_WR_EPS_QP0_SEND_DR_LOOPBACK PSIF_WR_LSO
 */
struct psif_wr_send_header_uc_rc_xrc {
	/* *** 64 bit group 0 start *** */
	struct psif_wr_local	local_addr; /* 128 bits @ offs 0:0 */
	/* *** 64 bit group 2 start *** */
	/* Header used with IB send commands using connected mode. */
	/* Inlined uc_rc_xrc : struct psif_wr_cm (224 bits) */ /* 224 bits @ offs 2:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * Reserved. XXX: FIX ME - calculation of this field based on constant, not
	 * psif_wr_local_address_header as it should.
	 */
	u32	reserved10[3]; /* 32 bits @ offs 2:0 */
	/*
	 * Max segment size used for PSIF_WR_LSO. This field is not used for other
	 * operations.
	 */
	u32	mss:12; /* 12 bits @ offs 3:32 */
	/* Reserved */
	u32	:20; /* 20 bits @ offs 3:44 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_send_header_uc_rc_xrc [256 bits] */

/*
 * This header is used for IB send operations. The header is a union and
 * consists of either a connected mode header or a datagram mode header. The
 * following opcodes are using this header: PSIF_WR_SEND PSIF_WR_SEND_IMM
 * PSIF_WR_SPECIAL_QP_SEND PSIF_WR_QP0_SEND_DR_XMIT
 * PSIF_WR_QP0_SEND_DR_LOOPBACK PSIF_WR_EPS_SPECIAL_QP_SEND
 * PSIF_WR_EPS_QP0_SEND_DR_XMIT PSIF_WR_EPS_QP0_SEND_DR_LOOPBACK PSIF_WR_LSO
 */
union psif_wr_send_header {
	/* Header used for IB send commands using UD mode. */
	struct psif_wr_send_header_ud	ud; /* 256 bits @ 0 offs 0 */
	/* Header used with IB send commands using connected mode. */
	struct psif_wr_send_header_uc_rc_xrc	uc_rc_xrc; /* 256 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_wr_send_header [256 bits] */

/* Remote address structure. */
struct psif_wr_remote {
	/* *** 64 bit group 0 start *** */
	/* Address to the remote side. */
	u64	addr; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* For RDMA and DM this is the length to add to dmalen in RETH of IB packet. */
	u32	length; /* 32 bits @ offs 1:0 */
	/*
	 * Remote key used to validate the memory region the associated address is
	 * pointing to.
	 */
	u32	rkey; /* 32 bits @ offs 1:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_remote [128 bits] */

/*
 * This header is used for RDMA type operations. The following opcodes are
 * using this header: PSIF_WR_RDMA_WR PSIF_WR_RDMA_WR_IMM PSIF_WR_RDMA_RD
 * PSIF_WR_CMP_SWAP PSIF_WR_FETCH_ADD PSIF_WR_MASK_CMP_SWAP
 * PSIF_WR_MASK_FETCH_ADD
 */
struct psif_wr_rdma {
	/* *** 64 bit group 0 start *** */
	struct psif_wr_local	local_addr; /* 128 bits @ offs 0:0 */
	/* *** 64 bit group 2 start *** */
	struct psif_wr_remote	remote_addr; /* 128 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_rdma [256 bits] */

struct psif_wr_dm_hdr {
	/* *** 64 bit group 0 start *** */
	/* Target ring buffer descriptor. */
	u32	rbd_id:24; /* 24 bits @ offs 0:0 */
	/* Reserved */
	u32	:8; /* 8 bits @ offs 0:24 */
} PSIF_PACKED; /* struct psif_wr_dm_hdr [32 bits] */

/*
 * Union of local_addr and remote_addr. For DM PUT: this is the local address
 * of where the write data resides. For DM GET: this is the remote address
 * used in the RDMA RD request going out.
 */
union psif_local_remote_addr_union {
	struct psif_wr_local	local_addr; /* 128 bits @ 0 offs 0 */
	struct psif_wr_remote	remote_addr; /* 128 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_local_remote_addr_union [128 bits] */

/*
 * This header is used for DM operations. The following opcodes are using
 * this header: PSIF_WR_DM_PUT and PSIF_WR_DM_GET.
 */
struct psif_wr_dm {
	/* *** 64 bit group 0 start *** */
	/* Reserved */
	u32	reserved_pad_112[3]; /* 32 bits @ offs 0:0 */
	struct psif_wr_dm_hdr	rb; /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	union psif_local_remote_addr_union	u; /* 128 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_dm [256 bits] */

/* Send completion ID. */
struct psif_send_completion_id {
	/* *** 64 bit group 0 start *** */
	/*
	 * This field is only valid for ring buffer send completions (proxy type send
	 * requests). In all other cases this field is ignored.
	 */
	u16	eps_tag; /* 16 bits @ offs 0:0 */
	/*
	 * Send queue sequence number. This is used to map the completion back to a
	 * request in the send queue.
	 */
	u16	sq_seq_num; /* 16 bits @ offs 0:16 */
	/*
	 * Completion queue sequence number for the completion queue being re-armed.
	 * This is going into the completion for the privileged request.
	 */
	u32	sequence_number; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_send_completion_id [64 bits] */

/* Event completion ID. */
struct psif_event_completion_id {
	/* *** 64 bit group 0 start *** */
	/* Completion queue descriptor ID which is the source of the event. */
	u64	cq_id:24; /* 24 bits @ offs 0:0 */
	/* Reserved */
	u64	:40; /* 40 bits @ offs 0:24 */
} PSIF_PACKED_ALIGNED; /* struct psif_event_completion_id [64 bits] */

/* Union containing a send or receive completion ID. */
union psif_completion_wc_id {
	/*
	 * Receive Queue completion ID. This is the receive queue entry ID found as
	 * part of receive queue entry.
	 */
	u64	rq_id; /* 64 bits @ 0 offs 0 */
	/*
	 * Send Queue completion ID. This contain the send queue sequence number. In
	 * ring buffer send completions this field also conatain a valid EPS tag.
	 */
	struct psif_send_completion_id	sq_id; /* 64 bits @ 0 offs 0 */
	/* Completion queue descriptor ID which is the source of the event. */
	struct psif_event_completion_id	ecq_id; /* 64 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_completion_wc_id [64 bits] */

/*
 * Union used for descriptor types. It can the take the follwing types: rq_id
 * xrq_id eq_id rb_id target_qp
 */
union psif_descriptor_union {
	/*
	 * Receive queue descriptor used for the following request:
	 * PSIF_WR_SET_SRQ_LIM: this is the receive queue to set the new limit for.
	 * PSIF_WR_INVALIDATE_RQ: this is the receive queue to invalidate/flush from
	 * the descriptor cache.
	 */
	u32	rq_id:24; /* 24 bits @ 0 offs 0 */
	/*
	 * XRCSRQ descriptor used for the following request: PSIF_WR_SET_XRCSRQ_LIM:
	 * this is the XRCSRQ to set the new limit for. PSIF_WR_INVALIDATE_XRCSRQ:
	 * this is the XRCSRQ to invalidate/flush from the descriptor cache.
	 */
	u32	xrq_id:24; /* 24 bits @ 0 offs 0 */
	/*
	 * Ring buffer descriptor ID used when invalidating/flushing a RB descriptor
	 * from the descriptor cache. This field is valid for PSIF_WR_INVALIDATE_RB.
	 */
	u32	rb_id:24; /* 24 bits @ 0 offs 0 */
	/*
	 * Completion queue descriptor ID used when invalidating/flushing a CQ
	 * descriptor from the descriptor cache. This field is valid for
	 * PSIF_WR_INVALIDATE_CQ.
	 */
	u32	cq_id:24; /* 24 bits @ 0 offs 0 */
	/* Target QP for PSIF_WR_INVALIDATE_SGL_CACHE command. */
	u32	target_qp:24; /* 24 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_descriptor_union [24 bits] */

/*
 * This header is used for privileged operations. The following opcodes are
 * using this header: PSIF_WR_INVALIDATE_LKEY PSIF_WR_INVALIDATE_RKEY
 * PSIF_WR_INVALIDATE_BOTH_KEYS PSIF_WR_INVALIDATE_TLB PSIF_WR_RESIZE_CQ
 * PSIF_WR_SET_SRQ_LIM PSIF_WR_SET_XRCSRQ_LIM PSIF_WR_REQ_CMPL_NOTIFY
 * PSIF_WR_CMPL_NOTIFY_RCVD PSIF_WR_REARM_CMPL_EVENT PSIF_WR_REQ_RB_NOTIFY
 * PSIF_WR_RB_NOTIFY_RCVD PSIF_WR_REARM_RB_EVENT PSIF_WR_GENERATE_COMPLETION
 * PSIF_WR_INVALIDATE_RQ PSIF_WR_INVALIDATE_CQ PSIF_WR_INVALIDATE_RB
 * PSIF_WR_INVALIDATE_XRCSRQ PSIF_WR_INVALIDATE_SGL_CACHE
 */
struct psif_wr_su {
	/* *** 64 bit group 0 start *** */
	/* PSIF_WR_GENERATE_COMPLETION: This is the WC ID to put in the completion. */
	union psif_completion_wc_id	wc_id; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/*
	 * PSIF_WR_INVALIDATE_TLB: this is the address vector to invalidate in the
	 * TLB. PSIF_WR_RESIZE_CQ: this is the new address of the CQ.
	 */
	u64	addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * PSIF_WR_INVALIDATE_TLB: this is the length for invalidate in the TLB. Only
	 * the lower 16 bits are valid for specifying length of TLB invalidation.
	 * PSIF_WR_RESIZE_CQ: this is the new length of the CQ.
	 */
	u32	length; /* 32 bits @ offs 2:0 */
	/*
	 * PSIF_WR_INVALIDATE_LKEY: key to invalidate/flush from the DMA VT cache.
	 * PSIF_WR_INVALIDATE_RKEY: key to invalidate/flush from the DMA VT cache.
	 * PSIF_WR_INVALIDATE_BOTH_KEYS: key to invalidate/flush from the DMA VT
	 * cache. PSIF_WR_INVALIDATE_TLB: this is the address vector to invalidate in
	 * the TLB.
	 */
	u32	key; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	union psif_descriptor_union	u2; /* 24 bits @ offs 3:0 */
	/*
	 * PSIF_WR_GENERATE_COMPLETION: This is the completion status to put in the
	 * completion.
	 */
	#if defined(__arm__) /* enum psif_wc_status */
		u64	completion_status:8;
	#else /* !__arm__ */
		enum psif_wc_status	completion_status:8;
	#endif	 /* 8 bits @ offs 3:24 */
	/* Reserved */
	u64	:18; /* 18 bits @ offs 3:32 */
	/* This is used by the PSIF_WR_SET_SRQ_LIM request. */
	u64	srq_lim:14; /* 14 bits @ offs 3:50 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr_su [256 bits] */

/* SEND RDMA DM ATOMIC or PRIVILEGED data - depending on opcode. */
union psif_wr_details {
	union psif_wr_send_header	send; /* 256 bits @ 0 offs 0 */
	struct psif_wr_rdma	rdma; /* 256 bits @ 0 offs 0 */
	struct psif_wr_dm	dm; /* 256 bits @ 0 offs 0 */
	struct psif_wr_rdma	atomic; /* 256 bits @ 0 offs 0 */
	struct psif_wr_su	su; /* 256 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_wr_details [256 bits] */

struct psif_wr_xrc {
	/* *** 64 bit group 0 start *** */
	/* Descriptor index for XRC SRQ. */
	u32	xrqd_id:24; /* 24 bits @ offs 0:0 */
	/* Reserved */
	u32	:8; /* 8 bits @ offs 0:24 */
} PSIF_PACKED; /* struct psif_wr_xrc [32 bits] */

/* PSIF work request. */
struct psif_wr { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * Send queue sequence number. Used to map request to a particular work
	 * request in the send queue.
	 */
	u16	sq_seq; /* 16 bits @ offs 0:0 */
	/* Length (number of bytes of valid data in the collect payload buffer). */
	u16	collect_length:9; /* 9 bits @ offs 0:16 */
	/*
	 * High Bandwidth/Low Latency BAR. The QoSL must be matched against the QoSL
	 * in the QP State. If it is unequal, the QP should be in error.
	 */
	#if defined(__arm__) /* enum psif_tsu_qos */
		u16	tsu_qosl:1;
	#else /* !__arm__ */
		enum psif_tsu_qos	tsu_qosl:1;
	#endif	 /* 1 bits @ offs 0:25 */
	/* Only applicable to UD. This is an indication that AHA should be used. */
	#if defined(__arm__) /* enum psif_use_ah */
		u16	ud_pkt:1;
	#else /* !__arm__ */
		enum psif_use_ah	ud_pkt:1;
	#endif	 /* 1 bits @ offs 0:26 */
	/* Port number to use for QP0/1 packets. This field is ignored if not QP0/1. */
	#if defined(__arm__) /* enum psif_port */
		u16	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 0:27 */
	/*
	 * The TSL (Tsu SL) must be matched against the TSL in the QP State (XXX: or
	 * in the AHA?). If it is unequal, the QP should be put in error.
	 */
	u16	tsu_sl:4; /* 4 bits @ offs 0:28 */
	/*
	 * QP sending this request. XXX: Should name be own_qp_num as defined in QP
	 * state?
	 */
	u32	local_qp:24; /* 24 bits @ offs 0:32 */
	/*
	 * XXX: Naming - do we want to use opcode for this also, or should we use
	 * pkt_type.
	 */
	#if defined(__arm__) /* enum psif_wr_type */
		u32	op:8;
	#else /* !__arm__ */
		enum psif_wr_type	op:8;
	#endif	 /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/* Inlined common : struct psif_wr_common (192 bits) */ /* 192 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/*
	 * Completion queue descriptor index. This index points to the completion
	 * queue to be used with this work request.
	 */
	u32	cqd_id:24; /* 24 bits @ offs 1:0 */
	/* UF used for all EPS-C QP0/1 packets. This field is ignored otherwise. */
	u32	srcuf:6; /* 6 bits @ offs 1:24 */
	/* Fence indicator. */
	u32	fence:1; /* 1 bits @ offs 1:30 */
	/* Completion notification identifier. */
	u32	completion:1; /* 1 bits @ offs 1:31 */
	/*
	 * EPS tag - used by EPS to associate process and work request. This field is
	 * not used by non-EPS work requests.
	 */
	u16	eps_tag; /* 16 bits @ offs 1:32 */
	/*
	 * VLAN ID index. Index into the VLAN table. This is not used in this first
	 * version of PSIF.
	 */
	u16	vid_index:2; /* 2 bits @ offs 1:48 */
	/* UF used for DR loopback packets. This field is ignored otherwise. */
	u16	destuf:6; /* 6 bits @ offs 1:50 */
	/* Number of SGL entries are valid for this request. */
	u16	num_sgl:4; /* 4 bits @ offs 1:56 */
	/* L4 checksum enabled when set. This is used for EoIB and IPoIB packets. */
	u16	l4_checksum_en:1; /* 1 bits @ offs 1:60 */
	/* L3 checksum enabled when set. This is used for EoIB and IPoIB packets. */
	u16	l3_checksum_en:1; /* 1 bits @ offs 1:61 */
	/* VLAN bypass mode. This is not used in first version of PSIF. */
	u16	vlan_bypass:1; /* 1 bits @ offs 1:62 */
	/* Solicited event bit to be set in IB packet. */
	u16	se:1; /* 1 bits @ offs 1:63 */
	/* *** 64 bit group 2 start *** */
	/* Immediate data is only valid when indicated by the opcode. */
	u32	imm; /* 32 bits @ offs 2:0 */
	/*
	 * Checksum used for data protection and consistency between work request and
	 * QP state.
	 */
	u32	checksum; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	union psif_wr_details	details; /* 256 bits @ offs 3:0 */
	/* *** 64 bit group 7 start *** */
	/* Manually added spacing to pad out wr */
	u32	space2; /* 32 bits @ offs 7:0 */
	struct psif_wr_xrc	xrc_hdr; /* 32 bits @ offs 7:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_wr [512 bits] */

/* This is the portion of the descriptor which is updated by software. */
struct psif_sq_sw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u32	space3; /* 32 bits @ offs 0:0 */
	/*
	 * Index to where elements are added to the send queue by SW. SW is
	 * responsibel for keeping track of how many entries there are in the send
	 * queue. I.e. SW needs to keep track of the head_index so it doesn't
	 * overwrite entries in the send queue which is not yet completed.
	 */
	u16	tail_indx; /* 16 bits @ offs 0:32 */
	/* Reserved */
	u16	:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_sq_sw [64 bits] */

/* Hardware structure indicating what is the next QP. */
struct psif_next {
	/* *** 64 bit group 0 start *** */
	/* QP number for the next QP to be processed. */
	u32	next_qp_num:24; /* 24 bits @ offs 0:0 */
	/* If all high the next pointer is null. */
	u32	next_null:8; /* 8 bits @ offs 0:24 */
} PSIF_PACKED; /* struct psif_next [32 bits] */

/* Descriptor used by the send queue scheduler to operate on the send queue. */
struct psif_sq_hw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	u16	u_1; /* 16 bits @ offs 0:0 */
	/*
	 * Send queue sequence number used by the SQS to maintain ordering and keep
	 * track of where which send queue elements to fetch. This field is not in
	 * sync with the field in qp_t. This number is typically a little bit before
	 * the number in the qp_t as SQS has to fetch the elements from host memory.
	 * This is also used as tail_index when checking if there are more elements
	 * in the send queue.
	 */
	u16	last_seq; /* 16 bits @ offs 0:16 */
	/* QP and UF to be processed next. */
	struct psif_next	sq_next; /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/* Maximum inline data length supported by this send queue. */
	u32	sq_max_inline:9; /* 9 bits @ offs 1:0 */
	/* Maximum number of SGEs supported by this send queue. */
	u32	size_log2:4; /* 4 bits @ offs 1:9 */
	/* Maximum number of SGEs supported by this send queue. */
	u32	sq_max_sge:5; /* 5 bits @ offs 1:13 */
	/*
	 * The size between each work queue element in the send queue. This is the
	 * shift value to use in order to find the start of a work queue element.
	 */
	u32	extent_log2:5; /* 5 bits @ offs 1:18 */
	/*
	 * Indication if this QP is configured as a low latency or high throughput
	 * quality of service level.
	 */
	u32	qos:1; /* 1 bits @ offs 1:23 */
	/*
	 * Timestamp qualifier. This bit is set when retry is entered to the queue
	 * and clear when the timestamp has expired.
	 */
	u32	sq_timestamp_valid:1; /* 1 bits @ offs 1:24 */
	/*
	 * Done is set when the last SQ WR is processed (sq_sequence_number ==
	 * tail_indx). When done is set, SQS only process the SQ WR when
	 * sq_sequence_number != tail_index
	 */
	u32	sq_done:1; /* 1 bits @ offs 1:25 */
	/* Reserved */
	u32	:6; /* 6 bits @ offs 1:26 */
	u32	u_2; /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	/* The base address to the send queue. */
	u64	base_addr; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* The MMU context used to get the send queue. */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_sq_hw [256 bits] */

/* Temp.definition of Send queue content */
struct psif_sq_entry { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Content pt. not defined in ASIC XML */
	struct psif_wr	wr; /* 512 bits @ offs 0:0 */
	/* *** 64 bit group 8 start *** */
	u64	payload[32]; /* 64 bits @ offs 8:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_sq_entry [2560 bits] */

/* Temp.definition of the send queue entry cache for the completion block 
 * The only info used by the driver is the size of this struct,
 * when allocating space for the cache in memory:
 */
struct psif_sq_cmpl {
	/* *** 64 bit group 0 start *** */
	/* Content pt. not defined in ASIC XML */
	u64	payload[8]; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_sq_cmpl [512 bits] */

/* This is the part of the descriptor which is updated by SW (user space). */
struct psif_rq_sw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u32	space4; /* 32 bits @ offs 0:0 */
	/* Software modified index pointing to the tail reecive entry in host memory. */
	u32	tail_indx:14; /* 14 bits @ offs 0:32 */
	/* Reserved */
	u32	:18; /* 18 bits @ offs 0:46 */
} PSIF_PACKED_ALIGNED; /* struct psif_rq_sw [64 bits] */

struct psif_rq_hw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * If set to something greater than zero, event notification is armed. An
	 * Affiliated Synchronous Event will be sent when number of WQE are less than
	 * srq_lim.
	 */
	u32	srq_lim:14; /* 14 bits @ offs 0:0 */
	/*
	 * Hardware modified index pointing to the head of the receive queue. TSU is
	 * using this to find the address of the receive queue entry.
	 */
	u32	head_indx:14; /* 14 bits @ offs 0:14 */
	/* This is the shift value to use to find start of the receive queue element. */
	u32	extent_log2:4; /* 4 bits @ offs 0:28 */
	/* pd(24[0] bits)Protection domain. */
	u32	pd:24; /* 24 bits @ offs 0:32 */
	/* This is indicating how many scatter entries are valid. */
	u32	scatter:4; /* 4 bits @ offs 0:56 */
	/* Reserved */
	u32	:1; /* 1 bits @ offs 0:60 */
	/* The shared receive queue is in error. */
	u32	srq_err:1; /* 1 bits @ offs 0:61 */
	/* This is a shared receive queue. For XRC SRQ this bit is ignored. */
	u32	srq:1; /* 1 bits @ offs 0:62 */
	/*
	 * Do not evict this entry if this bit is set. There can only be a fixed
	 * number of descriptors with this bit set. XXX: Should this be used as a
	 * hint, or should it be fixed?
	 */
	u32	sticky:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	/* Hardware updated portion of descriptor. */
	/* Inlined hw_no_pad : struct psif_rq_no_pad (256 bits) */ /* 256 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/* Base address for the receive queue in host memory. */
	u64	base_addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Reserved */
	u64	:55; /* 55 bits @ offs 3:0 */
	/* The desciptor is valid. */
	u64	valid:1; /* 1 bits @ offs 3:55 */
	/*
	 * Pre-fetch threshold (clog2) indicating when to read the software portion
	 * of the descriptor. If there are less entries than indicated by this
	 * threshold, the software portion of the descriptor must be read.
	 */
	u64	prefetch_threshold_log2:4; /* 4 bits @ offs 3:56 */
	/*
	 * Log2 size of the receive queue. Maximum number of entries in the receive
	 * queue. This is used for calculating when to wrap the head and tail
	 * indexes.
	 */
	u64	size_log2:4; /* 4 bits @ offs 3:60 */
} PSIF_PACKED_ALIGNED; /* struct psif_rq_hw [256 bits] */

/* Recveive queue scatter entry. */
struct psif_rq_scatter {
	/* *** 64 bit group 0 start *** */
	/* Base address for this scatter element. */
	u64	base_addr; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* L-Key to be used for this scatter element. */
	u32	lkey; /* 32 bits @ offs 1:0 */
	/* Length of scatter element. */
	u32	length; /* 32 bits @ offs 1:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_rq_scatter [128 bits] */

/* A receive queue entry structure contianing scatter entries. */
struct psif_rq_entry { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * Receive queue entry ID. This is added to the receive completion using this
	 * receive queue entry.
	 */
	u64	rqe_id; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Scatter entries for this receive queue element. */
	struct psif_rq_scatter	scatter[16]; /* 128 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_rq_entry [2112 bits] */

/* This is the portion of the descriptor which is updated by software. */
struct psif_rb_sw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u32	space5; /* 32 bits @ offs 0:0 */
	/* Index to ring buffer elements added by SW. */
	u32	head_indx; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_rb_sw [64 bits] */

/*
 * Descriptor entry for a ring buffer. This entry is used to address into the
 * ring buffer and write the correct entries. This structure is the hardware
 * updateable part of the RB descriptor.
 */
struct psif_rb_hw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Index to ring buffer elements to be consumed by HW. */
	u32	tail_indx; /* 32 bits @ offs 0:0 */
	/*
	 * Log2 size of the ring buffer. The entries are specified as 64B entities.
	 * The number indicates when the tail_index should wrap. If one message is
	 * running over the edge, the message is stored in consecutive entries
	 * outside the ring buffer. max_message_size additional space is added to the
	 * edge of the buffer.
	 */
	u32	size_log2:5; /* 5 bits @ offs 0:32 */
	/*
	 * Interrupt channel associated with the event queue. In the PSIF design the
	 * event queues are one to one with interrupt channel.
	 */
	u32	int_channel:7; /* 7 bits @ offs 0:37 */
	/* Reserved */
	u32	:11; /* 11 bits @ offs 0:44 */
	/* rb_size_log2(5[0] bits)Log2 size of the ring buffer. */
	u32	max_size_log2:5; /* 5 bits @ offs 0:55 */
	/* The descriptor is valid. */
	u32	valid:1; /* 1 bits @ offs 0:60 */
	/*
	 * When this bit is set, the solicited bit is used in order to send events to
	 * event queues.
	 */
	u32	armed:1; /* 1 bits @ offs 0:61 */
	/*
	 * This functionality is not valid unless armed is set. If set and incoming
	 * message has SE bit set, an event should be generated to the event queue
	 * indicated by eventq_dscr_id. If not set, an event is sent reqardless of
	 * the value of the SE bit in the incoming message.
	 */
	u32	filter_se:1; /* 1 bits @ offs 0:62 */
	/* Do not evict this entry if this bit is set. */
	u32	sticky:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * VA or PA of the base of the completion queue. If PA the MMU context above
	 * will be a bypass context. Updated by software. The head and tail pointers
	 * can be calculated by the following calculations: Address = base_ptr +
	 * (head * 64B ) Head Pointer and Tail Pointer will use the same MMU context
	 * as the base, and all need to be VA from one address space, or all need to
	 * be PA. In typical use, to allow direct user access to the head and tail
	 * pointer VAs are used.
	 */
	u64	base_addr; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* XXX: should this be defined as rb_sequence_number_t? */
	u32	sequence_number; /* 32 bits @ offs 3:0 */
	/* pd(24[0] bits)Protection domain. */
	u32	pd:24; /* 24 bits @ offs 3:32 */
	/*
	 * Pre-fetch threshold (clog2) indicating when to read the software portion
	 * of the descriptor. If there are less entries than indicated by this
	 * threshold, the software portion of the descriptor must be read.
	 */
	u32	prefetch_threshold_log2:5; /* 5 bits @ offs 3:56 */
	/* Reserved */
	u32	:3; /* 3 bits @ offs 3:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_rb_hw [256 bits] */

/*
 * Ring buffer header. A ring buffer header is preceding payload data when
 * written to host memory. The full message with RB header and payload data
 * is padded out to become a multiple of 64 bytes. The last 4 bytes of every
 * 64B data written, will contain the ring buffer sequence number.
 */
struct psif_rb_entry { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Length of data associated with this ring buffer header. */
	u32	byte_len; /* 32 bits @ offs 0:0 */
	/* ib_bth_qp_number(24[0] bits)Queue Pair */
	u32	qp_num:24; /* 24 bits @ offs 0:32 */
	/* Applicable only if this is for EPS-A. */
	#if defined(__arm__) /* enum psif_eps_a_core */
		u32	eps_a_core:2;
	#else /* !__arm__ */
		enum psif_eps_a_core	eps_a_core:2;
	#endif	 /* 2 bits @ offs 0:56 */
	/*
	 * MTU used when writing in this packet. This is used to calculate padding
	 * for multi packet messages, since full 64B chunks are always padded if data
	 * is not aligned to the 64B. Since RB sequence numbers are added, there will
	 * always be padding at the end.
	 */
	#if defined(__arm__) /* enum psif_path_mtu */
		u32	mtu:3;
	#else /* !__arm__ */
		enum psif_path_mtu	mtu:3;
	#endif	 /* 3 bits @ offs 0:58 */
	/*
	 * Defining the packet type the headers valid for this ring buffer.
	 * PSIF_RB_TYPE_INVALID PSIF_RB_TYPE_DM_PUT PSIF_RB_TYPE_DM_GET_RESP
	 * PSIF_RB_TYPE_RCV_PROXY_COMPLETION
	 * PSIF_RB_TYPE_RCV_PROXY_COMPLETION_AND_DATA
	 * PSIF_RB_TYPE_SEND_PROXY_COMPLETION PSIF_RB_TYPE_SEND_COMPLETION
	 */
	#if defined(__arm__) /* enum psif_rb_type */
		u32	pkt_type:3;
	#else /* !__arm__ */
		enum psif_rb_type	pkt_type:3;
	#endif	 /* 3 bits @ offs 0:61 */
	/* *** 64 bit group 1 start *** */
	/* Payload bulk */
	u64	payload[6]; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 7 start *** */
	/* sequence number for sanity checking */
	u32	seq_num; /* 32 bits @ offs 7:0 */
	/* Payload last */
	u32	payload_tail; /* 32 bits @ offs 7:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_rb_entry [512 bits] */

/* QP Receive capabilities... */
struct psif_qp_rcv_cap {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:52; /* 52 bits @ offs 0:0 */
	/* This is an Ethernet over IB QP. */
	u64	eoib_enable:1; /* 1 bits @ offs 0:52 */
	/* This is an IB over IB QP. */
	u64	ipoib_enable:1; /* 1 bits @ offs 0:53 */
	/*
	 * Enable header/data split for offloading. Header and data should end up in
	 * separate scatter elements.
	 */
	u64	hdr_split_enable:1; /* 1 bits @ offs 0:54 */
	/*
	 * Dynamic MTU is enabled - i.e. incoming requests can have 256B payload
	 * instead of MTU size specified in QP state.
	 */
	u64	rcv_dynamic_mtu_enable:1; /* 1 bits @ offs 0:55 */
	/*
	 * This is a proxy QP. Packets less than a particular size are forwarded to
	 * EPS-A core indicated in QP state.
	 */
	u64	proxy_qp_enable:1; /* 1 bits @ offs 0:56 */
	/* Enable capability for RSS. */
	u64	rss_enable:1; /* 1 bits @ offs 0:57 */
	/* Reserved */
	u64	:1; /* 1 bits @ offs 0:58 */
	/*
	 * PSIF specific capability enable for receiving DM massages encoded in RDMA
	 * WR.
	 */
	u64	dm_put_enable:1; /* 1 bits @ offs 0:59 */
	/* PSIF specific capability enable for receiving Masked Atomic operations. */
	u64	masked_atomic_enable:1; /* 1 bits @ offs 0:60 */
	/* IB defined capability enable for receiving Atomic operations. */
	u64	atomic_enable:1; /* 1 bits @ offs 0:61 */
	/* IB defined capability enable for receiving RDMA WR. */
	u64	rdma_wr_enable:1; /* 1 bits @ offs 0:62 */
	/* IB defined capability enable for receiving RDMA RD. */
	u64	rdma_rd_enable:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_qp_rcv_cap [64 bits] */

/* QP Send capabilities... */
struct psif_qp_snd_cap {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:59; /* 59 bits @ offs 0:0 */
	/* PSIF specific exponential backoff enable. */
	u64	exp_backoff_enable:1; /* 1 bits @ offs 0:59 */
	/* PSIF specific capability enable for sending DM get messages. */
	u64	dm_get_enable:1; /* 1 bits @ offs 0:60 */
	/*
	 * Dynamic MTU is enabled - i.e. requests can use 256B payload instead of
	 * what is specified in QP state.
	 */
	u64	send_dynamic_mtu_enable:1; /* 1 bits @ offs 0:61 */
	/* This QP is running IP over IB. */
	u64	ipoib:1; /* 1 bits @ offs 0:62 */
	/* This QP is running Ethernet over IB. */
	u64	eoib:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_qp_snd_cap [64 bits] */

/*
 * QP state information as laid out in system memory. This structure should
 * be used to cast the state information stored to a register.
 */
struct psif_qp_core { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * This retry tag is the one used by tsu_rqs and added to the packets sent to
	 * tsu_dma. It is the responsibility of tsu_rqs to update this retry tag
	 * whenever the sq_sequence_number in QP state is equal to the one in the
	 * request.
	 */
	u32	retry_tag_committed:3; /* 3 bits @ offs 0:0 */
	/*
	 * This retry tag is updated by the error block when an error occur. If
	 * tsu_rqs reads this retry tag and it is different than the
	 * retry_tag_comitted, tsu_rqs must update retry_tag_comitted to the value of
	 * retry_tag_err when the sq_sequence_number indicates this is the valid
	 * request. The sq_sequence_number has been updated by tsu_err at the same
	 * time the retry_tag_err is updated.
	 */
	u32	retry_tag_err:3; /* 3 bits @ offs 0:3 */
	/*
	 * If the DMA is getting an L-Key violation or an error from PCIe when
	 * fetching data for requests, it has to set this bit. When set, all requests
	 * behind must be marked in error and not transmitted on IB. Responses are
	 * sent as normal.
	 */
	u32	req_access_error:1; /* 1 bits @ offs 0:6 */
	/*
	 * If the DMA is getting an R-Key violation or an error from PCIe when
	 * fetching data for RDMA read responses, it has to set this bit. When set,
	 * all packets sitting behind the RDMA read on this QP (requests and
	 * responses), must be marked bad so they are not transmitted on IB.
	 */
	u32	resp_access_error:1; /* 1 bits @ offs 0:7 */
	/*
	 * The XRC domain is used to check against the XRC domain in the XRCSRQ
	 * descriptor indexed by the request. If the XRC domain matches, the
	 * protection domain in the XRCSRQ descriptor is used instead of the
	 * protection domain associated with the QP.
	 */
	u32	xrc_domain:24; /* 24 bits @ offs 0:8 */
	/*
	 * Error retry counter initial value. Read by tsu_dma and used by tsu_cmpl to
	 * calculate exp_backoff etc..
	 */
	u32	error_retry_init:3; /* 3 bits @ offs 0:32 */
	/*
	 * Retry counter associated with retries to received NAK or implied NAK. If
	 * it expires, a path migration will be attempted if it is armed, or the QP
	 * will go to error state. Read by tsu_dma and used by tsu_cmpl.
	 */
	u32	error_retry_count:3; /* 3 bits @ offs 0:35 */
	/*
	 * When 1, indicates that the receive queue of this QP is a shared receive
	 * queue. This bit is used by tsu_err to classify errors.
	 */
	u32	rq_is_srq:1; /* 1 bits @ offs 0:38 */
	/* A hit in the set locally spun out of tsu_cmpl is found. */
	u32	spin_hit:1; /* 1 bits @ offs 0:39 */
	/* Send queue extent - the clog2 size between the work requests. */
	u32	sq_clog2_extent:5; /* 5 bits @ offs 0:40 */
	/* The size (log2 number of entries) of the send queue. */
	u32	sq_clog2_size:4; /* 4 bits @ offs 0:45 */
	/*
	 * Current number of outstanding read or atomic requests. Intialize to zero.
	 * It is updated by tsu_rqs every time a new read or atomic requests is
	 * transmitted.
	 */
	u32	current_outstanding:5; /* 5 bits @ offs 0:49 */
	/*
	 * Current number of retired read or atomic requests. Initialze to zero.
	 * Updated by tsu_cmpl every time a read or atomic request is completed.
	 */
	u32	current_retired:5; /* 5 bits @ offs 0:54 */
	/* Reserved */
	u32	:1; /* 1 bits @ offs 0:59 */
	/*
	 * Indication that a receive queue access is in progress. When receiving
	 * 'Error RQE' packets or Send Last packets already marked with error, the
	 * RQH must obtain the WR_ID (either from it's cache or from the scratchpad)
	 * and pass it on in the packet, if the 'in progress' bit is set.
	 */
	u32	rqh_rq_in_progress:1; /* 1 bits @ offs 0:60 */
	/*
	 * Indication that a receive queue access is in progress. The bit is set on a
	 * Send First packet and cleared on a Send Last packet. It is also cleared on
	 * a Error RQE packet (see below). If a Send Last packet or Flush RQE is
	 * received when the bit is already clear then that packet must not consume a
	 * CQE, otherwise it will consume a CQE. The idea here is that the 'Error
	 * RQE' packet replaces the last packet and forces a completion for the
	 * claimed RQE.
	 */
	u32	dscr_rq_in_progress:1; /* 1 bits @ offs 0:61 */
	/* A valid RQ entry is received for this particular outstanding error. */
	u32	rq_valid:1; /* 1 bits @ offs 0:62 */
	/* Indication that a completion is needed for this error type. */
	u32	need_completion:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	/*
	 * Minium RNR NAK timeout. This is added to RNR NAK packets and the requester
	 * receiving the RNR NAK must wait until the timer has expired before the
	 * retry is sent.
	 */
	u32	min_rnr_nak_time:5; /* 5 bits @ offs 1:0 */
	/* QP State for this QP. */
	#if defined(__arm__) /* enum psif_qp_state */
		u32	state:3;
	#else /* !__arm__ */
		enum psif_qp_state	state:3;
	#endif	 /* 3 bits @ offs 1:5 */
	/* QP number for the remote node. */
	u32	remote_qp:24; /* 24 bits @ offs 1:8 */
	/* R-Key of received multipacket message. */
	u32	rcv_rkey; /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	/*
	 * Number of bytes received for in progress RDMA RD Responses. This is
	 * maintained by tsu_cmpl.
	 */
	u32	rcv_bytes; /* 32 bits @ offs 2:0 */
	/* sq_seq(16[0] bits) * Send queue sequence number. This sequence number is used to make sure
 * order is maintained for requests sent from the process/host.
 */
	u16	retry_sq_seq; /* 16 bits @ offs 2:32 */
	/* sq_seq(16[0] bits) * Send queue sequence number. This sequence number is used to make sure
 * order is maintained for requests sent from the process/host.
 */
	u16	sq_seq; /* 16 bits @ offs 2:48 */
	/* *** 64 bit group 3 start *** */
	/*
	 * Magic number used to verify use of QP state. This is done by calculating a
	 * checksum of the work request incorporating the magic number. This checksum
	 * is checked against the checksum in the work request.
	 */
	u32	magic; /* 32 bits @ offs 3:0 */
	/*
	 * Completion queue sequence number. This sequence number is used when
	 * receiving DM messages. This is the starting sequence number for the next
	 * packet.
	 */
	u32	cq_seq; /* 32 bits @ offs 3:32 */
	/* *** 64 bit group 4 start *** */
	/*
	 * Q-Key received in incoming IB packet is checked towards this Q-Key. Q-Key
	 * used on transmit if top bit of Q-Key in WR is set.
	 */
	u32	qkey; /* 32 bits @ offs 4:0 */
	/* When 1 indicates that we have an IB retry outstanding. */
	u32	ib_retry_outstanding:1; /* 1 bits @ offs 4:32 */
	/* When 1 indicates that we have a fence retry outstanding. */
	u32	fence_retry_outstanding:1; /* 1 bits @ offs 4:33 */
	/*
	 * This is a way to optimize sending flush completions. When this bit is not
	 * set, tsu_err must make sure to stall tsu_cmpl before sending a send
	 * completion. This field must be cleared on a modify QP from SQErr to RTS.
	 */
	u32	send_stall_done:1; /* 1 bits @ offs 4:34 */
	/*
	 * This is set by CMPL when there are outstanding requests and a TX error is
	 * received from DMA. It is cleared when the error is sent to ERR.
	 */
	#if defined(__arm__) /* enum psif_cmpl_outstanding_error */
		u32	outstanding_error:4;
	#else /* !__arm__ */
		enum psif_cmpl_outstanding_error	outstanding_error:4;
	#endif	 /* 4 bits @ offs 4:35 */
	/* Reserved */
	u32	:1; /* 1 bits @ offs 4:39 */
	/*
	 * Sequence number of the last ACK received. Read and written by tsu_cmpl.
	 * Used to verify that the received response packet is a valid response.
	 */
	u32	last_acked_psn:24; /* 24 bits @ offs 4:40 */
	/* *** 64 bit group 5 start *** */
	/* Offset within scatter element of in progress SEND. */
	u32	scatter_offs; /* 32 bits @ offs 5:0 */
	/* Index to scatter element of in progress SEND. */
	u32	scatter_indx:5; /* 5 bits @ offs 5:32 */
	/*
	 * 2 bits (next_opcode) 0x0: No operation in progress 0x1: Expect SEND middle
	 * or last 0x2: Expect RDMA_WR middle or last
	 */
	#if defined(__arm__) /* enum psif_expected_op */
		u32	expected_opcode:2;
	#else /* !__arm__ */
		enum psif_expected_op	expected_opcode:2;
	#endif	 /* 2 bits @ offs 5:37 */
	/*
	 * When 1, indicates that a psn_nak has been sent. Need a valid request in
	 * order to clear the bit.
	 */
	u32	psn_nak:1; /* 1 bits @ offs 5:39 */
	/*
	 * Expected packet sequence number: Sequence number on next expected packet.
	 */
	u32	expected_psn:24; /* 24 bits @ offs 5:40 */
	/* *** 64 bit group 6 start *** */
	/*
	 * Timeout timestamp - if the timer is running and the timestamp indicates a
	 * timeout, a retry iss issued.
	 */
	u64	timeout_time:48; /* 48 bits @ offs 6:0 */
	/*
	 * When 1, indicates that a NAK has been for committed_psn+1. Need a valid
	 * request in order to clear the bit. This means receiving a good first/only
	 * packet for the committed_psn+1.
	 */
	u64	nak_sent:1; /* 1 bits @ offs 6:48 */
	/*
	 * TSU quality of service level. Can take values indicating low latency and
	 * high throughput. This is equivalent to high/low BAR when writing doorbells
	 * to PSIF. The qosl bit in the doorbell request must match this bit in the
	 * QP state, otherwise the QP must be put in error. This check only applies
	 * to tsu_rqs.
	 */
	#if defined(__arm__) /* enum psif_tsu_qos */
		u64	qosl:1;
	#else /* !__arm__ */
		enum psif_tsu_qos	qosl:1;
	#endif	 /* 1 bits @ offs 6:49 */
	/*
	 * Migration state (migrated, re-arm and armed). Since path migration is
	 * handled by tsu_qps, this is controlled by tsu_qps. XXX: Should error
	 * handler also be able to change the path?
	 */
	#if defined(__arm__) /* enum psif_migration */
		u64	mstate:2;
	#else /* !__arm__ */
		enum psif_migration	mstate:2;
	#endif	 /* 2 bits @ offs 6:50 */
	/* This is an Ethernet over IB QP. */
	u64	eoib_enable:1; /* 1 bits @ offs 6:52 */
	/* This is an IB over IB QP. */
	u64	ipoib_enable:1; /* 1 bits @ offs 6:53 */
	/*
	 * Enable header/data split for offloading. Header and data should end up in
	 * separate scatter elements.
	 */
	u64	hdr_split_enable:1; /* 1 bits @ offs 6:54 */
	/*
	 * Dynamic MTU is enabled - i.e. incoming requests can have 256B payload
	 * instead of MTU size specified in QP state.
	 */
	u64	rcv_dynamic_mtu_enable:1; /* 1 bits @ offs 6:55 */
	/*
	 * This is a proxy QP. Packets less than a particular size are forwarded to
	 * EPS-A core indicated in QP state.
	 */
	u64	proxy_qp_enable:1; /* 1 bits @ offs 6:56 */
	/* Enable capability for RSS. */
	u64	rss_enable:1; /* 1 bits @ offs 6:57 */
	/* Reserved */
	u64	:1; /* 1 bits @ offs 6:58 */
	/*
	 * PSIF specific capability enable for receiving DM massages encoded in RDMA
	 * WR.
	 */
	u64	dm_put_enable:1; /* 1 bits @ offs 6:59 */
	/* PSIF specific capability enable for receiving Masked Atomic operations. */
	u64	masked_atomic_enable:1; /* 1 bits @ offs 6:60 */
	/* IB defined capability enable for receiving Atomic operations. */
	u64	atomic_enable:1; /* 1 bits @ offs 6:61 */
	/* IB defined capability enable for receiving RDMA WR. */
	u64	rdma_wr_enable:1; /* 1 bits @ offs 6:62 */
	/* IB defined capability enable for receiving RDMA RD. */
	u64	rdma_rd_enable:1; /* 1 bits @ offs 6:63 */
	/* *** 64 bit group 7 start *** */
	/* Receive capabilities enabled for this QP. */
	/* Inlined rcv_cap : struct psif_qp_rcv_cap (64 bits) */ /* 64 bits @ offs 7:0 */
	/* *** 64 bit group 7 start *** */
	/*
	 * Transmit packet sequence number. Read and updated by tsu_dma before
	 * sending packets to tsu_ibpb and tsu_cmpl.
	 */
	u64	xmit_psn:24; /* 24 bits @ offs 7:0 */
	/*
	 * Retry transmit packet sequence number. This is the xmit_psn which should
	 * be used on the first packet of a retry. This is set by tsu_err. When
	 * tsu_dma see that a packet is the first of a retry, it must use this psn as
	 * the xmit_psn and write back xmit_psn as this psn+1.
	 */
	u64	retry_xmit_psn:24; /* 24 bits @ offs 7:24 */
	/*
	 * Index to scatter element of in progress RDMA RD response. This field does
	 * not need to be written to host memory.
	 */
	u64	resp_scatter_indx:5; /* 5 bits @ offs 7:48 */
	/*
	 * An error is found by tsu_cmpl. All packets on this QP is forwarded to
	 * tsu_err until this bit is cleared. The bit is cleared either from QP
	 * cleanup or when tsu_cmpl is receiving is_retry.
	 */
	u64	rc_in_error:1; /* 1 bits @ offs 7:53 */
	/* The timestamp is valid and will indicate when to time out the request.. */
	u64	timer_running:1; /* 1 bits @ offs 7:54 */
	/*
	 * TSU Service Level used to decide the TSU VL for requests associated with
	 * this QP.
	 */
	u64	tsl:4; /* 4 bits @ offs 7:55 */
	/*
	 * Maximum number of outstanding read or atomic requests allowed by the
	 * remote HCA. Initialized by software.
	 */
	u64	max_outstanding:5; /* 5 bits @ offs 7:59 */
	/* *** 64 bit group 8 start *** */
	/*
	 * DMA length found in first packet of inbound request. When last packet is
	 * received, it must be made sure the dmalen and received_bytes are equal.
	 */
	u32	dmalen; /* 32 bits @ offs 8:0 */
	/* Send Queue RNR retry count initialization value. */
	u32	rnr_retry_init:3; /* 3 bits @ offs 8:32 */
	/*
	 * Retry counter associated with RNR NAK retries. If it expires, a path
	 * migration will be attempted if it is armed, or the QP will go to error
	 * state.
	 */
	u32	rnr_retry_count:3; /* 3 bits @ offs 8:35 */
	/*
	 * When this bit is set, ordering from the send queue is ignored. The
	 * sq_sequence_number check in the RQS is ignored. When the bit is not set,
	 * sq_sequence_number check is done. This bit must be set for QP0 and QP1.
	 */
	u32	no_ordering:1; /* 1 bits @ offs 8:38 */
	/*
	 * When set, RQS should only check that the orig_checksum is equal to magic
	 * number. When not set, RQS should perform the checksum check towards the
	 * checksum in the psif_wr.
	 */
	u32	no_checksum:1; /* 1 bits @ offs 8:39 */
	/*
	 * This is an index to a receive queue descriptor. The descriptor points to
	 * the next receive queue element to be used. Receive queues are used for IB
	 * Send and RDMA Writes with Immediate data.
	 */
	u32	rq_indx:24; /* 24 bits @ offs 8:40 */
	/* *** 64 bit group 9 start *** */
	/*
	 * Transport type of the QP (RC, UC, UD, XRC, MANSP1). MANSP1 is set for
	 * privileged QPs.
	 */
	#if defined(__arm__) /* enum psif_qp_trans */
		u32	transport_type:3;
	#else /* !__arm__ */
		enum psif_qp_trans	transport_type:3;
	#endif	 /* 3 bits @ offs 9:0 */
	/* PSIF specific exponential backoff enable. */
	u32	exp_backoff_enable:1; /* 1 bits @ offs 9:3 */
	/* PSIF specific capability enable for sending DM get messages. */
	u32	dm_get_enable:1; /* 1 bits @ offs 9:4 */
	/*
	 * Dynamic MTU is enabled - i.e. requests can use 256B payload instead of
	 * what is specified in QP state.
	 */
	u32	send_dynamic_mtu_enable:1; /* 1 bits @ offs 9:5 */
	/* This QP is running IP over IB. */
	u32	ipoib:1; /* 1 bits @ offs 9:6 */
	/* This QP is running Ethernet over IB. */
	u32	eoib:1; /* 1 bits @ offs 9:7 */
	/* Send capabilities enabled for this QP. */
	/* Inlined send_cap : struct psif_qp_snd_cap (64 bits) */ /* 64 bits @ offs 9:8 */
	/*
	 * This is an index to completion queue descriptor. The descriptor points to
	 * a receive completion queue, which may or may not be the same as the send
	 * completion queue.
	 */
	u32	rcv_cq_indx:24; /* 24 bits @ offs 9:8 */
	/*
	 * Number of bytes received of in progress RDMA Write or SEND. The data
	 * received for SENDs and RDMA WR w/Imm are needed for completions. This
	 * should be added to the msg_length.
	 */
	u32	bytes_received; /* 32 bits @ offs 9:32 */
	/* *** 64 bit group 10 start *** */
	/* Response address. Used as the addresss for where to write DM Get responses. */
	u64	resp_addr; /* 64 bits @ offs 10:0 */
	/* *** 64 bit group 11 start *** */
	/*
	 * Request address. In the case of DM or RDMA WR, this is the current write
	 * pointer. In the case of a SEND, this is the address to the receive queue
	 * element.
	 */
	u64	req_addr; /* 64 bits @ offs 11:0 */
	/* *** 64 bit group 12 start *** */
	/*
	 * Used to store MMU context for in progress DM, where there is no DMA VT
	 * lookup. The MMU context then belongs to the req_addr. A QP can be set up
	 * to support either DM Get or DM Put, not both.
	 */
	struct psif_mmu_cntx	dm_mmu_context; /* 64 bits @ offs 12:0 */
	/* *** 64 bit group 13 start *** */
	/*
	 * Flag indicating if the swap in the last atomic swap operation was
	 * performed or not. If swapped, the next RDMA WR should be performed towards
	 * host memory. If not swapped, the next RDMA WR should not be performed
	 * towards host memory, but should be ACK'ed at the IB level as normal.
	 */
	#if defined(__arm__) /* enum psif_bool */
		u32	swapped:1;
	#else /* !__arm__ */
		enum psif_bool	swapped:1;
	#endif	 /* 1 bits @ offs 13:0 */
	/*
	 * Write pointer to atomic data stored in QP. Every time an atomic operation
	 * is performed, the original atomic data is stored in order be to returned
	 * in the event of duplicate atomic.
	 */
	u32	orig_atomic_wr_ptr:3; /* 3 bits @ offs 13:1 */
	#if defined(__arm__) /* enum psif_path_mtu */
		u32	path_mtu:3;
	#else /* !__arm__ */
		enum psif_path_mtu	path_mtu:3;
	#endif	 /* 3 bits @ offs 13:4 */
	/*
	 * Communication established bit. When a packet is received when in RTR
	 * state, this bit should be set, and an asynchronous event should be sent.
	 */
	#if defined(__arm__) /* enum psif_comm_live */
		u32	comm_established:1;
	#else /* !__arm__ */
		enum psif_comm_live	comm_established:1;
	#endif	 /* 1 bits @ offs 13:7 */
	/* This PSN is committed - ACKs sent will contain this PSN. */
	u32	committed_received_psn:24; /* 24 bits @ offs 13:8 */
	/*
	 * Offset within scatter element of in progress RDMA RD response. This field
	 * does not need to be written to host memory.
	 */
	u32	resp_scatter_offs; /* 32 bits @ offs 13:32 */
	/* *** 64 bit group 14 start *** */
	/*
	 * Message sequence number used in AETH when sending ACKs. The number is
	 * incremented every time a new inbound message is processed.
	 */
	u64	msn:24; /* 24 bits @ offs 14:0 */
	/*
	 * This is an index to send completion queue descriptor. The descriptor
	 * points to a send completion queue, which may or may not be the same as the
	 * send completion queue.
	 */
	u64	send_cq_indx:24; /* 24 bits @ offs 14:24 */
	/*
	 * Committed MSN - the MSN of the newest committed request for this QP. Only
	 * the bottom 16 bits of the MSN is used.
	 */
	u64	last_committed_msn:16; /* 16 bits @ offs 14:48 */
	/* *** 64 bit group 15 start *** */
	/* pd(24[0] bits)Protection domain. */
	u64	srq_pd:24; /* 24 bits @ offs 15:0 */
	/* pd(24[0] bits)Protection domain. */
	u64	pd:24; /* 24 bits @ offs 15:24 */
	/*
	 * MSN for the last incomming received ACK. Only the bottom 16 bits of the
	 * MSN is used.
	 */
	u64	last_received_msn:16; /* 16 bits @ offs 15:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_qp_core [1024 bits] */

/* GRH entry used for PSIF vHCA routing etc. */
struct psif_grh {
	/* *** 64 bit group 0 start *** */
	u64	remote_gid_0; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	remote_gid_1; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Warn: Padding added in alignment check */
	u64	:28; /* 28 bits @ offs 2:0 */
	/* ib_grh_hoplmt(8[0] bits)Hop Limit */
	u64	hoplmt:8; /* 8 bits @ offs 2:28 */
	/* ib_grh_tclass(8[0] bits)Traffic Class */
	u64	tclass:8; /* 8 bits @ offs 2:36 */
	/* ib_grh_flowl(20[0] bits)Flow Label */
	u64	flowlabel:20; /* 20 bits @ offs 2:44 */
} PSIF_PACKED_ALIGNED; /* struct psif_grh [192 bits] */

/*
 * Path specific information. This is information which can be different for
 * primary and alternate path.
 */
struct psif_qp_path { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	u64	remote_gid_0; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Inlined grh : struct psif_grh (192 bits) */ /* 192 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	u64	remote_gid_1; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* ib_lrh_lid(16[0] bits)Local ID */
	u16	remote_lid; /* 16 bits @ offs 2:0 */
	/* gid_indx(1[0] bits)GID index indicating which of the UFs two GIDs are used. */
	u64	gid_indx:1; /* 1 bits @ offs 2:16 */
	#if defined(__arm__) /* enum psif_port */
		u64	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 2:17 */
	#if defined(__arm__) /* enum psif_loopback */
		u64	loopback:1;
	#else /* !__arm__ */
		enum psif_loopback	loopback:1;
	#endif	 /* 1 bits @ offs 2:18 */
	#if defined(__arm__) /* enum psif_use_grh */
		u64	use_grh:1;
	#else /* !__arm__ */
		enum psif_use_grh	use_grh:1;
	#endif	 /* 1 bits @ offs 2:19 */
	/* ib_lrh_sl(4[0] bits)Service Level */
	u64	sl:4; /* 4 bits @ offs 2:20 */
	/* Reserved */
	u64	:4; /* 4 bits @ offs 2:24 */
	/* ib_grh_hoplmt(8[0] bits)Hop Limit */
	u64	hoplmt:8; /* 8 bits @ offs 2:28 */
	/* ib_grh_tclass(8[0] bits)Traffic Class */
	u64	tclass:8; /* 8 bits @ offs 2:36 */
	/* ib_grh_flowl(20[0] bits)Flow Label */
	u64	flowlabel:20; /* 20 bits @ offs 2:44 */
	/* *** 64 bit group 3 start *** */
	/* Reserved */
	u64	:27; /* 27 bits @ offs 3:0 */
	/* timeout(5[0] bits) * Local ACK timeout. This is the exponent used to calculate the delay before
 * an ACK is declared 'lost'
 */
	u64	local_ack_timeout:5; /* 5 bits @ offs 3:27 */
	/* ipd(8[0] bits)Inter packet delay. Encoded as specified in IB spec. */
	u64	ipd:8; /* 8 bits @ offs 3:32 */
	/* Reserved */
	u64	:8; /* 8 bits @ offs 3:40 */
	/*
	 * This is the LID path bits. This is used by tsu_ibpb when generating the
	 * SLID in the packet, and it is used by tsu_rcv when checking the DLID.
	 */
	u64	local_lid_path:7; /* 7 bits @ offs 3:48 */
	/* pkey_indx(9[0] bits)Index into the P-Key table. */
	u64	pkey_indx:9; /* 9 bits @ offs 3:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_qp_path [256 bits] */

/* Query QP structure. */
struct psif_query_qp {
	/* *** 64 bit group 0 start *** */
	/* QP state information from query. */
	struct psif_qp_core	qp; /* 1024 bits @ offs 0:0 */
	/* *** 64 bit group 16 start *** */
	/* Primary path information. */
	struct psif_qp_path	primary_path; /* 256 bits @ offs 16:0 */
	/* *** 64 bit group 20 start *** */
	/* Alternate path information. */
	struct psif_qp_path	alternate_path; /* 256 bits @ offs 20:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_query_qp [1536 bits] */

/* XXX: This is how the QP state in host memory is organized. */
struct psif_qp { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	struct psif_qp_core	state; /* 1024 bits @ offs 0:0 */
	/* *** 64 bit group 16 start *** */
	/*
	 * Path information for path A specific for this QP connection. This field
	 * only makes sense for QPs using connected mode. For datagram mode, this
	 * information comes from the AHA.
	 */
	struct psif_qp_path	path_a; /* 256 bits @ offs 16:0 */
	/* *** 64 bit group 20 start *** */
	/*
	 * Path information for path B specific for this QP connection. This field
	 * only makes sense for QPs using connected mode. For datagram mode, this
	 * information comes from the AHA.
	 */
	struct psif_qp_path	path_b; /* 256 bits @ offs 20:0 */
	/* *** 64 bit group 24 start *** */
	/*
	 * Information needed in order to handle retries on IB atomic requests as
	 * required.
	 */
	u64	atomic_retry_info[8]; /* 64 bits @ offs 24:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_qp [2048 bits] */

/* Temp.definition of collect buffers */
struct psif_cb { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Content pt. not defined in ASIC XML */
	struct psif_wr	wr; /* 512 bits @ offs 0:0 */
	/* *** 64 bit group 8 start *** */
	u64	payload[32]; /* 64 bits @ offs 8:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_cb [2560 bits] */

/* Temp.definition of PCIe WR BAR SQS WR layout = first 8 bytes of WR */
struct psif_pcie_sqs_wr {
	/* *** 64 bit group 0 start *** */
	/*
	 * Send queue sequence number. Used to map request to a particular work
	 * request in the send queue.
	 */
	u16	sq_seq; /* 16 bits @ offs 0:0 */
	/* Length (number of bytes of valid data in the collect payload buffer). */
	u16	collect_length:9; /* 9 bits @ offs 0:16 */
	/*
	 * High Bandwidth/Low Latency BAR. The QoSL must be matched against the QoSL
	 * in the QP State. If it is unequal, the QP should be in error.
	 */
	#if defined(__arm__) /* enum psif_tsu_qos */
		u16	tsu_qosl:1;
	#else /* !__arm__ */
		enum psif_tsu_qos	tsu_qosl:1;
	#endif	 /* 1 bits @ offs 0:25 */
	/* Only applicable to UD. This is an indication that AHA should be used. */
	#if defined(__arm__) /* enum psif_use_ah */
		u16	ud_pkt:1;
	#else /* !__arm__ */
		enum psif_use_ah	ud_pkt:1;
	#endif	 /* 1 bits @ offs 0:26 */
	/* Port number to use for QP0/1 packets. This field is ignored if not QP0/1. */
	#if defined(__arm__) /* enum psif_port */
		u16	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 0:27 */
	/*
	 * The TSL (Tsu SL) must be matched against the TSL in the QP State (XXX: or
	 * in the AHA?). If it is unequal, the QP should be put in error.
	 */
	u16	tsu_sl:4; /* 4 bits @ offs 0:28 */
	/*
	 * QP sending this request. XXX: Should name be own_qp_num as defined in QP
	 * state?
	 */
	u32	local_qp:24; /* 24 bits @ offs 0:32 */
	/*
	 * XXX: Naming - do we want to use opcode for this also, or should we use
	 * pkt_type.
	 */
	#if defined(__arm__) /* enum psif_wr_type */
		u32	op:8;
	#else /* !__arm__ */
		enum psif_wr_type	op:8;
	#endif	 /* 8 bits @ offs 0:56 */
} PSIF_PACKED_ALIGNED; /* struct psif_pcie_sqs_wr [64 bits] */

/* Temp.definition of PCIe WR BAR layout */
struct psif_pcie_wr {
	/* *** 64 bit group 0 start *** */
	struct psif_cb	cb; /* 2560 bits @ offs 0:0 */
	/* *** 64 bit group 40 start *** */
	u64	reserved_1[464]; /* 64 bits @ offs 40:0 */
	/* *** 64 bit group 504 start *** */
	struct psif_pcie_sqs_wr	sqs_wr; /* 64 bits @ offs 504:0 */
	/* *** 64 bit group 505 start *** */
	u64	reserved_2[6]; /* 64 bits @ offs 505:0 */
	/* *** 64 bit group 511 start *** */
	u64	clear; /* 64 bits @ offs 511:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_pcie_wr [32768 bits] */

struct psif_mbox {
	/* *** 64 bit group 0 start *** */
	/* Host posting to EPS-x */

	u64	in; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* EPS-x posting to Host */

	u64	out; /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_mbox [128 bits] */

struct psif_pcie_mbox {
	/* *** 64 bit group 0 start *** */
	/* MBOX_EPS_MAX mbox'es for all the EPS's */

	struct psif_mbox	eps[5]; /* 128 bits @ offs 0:0 */
	/* *** 64 bit group 10 start *** */
	/* (Reset all mailboxes) */

	u64	eps_reset; /* 64 bits @ offs 10:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_pcie_mbox [704 bits] */

/* Modify QP structure. */
struct psif_modify_qp {
	/* *** 64 bit group 0 start *** */
	/*
	 * Current number of retired read or atomic requests. Initialze to zero.
	 * Updated by tsu_cmpl every time a read or atomic request is completed.
	 */
	u16	max_outstanding:5; /* 5 bits @ offs 0:0 */
	/* QP State for this QP. */
	#if defined(__arm__) /* enum psif_qp_state */
		u16	state:3;
	#else /* !__arm__ */
		enum psif_qp_state	state:3;
	#endif	 /* 3 bits @ offs 0:5 */
	/*
	 * Minium RNR NAK timeout. This is added to RNR NAK packets and the requester
	 * receiving the RNR NAK must wait until the timer has expired before the
	 * retry is sent.
	 */
	u16	min_rnr_nak_time:5; /* 5 bits @ offs 0:8 */
	/*
	 * Error retry counter initial value. Read by tsu_dma and used by tsu_cmpl to
	 * calculate exp_backoff etc..
	 */
	u16	error_retry_count:3; /* 3 bits @ offs 0:13 */
	/* This is an Ethernet over IB QP. */
	u16	eoib_enable:1; /* 1 bits @ offs 0:16 */
	/* This is an IB over IB QP. */
	u16	ipoib_enable:1; /* 1 bits @ offs 0:17 */
	/*
	 * Enable header/data split for offloading. Header and data should end up in
	 * separate scatter elements.
	 */
	u16	hdr_split_enable:1; /* 1 bits @ offs 0:18 */
	/*
	 * Dynamic MTU is enabled - i.e. incoming requests can have 256B payload
	 * instead of MTU size specified in QP state.
	 */
	u16	rcv_dynamic_mtu_enable:1; /* 1 bits @ offs 0:19 */
	/*
	 * This is a proxy QP. Packets less than a particular size are forwarded to
	 * EPS-A core indicated in QP state.
	 */
	u16	proxy_qp_enable:1; /* 1 bits @ offs 0:20 */
	/* Enable capability for RSS. */
	u16	rss_enable:1; /* 1 bits @ offs 0:21 */
	/* Reserved */
	u16	:1; /* 1 bits @ offs 0:22 */
	/*
	 * PSIF specific capability enable for receiving DM massages encoded in RDMA
	 * WR.
	 */
	u16	dm_put_enable:1; /* 1 bits @ offs 0:23 */
	/* PSIF specific capability enable for receiving Masked Atomic operations. */
	u16	masked_atomic_enable:1; /* 1 bits @ offs 0:24 */
	/* IB defined capability enable for receiving Atomic operations. */
	u16	atomic_enable:1; /* 1 bits @ offs 0:25 */
	/* IB defined capability enable for receiving RDMA WR. */
	u16	rdma_wr_enable:1; /* 1 bits @ offs 0:26 */
	/* IB defined capability enable for receiving RDMA RD. */
	u16	rdma_rd_enable:1; /* 1 bits @ offs 0:27 */
	/* Receive capabilities enabled for this QP. */
	/* Inlined rcv_cap : struct psif_qp_rcv_cap (64 bits) */ /* 64 bits @ offs 0:28 */
	/*
	 * Retry counter associated with RNR NAK retries. If it expires, a path
	 * migration will be attempted if it is armed, or the QP will go to error
	 * state.
	 */
	u16	rnr_retry_count:3; /* 3 bits @ offs 0:28 */
	/*
	 * If the DMA is getting an L-Key violation or an error from PCIe when
	 * fetching data for requests, it has to set this bit. When set, all requests
	 * behind must be marked in error and not transmitted on IB. Responses are
	 * sent as normal.
	 */
	u16	req_access_error:1; /* 1 bits @ offs 0:31 */
	/* Q-Key received in incoming IB packet is checked towards this Q-Key. */
	u32	rx_qkey; /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/*
	 * Transmit packet sequence number. Read and updated by tsu_dma before
	 * sending packets to tsu_ibpb and tsu_cmpl.
	 */
	u32	xmit_psn:24; /* 24 bits @ offs 1:0 */
	/* Reserved */
	u32	:8; /* 8 bits @ offs 1:24 */
	/*
	 * Migration state (migrated, re-arm and armed). Since path migration is
	 * handled by tsu_qps, this is controlled by tsu_qps. XXX: Should error
	 * handler also be able to change the path?
	 */
	#if defined(__arm__) /* enum psif_migration */
		u32	mstate:2;
	#else /* !__arm__ */
		enum psif_migration	mstate:2;
	#endif	 /* 2 bits @ offs 1:32 */
	/* Reserved */
	u32	:3; /* 3 bits @ offs 1:34 */
	/* Path MTU. */
	#if defined(__arm__) /* enum psif_path_mtu */
		u32	path_mtu:3;
	#else /* !__arm__ */
		enum psif_path_mtu	path_mtu:3;
	#endif	 /* 3 bits @ offs 1:37 */
	/*
	 * Receive packet sequence number. Read and updated by tsu_dscr before
	 * passing packets to tsu_rqh.
	 */
	u32	expected_psn:24; /* 24 bits @ offs 1:40 */
	/* *** 64 bit group 2 start *** */
	/* Primary path information. */
	struct psif_qp_path	primary_path; /* 256 bits @ offs 2:0 */
	/* *** 64 bit group 6 start *** */
	/* Alternate path information. */
	struct psif_qp_path	alternate_path; /* 256 bits @ offs 6:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_modify_qp [640 bits] */

struct psif_dma_vt_mem_access {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:61; /* 61 bits @ offs 0:0 */
	/* Atomic access enabled. */
	u64	atomic:1; /* 1 bits @ offs 0:61 */
	/* Write access enabled. */
	u64	wr:1; /* 1 bits @ offs 0:62 */
	/* Read access enabled. */
	u64	rd:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_dma_vt_mem_access [64 bits] */

/*
 * Structure defining DMA Key Validation entries. This structure is specific
 * to IB and has information about R/L-Key states. One entry kan represent an
 * R-Key, an L-Key or both at the same time. This is is decided bythe key
 * states.
 */
struct psif_key {
	/* *** 64 bit group 0 start *** */
	/* Reserved */
	u32	:25; /* 25 bits @ offs 0:0 */
	/*
	 * If this bit is set, it means that this memory region is enabled for
	 * conditional RDMA write. The bit must be added to the header at tsu_val and
	 * follow the request towards tsu_host. When tsu_host receives this bit, it
	 * is checking the 'swapped' bit in the QP state in order to decide if the
	 * payload is written to host memory or not.
	 */
	u32	conditional_wr:1; /* 1 bits @ offs 0:25 */
	/* Atomic access enabled. */
	u32	local_access_atomic:1; /* 1 bits @ offs 0:26 */
	/* Write access enabled. */
	u32	local_access_wr:1; /* 1 bits @ offs 0:27 */
	/* Read access enabled. */
	u32	local_access_rd:1; /* 1 bits @ offs 0:28 */
	/*
	 * Local access rights. Used for L-Key accesses when this is a valid L-Key.
	 * Must be set correctly by SW so that RD access is always set.
	 */
	/* Inlined local_access : struct psif_dma_vt_mem_access (64 bits) */ /* 64 bits @ offs 0:29 */
	/* Atomic access enabled. */
	u32	remote_access_atomic:1; /* 1 bits @ offs 0:29 */
	/* Write access enabled. */
	u32	remote_access_wr:1; /* 1 bits @ offs 0:30 */
	/* Read access enabled. */
	u32	remote_access_rd:1; /* 1 bits @ offs 0:31 */
	/* Remote access rights. Used for R-Key accesses when this is a valid R-Key. */
	/* Inlined remote_access : struct psif_dma_vt_mem_access (64 bits) */ /* 64 bits @ offs 0:32 */
	/* pd(24[0] bits)Protection domain. */
	u32	pd:24; /* 24 bits @ offs 0:32 */
	/* Reserved */
	u32	:4; /* 4 bits @ offs 0:56 */
	/* L-key state for this DMA validation entry */
	#if defined(__arm__) /* enum psif_dma_vt_key_states */
		u32	lkey_state:2;
	#else /* !__arm__ */
		enum psif_dma_vt_key_states	lkey_state:2;
	#endif	 /* 2 bits @ offs 0:60 */
	/* R-key state for this DMA validation entry */
	#if defined(__arm__) /* enum psif_dma_vt_key_states */
		u32	rkey_state:2;
	#else /* !__arm__ */
		enum psif_dma_vt_key_states	rkey_state:2;
	#endif	 /* 2 bits @ offs 0:62 */
	/* *** 64 bit group 1 start *** */
	/* Length of memory region this validation entry is associated with. */
	u64	length; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	struct psif_mmu_cntx	mmu_context; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* host_address(64[0] bits)Host address used for accesses to/from TSU HOST. */
	u64	base_addr; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_key [256 bits] */

/* 
 * Flash image header format for application image
 * extention of struct psif_flash_header_all
 */
struct psif_flash_header_app {
	/* *** 64 bit group 0 start *** */
	/* byte[0:3] signature is 0xdeadbeef */
	u32	signature; /* 32 bits @ offs 0:0 */
	/* byte[4:7] image type */
	#if defined(__arm__) /* enum psif_flash_image_type */
		u32	type:32;
	#else /* !__arm__ */
		enum psif_flash_image_type	type:32;
	#endif	 /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/* byte[8:11] SHRDMEM start address */
	u32	exec_base; /* 32 bits @ offs 1:0 */
	/* byte[12:15] code/data size */
	u32	image_length; /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	/* byte[16:19] SHRDMEM ZI base address */
	u32	zi_base; /* 32 bits @ offs 2:0 */
	/* byte[20:23] ZI size */
	u32	zi_length; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	/* byte[24:27] Storage only used by boot loader */
	u32	flash_base; /* 32 bits @ offs 3:0 */
	/* byte[28:31] Execution start address */
	u32	start_addr; /* 32 bits @ offs 3:32 */
	/* *** 64 bit group 4 start *** */
	/* byte[32:35] SHRDMEM address base of low vectors */
	u32	low_vec_base; /* 32 bits @ offs 4:0 */
	/* byte[36:39] Flash address base of low vectors */
	u32	low_vec_flash_base; /* 32 bits @ offs 4:32 */
	/* *** 64 bit group 5 start *** */
	/* byte[40:43] Size of low vectors */
	u32	low_vec_length; /* 32 bits @ offs 5:0 */
	/* byte[44:47] FLASH_DATE_LEN > = sizeof(__DATE__) */
	u8	date[4]; /* 8 bits @ offs 5:32 */
	/* *** 64 bit group 6 start *** */
	/* byte[48:55] */
	u8	date_1[8]; /* 8 bits @ offs 6:0 */
	/* *** 64 bit group 7 start *** */
	/* byte[56:59] */
	u8	date_2[4]; /* 8 bits @ offs 7:0 */
	/* byte[60:63] FLASH_TIME_LEN > = sizeof(__TIME__) */
	u8	time[4]; /* 8 bits @ offs 7:32 */
	/* *** 64 bit group 8 start *** */
	/* byte[64:71] */
	u8	time_1[8]; /* 8 bits @ offs 8:0 */
	/* *** 64 bit group 9 start *** */
	/* byte[72:79] FLASH_REV_STR_LEN > = sizeof(REV_STRING) */
	u8	rev_string[8]; /* 8 bits @ offs 9:0 */
	/* *** 64 bit group 10 start *** */
	/* byte[80:83] checkssum_ptr - this value + 4 equals the size of the immage in bytes */
	u32	checksum_ptr; /* 32 bits @ offs 10:0 */
	/* byte[84:87] */
	u32	app_vec_flash_base; /* 32 bits @ offs 10:32 */
	/* *** 64 bit group 11 start *** */
	/* byte[88:91] */
	u32	app_vec_base; /* 32 bits @ offs 11:0 */
	/* byte[92:95] */
	u32	app_vec_length; /* 32 bits @ offs 11:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_flash_header_app [768 bits] */

/* 
 * Flash image header format 
 * Note: image length is not valid for the boot loader image itself (64k bytes) 
 * struct is always located at offset 0x800 within an image
 */
struct psif_flash_header_all {
	/* *** 64 bit group 0 start *** */
	/* byte[0:3] signature of 0xdeadbeef */
	u32	signature; /* 32 bits @ offs 0:0 */
	/* byte[4:7] image type */
	#if defined(__arm__) /* enum psif_flash_image_type */
		u32	type:32;
	#else /* !__arm__ */
		enum psif_flash_image_type	type:32;
	#endif	 /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/* byte[8:11] execution base */
	u32	base; /* 32 bits @ offs 1:0 */
	/* byte[12:15] image length.
	 The length is defined in bytes and starts at offset 0x0A00 into the image. */
	u32	length; /* 32 bits @ offs 1:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_flash_header_all [128 bits] */

/* This is the portion of the descriptor which is updated by software. */
struct psif_eq_sw {
	/* *** 64 bit group 0 start *** */
	/* Index to event elements consumed by SW. */
	u32	head_indx; /* 32 bits @ offs 0:0 */
} PSIF_PACKED; /* struct psif_eq_sw [32 bits] */

/*
 * Descriptor entry for an event queue. This entry is used to address into
 * the event queue and write the correct entries. This structure is the
 * hardware updateable part of the EQ descriptor.
 */
struct psif_eq_hw {
	/* *** 64 bit group 0 start *** */
	/*
	 * Event queue sequence number. This is the sequence number to be used for
	 * this event. When used by a client, it is incremented and written back to
	 * this descriptor.
	 */
	u32	sequence_number; /* 32 bits @ offs 0:0 */
	/*
	 * The size (log2 number of entries) of the event queue. This is used for
	 * calculating when to wrap the head and tail indexes.
	 */
	u32	size_log2:5; /* 5 bits @ offs 0:32 */
	/*
	 * The size between event queue entries. This is the shift value to find the
	 * start of the next entry.
	 */
	u32	extent_log2:5; /* 5 bits @ offs 0:37 */
	/* The descriptor is valid. */
	u32	valid:1; /* 1 bits @ offs 0:42 */
	/* Inlined ctrl : struct psif_eq_ctrl (64 bits) */ /* 64 bits @ offs 0:43 */
	/* Reserved */
	u32	:21; /* 21 bits @ offs 0:43 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * VA or PA of the base of the queue. If PA the MMU context above will be a
	 * bypass context. Updated by software. The head and tail pointers can be
	 * calculated by the following calculations: Address = base_ptr + (head *
	 * ($bits(event_entry_t)/8 ) Head Pointer and Tail Pointer will use the same
	 * MMU context as the base, and all need to be VA from one address space, or
	 * all need to be PA. In typical use, to allow direct user access to the head
	 * and tail pointer VAs are used.
	 */
	u64	base_addr; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Warn: Padding added in alignment check */
	u32	space6; /* 32 bits @ offs 3:0 */
	/* Index to event queue elements added by HW. */
	u32	tail_indx; /* 32 bits @ offs 3:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_eq_hw [256 bits] */

/* Event queue entry. */
struct psif_eq_entry {
	/* *** 64 bit group 0 start *** */
	/* Receive queue descriptor ID. */
	u64	rqd_id:24; /* 24 bits @ offs 0:0 */
	/* Completion queue descriptor ID. */
	u64	cqd_id:24; /* 24 bits @ offs 0:24 */
	#if defined(__arm__) /* enum psif_port_flags */
		u64	port_flags:4;
	#else /* !__arm__ */
		enum psif_port_flags	port_flags:4;
	#endif	 /* 4 bits @ offs 0:48 */
	/* Type of event this is. */
	#if defined(__arm__) /* enum psif_event_type */
		u64	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:52 */
	#if defined(__arm__) /* enum psif_event_status */
		u64	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/* QP number. */
	u64	qp:24; /* 24 bits @ offs 1:0 */
	/* Ring buffer descriptor ID. */
	u64	rbd_id:24; /* 24 bits @ offs 1:24 */
	/* IB port number */
	#if defined(__arm__) /* enum psif_port */
		u64	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 1:48 */
	/* Reserved */
	u64	:7; /* 7 bits @ offs 1:49 */
	#if defined(__arm__) /* enum psif_eps_core_id */
		u64	eps_core_id:4;
	#else /* !__arm__ */
		enum psif_eps_core_id	eps_core_id:4;
	#endif	 /* 4 bits @ offs 1:56 */
	/* vendor_fields(4[0] bits)Should this be an enum? */
	u64	vendor_fields:4; /* 4 bits @ offs 1:60 */
	/* *** 64 bit group 2 start *** */
	/* Padding out to 64 bit limit */
	u64	padding:32; /* 32 bits @ offs 2:0 */
	/* Completion queue sequence number causing the event to be sent. */
	u32	cq_sequence_number; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	/* Padding out struct bulk */
	u64	reserved[4]; /* 64 bits @ offs 3:0 */
	/* *** 64 bit group 7 start *** */
	/* sequence number for sanity checking */
	u32	seq_num; /* 32 bits @ offs 7:0 */
	/* Padding out struct last */
	u32	:32; /* 32 bits @ offs 7:32 */
} PSIF_PACKED_ALIGNED32; /* struct psif_eq_entry [512 bits] */

struct psif_epsc_log_stat {
	/* *** 64 bit group 0 start *** */
	/* Owned by epsc, runs all the way to 64 bit */

	u64	produce_offset; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Owned by host */

	u64	consume_offset; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Owned by host, real offset modulo sz */

	u64	size; /* 64 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_log_stat [192 bits] */

/* 
 * CSR Query port structure 
 */
struct psif_epsc_port_attr {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_epsc_port_state */
		u32	state:32;
	#else /* !__arm__ */
		enum psif_epsc_port_state	state:32;
	#endif	 /* 32 bits @ offs 0:0 */
	u32	portNumber; /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	#if defined(__arm__) /* enum psif_epsc_path_mtu */
		u32	active_mtu:32;
	#else /* !__arm__ */
		enum psif_epsc_path_mtu	active_mtu:32;
	#endif	 /* 32 bits @ offs 1:0 */
	#if defined(__arm__) /* enum psif_epsc_path_mtu */
		u32	max_mtu:32;
	#else /* !__arm__ */
		enum psif_epsc_path_mtu	max_mtu:32;
	#endif	 /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	u32	port_cap_flags; /* 32 bits @ offs 2:0 */
	u32	gid_tbl_len; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	u32	bad_pkey_cntr; /* 32 bits @ offs 3:0 */
	u32	max_msg_sz; /* 32 bits @ offs 3:32 */
	/* *** 64 bit group 4 start *** */
	u16	lid; /* 16 bits @ offs 4:0 */
	u16	pkey_tbl_len; /* 16 bits @ offs 4:16 */
	u32	qkey_viol_cntr; /* 32 bits @ offs 4:32 */
	/* *** 64 bit group 5 start *** */
	u16	active_width:8; /* 8 bits @ offs 5:0 */
	u16	init_type_reply:8; /* 8 bits @ offs 5:8 */
	u16	subnet_timeout:8; /* 8 bits @ offs 5:16 */
	u16	sm_sl:8; /* 8 bits @ offs 5:24 */
	u16	max_vl_num:8; /* 8 bits @ offs 5:32 */
	u16	lmc:8; /* 8 bits @ offs 5:40 */
	u16	sm_lid; /* 16 bits @ offs 5:48 */
	/* *** 64 bit group 6 start *** */
	/* Warn: Padding added in alignment check */
	u64	:48; /* 48 bits @ offs 6:0 */
	u64	phys_state:8; /* 8 bits @ offs 6:48 */
	u64	active_speed:8; /* 8 bits @ offs 6:56 */
} PSIF_PACKED_ALIGNED32; /* struct psif_epsc_port_attr [512 bits] */

/* 
 * Query GID response in host memory
 */
struct psif_epsc_gid_attr {
	/* *** 64 bit group 0 start *** */
	u64	gid_0; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	gid_1; /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_gid_attr [128 bits] */

/*
 * Populate MMU table
 */
struct psif_epsc_exercise_mmu {
	/* *** 64 bit group 0 start *** */
	/* Start adress */
	u64	host_addr; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* MMU context supplied by driver */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Buffer length in bytes */
	u64	length; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Stride in bytes */
	u64	stride; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_exercise_mmu [256 bits] */

/* 
 * CSR Query device structure 
 */
struct psif_epsc_device_attr {
	/* *** 64 bit group 0 start *** */
	u64	fw_ver; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	sys_image_guid; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	node_guid; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	u64	max_mr_size; /* 64 bits @ offs 3:0 */
	/* *** 64 bit group 4 start *** */
	u64	page_size_cap; /* 64 bits @ offs 4:0 */
	/* *** 64 bit group 5 start *** */
	u32	vendor_part_id; /* 32 bits @ offs 5:0 */
	u32	vendor_id; /* 32 bits @ offs 5:32 */
	/* *** 64 bit group 6 start *** */
	u32	max_qp; /* 32 bits @ offs 6:0 */
	u32	hw_ver; /* 32 bits @ offs 6:32 */
	/* *** 64 bit group 7 start *** */
	u32	device_cap_flags; /* 32 bits @ offs 7:0 */
	u32	max_qp_wr; /* 32 bits @ offs 7:32 */
	/* *** 64 bit group 8 start *** */
	u32	max_sge_rd; /* 32 bits @ offs 8:0 */
	u32	max_sge; /* 32 bits @ offs 8:32 */
	/* *** 64 bit group 9 start *** */
	u32	max_cqe; /* 32 bits @ offs 9:0 */
	u32	max_cq; /* 32 bits @ offs 9:32 */
	/* *** 64 bit group 10 start *** */
	u32	max_pd; /* 32 bits @ offs 10:0 */
	u32	max_mr; /* 32 bits @ offs 10:32 */
	/* *** 64 bit group 11 start *** */
	u32	max_ee_rd_atom; /* 32 bits @ offs 11:0 */
	u32	max_qp_rd_atom; /* 32 bits @ offs 11:32 */
	/* *** 64 bit group 12 start *** */
	u32	max_qp_init_rd_atom; /* 32 bits @ offs 12:0 */
	u32	max_res_rd_atom; /* 32 bits @ offs 12:32 */
	/* *** 64 bit group 13 start *** */
	#if defined(__arm__) /* enum psif_epsc_atomic_cap */
		u32	atomic_cap:32;
	#else /* !__arm__ */
		enum psif_epsc_atomic_cap	atomic_cap:32;
	#endif	 /* 32 bits @ offs 13:0 */
	u32	max_ee_init_rd_atom; /* 32 bits @ offs 13:32 */
	/* *** 64 bit group 14 start *** */
	u32	max_ee; /* 32 bits @ offs 14:0 */
	#if defined(__arm__) /* enum psif_epsc_atomic_cap */
		u32	masked_atomic_cap:32;
	#else /* !__arm__ */
		enum psif_epsc_atomic_cap	masked_atomic_cap:32;
	#endif	 /* 32 bits @ offs 14:32 */
	/* *** 64 bit group 15 start *** */
	u32	max_mw; /* 32 bits @ offs 15:0 */
	u32	max_rdd; /* 32 bits @ offs 15:32 */
	/* *** 64 bit group 16 start *** */
	u32	max_raw_ethy_qp; /* 32 bits @ offs 16:0 */
	u32	max_raw_ipv6_qp; /* 32 bits @ offs 16:32 */
	/* *** 64 bit group 17 start *** */
	u32	max_mcast_qp_attach; /* 32 bits @ offs 17:0 */
	u32	max_mcast_grp; /* 32 bits @ offs 17:32 */
	/* *** 64 bit group 18 start *** */
	u32	max_ah; /* 32 bits @ offs 18:0 */
	u32	max_total_mcast_qp_attach; /* 32 bits @ offs 18:32 */
	/* *** 64 bit group 19 start *** */
	u32	max_map_per_fmr; /* 32 bits @ offs 19:0 */
	u32	max_fmr; /* 32 bits @ offs 19:32 */
	/* *** 64 bit group 20 start *** */
	u32	max_srq_wr; /* 32 bits @ offs 20:0 */
	u32	max_srq; /* 32 bits @ offs 20:32 */
	/* *** 64 bit group 21 start *** */
	u32	max_fast_reg_page_list_len; /* 32 bits @ offs 21:0 */
	u32	max_srq_sge; /* 32 bits @ offs 21:32 */
	/* *** 64 bit group 22 start *** */
	/* Warn: Padding added in alignment check */
	u8	space7; /* 8 bits @ offs 22:0 */
	u64	phys_port_cnt:32; /* 32 bits @ offs 22:8 */
	u64	local_ca_ack_delay:8; /* 8 bits @ offs 22:40 */
	u64	max_pkeys:16; /* 16 bits @ offs 22:48 */
} PSIF_PACKED_ALIGNED32; /* struct psif_epsc_device_attr [1536 bits] */

/*
 * The eps-c fw csr to host sw completion
 * Response to a CSR request
 */
struct psif_epsc_csr_rsp {
	/* *** 64 bit group 0 start *** */
	/* Address from request */
	u32	addr; /* 32 bits @ offs 0:0 */
	/* Data integrity */
	u16	crc; /* 16 bits @ offs 0:32 */
	/* enum psif_epsc_csr_opcode from request */
	#if defined(__arm__) /* enum psif_epsc_csr_opcode */
		u16	opcode:8;
	#else /* !__arm__ */
		enum psif_epsc_csr_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 0:48 */
	/* return status of operation */
	#if defined(__arm__) /* enum psif_epsc_csr_status */
		u16	status:8;
	#else /* !__arm__ */
		enum psif_epsc_csr_status	status:8;
	#endif	 /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/* Data from operation */
	u64	data; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Info from operation */
	u64	info; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Sequence number from request */
	u64	seq_num; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED32; /* struct psif_epsc_csr_rsp [256 bits] */

/*
 * Padded base addr struct
 */
struct psif_epsc_csr_base_addr {
	/* *** 64 bit group 0 start *** */
	/* this should be psif_base_addr_t base_addr */
	u64	address; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_context; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * extent_log2 used for entry alignment. This field used to calculate
	 * address for a particular entry. Address to an entry is calculated as
	 * follows: host_addr + entry_num*(1 [leftshift] extent_log2)
	 */
	u32	extent_log2:5; /* 5 bits @ offs 2:0 */
	/* special padding */
	u32	:27; /* 27 bits @ offs 2:5 */
	/* Number of entries in table. */
	u32	num_entries; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	u32	:32; /* 32 bits @ offs 3:0 */
	/* msix_index is valid only for EQ setup */
	u32	msix_index; /* 32 bits @ offs 3:32 */
	/* *** 64 bit group 4 start *** */
	/* Fill to alignmnet *//* ... */

	u64	padding[7]; /* 64 bits @ offs 4:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_base_addr [704 bits] */

/*
 * Modify QP CSR structure
 */
struct psif_epsc_csr_modify_qp {
	/* *** 64 bit group 0 start *** */
	struct psif_csr_modify_qp_ctrl	ctrl; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_modify_qp	data; /* 640 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_modify_qp [704 bits] */

/*
 * Query QP
 *
 * int ibv_query_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr, enum
 * ibv_qp_attr_mask attr_mask, struct ibv_qp_init_attr *init_attr)
 *
 * Input Parameters:
 *  qp struct ibv_qp from ibv_create_qp
 *  attr_mask bitmask of items to query (see ibv_modify_qp)
 * Output Parameters:
 *  attr struct ibv_qp_attr to be filled in with requested attributes
 *  init_attr struct ibv_qp_init_attr to be filled in with initial
 *  attributes
 * Return Value:
 *  0 on success, errno on failure.
 */
struct psif_epsc_csr_query_qp {
	/* *** 64 bit group 0 start *** */
	/* Response data assumed to use mmu_context of mail-box */
	u64	address; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_csr_modify_qp_ctrl	ctrl; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	padding[9]; /* 64 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_query_qp [704 bits] */

/*
 * EPSC_SET_LID{,_P1,_P2}
 */
struct psif_epsc_csr_set_lid {
	/* *** 64 bit group 0 start *** */
	struct psif_csr_own_lid_base	lid_rqs; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_csr_snd_lid	lid_snd; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	struct psif_csr_rcv_lid	lid_rcv; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	u64	:48; /* 48 bits @ offs 3:0 */
	/* Index pt. not used (PSIF.ARCH.03.12 and later) */
	u64	index:8; /* 8 bits @ offs 3:48 */
	u64	port:8; /* 8 bits @ offs 3:56 */
	/* *** 64 bit group 4 start *** */
	u64	padding[7]; /* 64 bits @ offs 4:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_set_lid [704 bits] */

/*
 * EPSC_SET_GID{,_P1,_P2}
 */
struct psif_epsc_csr_set_gid {
	/* *** 64 bit group 0 start *** */
	u64	gid_0; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	gid_1; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	:48; /* 48 bits @ offs 2:0 */
	u64	index:8; /* 8 bits @ offs 2:48 */
	u64	port:8; /* 8 bits @ offs 2:56 */
	/* *** 64 bit group 3 start *** */
	u64	padding[8]; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_set_gid [704 bits] */

/* 
 * Set EPSC_SET_VLINK_STATE
 */
struct psif_epsc_csr_vlink_state {
	/* *** 64 bit group 0 start *** */
	u64	:52; /* 52 bits @ offs 0:0 */
	#if defined(__arm__) /* enum psif_vlink_state */
		u64	vlink_state:5;
	#else /* !__arm__ */
		enum psif_vlink_state	vlink_state:5;
	#endif	 /* 5 bits @ offs 0:52 */
	#if defined(__arm__) /* enum psif_port */
		u64	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 0:57 */
	/* universal_function(6[0] bits)UF */
	u64	uf:6; /* 6 bits @ offs 0:58 */
	/* *** 64 bit group 1 start *** */
	u64	padding[10]; /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_vlink_state [704 bits] */

/*
 * EPSC_QUERY_DEVICE, EPSC_QUERY_PORT, EPSC_QUERY_INFO,
 */
struct psif_epsc_csr_query_hw {
	/* *** 64 bit group 0 start *** */
	/* Response data assumed to use mmu_context of mail-box */
	u64	address; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	padding[10]; /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_query_hw [704 bits] */

/*
 * EPSC_QUERY_PKEY, EPSC_QUERY_GID, 
 */
struct psif_epsc_csr_query_table {
	/* *** 64 bit group 0 start *** */
	u64	:40; /* 40 bits @ offs 0:0 */
	u64	index:16; /* 16 bits @ offs 0:40 */
	u64	port:8; /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	u64	padding[10]; /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_query_table [704 bits] */

/*
 * EPSC_MC_ATTACH, EPSC_MC_DETACH, EPSC_QUERY_MC
 */
struct psif_epsc_csr_mc {
	/* *** 64 bit group 0 start *** */
	u32	:32; /* 32 bits @ offs 0:0 */
	u32	qp:24; /* 24 bits @ offs 0:32 */
	u32	port:8; /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	u64	mgid_0; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	mgid_1; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	u64	padding[8]; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_mc [704 bits] */

/*
 * EPSC_EVENT_ACK
 */
struct psif_epsc_csr_event {
	/* *** 64 bit group 0 start *** */
	u32	eq_index; /* 32 bits @ offs 0:0 */
	u16	:16; /* 16 bits @ offs 0:32 */
	u16	eq_num:8; /* 8 bits @ offs 0:48 */
	u16	port:8; /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/* Will become : psif_eq_event event */
	u64	event[8]; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 9 start *** */
	u64	padding[2]; /* 64 bits @ offs 9:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_event [704 bits] */

/*
 * EPSC_MODIFY_DEVICE
 */
struct psif_epsc_csr_modify_device {
	/* *** 64 bit group 0 start *** */
	u64	:48; /* 48 bits @ offs 0:0 */
	#if defined(__arm__) /* enum psif_epsc_csr_modify_device_flags */
		u64	modify_mask:16;
	#else /* !__arm__ */
		enum psif_epsc_csr_modify_device_flags	modify_mask:16;
	#endif	 /* 16 bits @ offs 0:48 */
	/* *** 64 bit group 1 start *** */
	u64	sys_image_guid; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u8	node_desc[64]; /* 8 bits @ offs 2:0 */
	/* *** 64 bit group 10 start *** */
	u64	padding; /* 64 bits @ offs 10:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_modify_device [704 bits] */

/*
 * EPSC_MODIFY_PORT_{1,2}
 */
struct psif_epsc_csr_modify_port {
	/* *** 64 bit group 0 start *** */
	u32	:32; /* 32 bits @ offs 0:0 */
	u16	init_type:8; /* 8 bits @ offs 0:32 */
	u16	port:8; /* 8 bits @ offs 0:40 */
	#if defined(__arm__) /* enum psif_epsc_csr_modify_port_flags */
		u16	modify_mask:16;
	#else /* !__arm__ */
		enum psif_epsc_csr_modify_port_flags	modify_mask:16;
	#endif	 /* 16 bits @ offs 0:48 */
	/* *** 64 bit group 1 start *** */
	u32	clr_port_cap_mask; /* 32 bits @ offs 1:0 */
	u32	set_port_cap_mask; /* 32 bits @ offs 1:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_modify_port [128 bits] */

/*
 * Test operations : EPSC_TEST_HOST_RD & EPSC_TEST_HOST_WR
 */
struct psif_epsc_csr_test_host_wrd {
	/* *** 64 bit group 0 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	host_addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	data; /* 64 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_test_host_wrd [192 bits] */

/*
 * Flash programming: EPSC_FLASH_START, EPSC_FLASH_RD, 
 *                    EPSC_FLASH_WR & EPSC_FLASH_STOP 
 */
struct psif_epsc_csr_flash_access {
	/* *** 64 bit group 0 start *** */
	u32	length; /* 32 bits @ offs 0:0 */
	u32	offset; /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	host_addr; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	u64	crc; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_flash_access [256 bits] */

/*
 * IB packet tracer setup : EPSC_TRACE_SETUP
 *
 */
struct psif_epsc_csr_trace_setup {
	/* *** 64 bit group 0 start *** */
	u32	:32; /* 32 bits @ offs 0:0 */
	#if defined(__arm__) /* enum psif_epsc_csr_trace_control */
		u32	ctrl:32;
	#else /* !__arm__ */
		enum psif_epsc_csr_trace_control	ctrl:32;
	#endif	 /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/* CSR: TSU_IBPR_TRACE_BUFFER_SETUP */
	struct psif_csr_ibpr_trace_buffer_setup	setup; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* CSR: TSU_IBPR_TRACE_STORE_QUALIFIER1 */
	struct psif_csr_ibpr_trace_store_qualifier1	qual1; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* CSR: TSU_IBPR_TRACE_STORE_QUALIFIER1_MASK */
	struct psif_csr_ibpr_trace_store_qualifier1_mask	qual1_mask; /* 64 bits @ offs 3:0 */
	/* *** 64 bit group 4 start *** */
	/* CSR: TSU_IBPR_TRACE_TRIGGER1 */
	struct psif_csr_ibpr_trace_trigger1	trigg1; /* 64 bits @ offs 4:0 */
	/* *** 64 bit group 5 start *** */
	/* TSU_IBPR_TRACE_TRIGGER1_MASK */
	struct psif_csr_ibpr_trace_trigger1_mask	trigg1_mask; /* 64 bits @ offs 5:0 */
	/* *** 64 bit group 6 start *** */
	/* CSR: TSU_IBPR_TRACE_STORE_QUALIFIER2 */
	struct psif_csr_ibpr_trace_store_qualifier2	qual2; /* 64 bits @ offs 6:0 */
	/* *** 64 bit group 7 start *** */
	/* CSR: TSU_IBPR_TRACE_STORE_QUALIFIER2_MASK */
	struct psif_csr_ibpr_trace_store_qualifier2_mask	qual2_mask; /* 64 bits @ offs 7:0 */
	/* *** 64 bit group 8 start *** */
	/* CSR: TSU_IBPR_TRACE_TRIGGER2 */
	struct psif_csr_ibpr_trace_trigger2	trigg2; /* 64 bits @ offs 8:0 */
	/* *** 64 bit group 9 start *** */
	/* TSU_IBPR_TRACE_TRIGGER2_MASK */
	struct psif_csr_ibpr_trace_trigger2_mask	trigg2_mask; /* 64 bits @ offs 9:0 */
	/* *** 64 bit group 10 start *** */
	u64	padding; /* 64 bits @ offs 10:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_trace_setup [704 bits] */

/*
 * IB packet trace acquire : EPSC_TRACE_ACQUIRE
 *
 */
struct psif_epsc_csr_trace_acquire {
	/* *** 64 bit group 0 start *** */
	/* Pointer to trace buffer */
	u64	host_addr; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Buffer length in bytes */
	u64	maxtrace; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* MMU context supplied by driver */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	u64	padding[8]; /* 64 bits @ offs 3:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_trace_acquire [704 bits] */

/*
 * EPSC_FW_VERSION
 */
struct psif_epsc_csr_fw_version {
	/* *** 64 bit group 0 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	u64	host_addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u64	data; /* 64 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_fw_version [192 bits] */

struct psif_epsc_csr_log_ctrl {
	/* *** 64 bit group 0 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Log mode to use */

	#if defined(__arm__) /* enum psif_epsc_log_mode */
		u32	mode:32;
	#else /* !__arm__ */
		enum psif_epsc_log_mode	mode:32;
	#endif	 /* 32 bits @ offs 1:0 */
	/* Log level to use */

	#if defined(__arm__) /* enum psif_epsc_log_level */
		u32	level:32;
	#else /* !__arm__ */
		enum psif_epsc_log_level	level:32;
	#endif	 /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	/* Fields only used by log mode EPSC_LOG_MODE_HOST *//* Start address of the data area to write to */

	u64	base; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* pointer to a log_stat data area */

	u64	stat_base; /* 64 bits @ offs 3:0 */
	/* *** 64 bit group 4 start *** */
	/* Length in bytes of the buffer */

	u64	length; /* 64 bits @ offs 4:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_log_ctrl [320 bits] */

/*
 * Control link attributes 
 */
struct psif_epsc_csr_link_cntrl {
	/* *** 64 bit group 0 start *** */
	#if defined(__arm__) /* enum psif_epsc_port_state */
		u32	state:32;
	#else /* !__arm__ */
		enum psif_epsc_port_state	state:32;
	#endif	 /* 32 bits @ offs 0:0 */
	u16	:6; /* 6 bits @ offs 0:32 */
	#if defined(__arm__) /* enum psif_ib_link_width */
		u16	width:2;
	#else /* !__arm__ */
		enum psif_ib_link_width	width:2;
	#endif	 /* 2 bits @ offs 0:38 */
	u16	:5; /* 5 bits @ offs 0:40 */
	#if defined(__arm__) /* enum psif_ib_link_speed */
		u16	speed:3;
	#else /* !__arm__ */
		enum psif_ib_link_speed	speed:3;
	#endif	 /* 3 bits @ offs 0:45 */
	u16	port:8; /* 8 bits @ offs 0:48 */
	u16	:5; /* 5 bits @ offs 0:56 */
	u16	set_width:1; /* 1 bits @ offs 0:61 */
	u16	set_speed:1; /* 1 bits @ offs 0:62 */
	u16	set_state:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_link_cntrl [64 bits] */

/*
 * EPS-A to EPS-C
 */
struct psif_epsc_csr_epsa_cntrl {
	/* *** 64 bit group 0 start *** */
	u32	:30; /* 30 bits @ offs 0:0 */
	/* Which EPS-A core */
	#if defined(__arm__) /* enum psif_eps_a_core */
		u32	epsa:2;
	#else /* !__arm__ */
		enum psif_eps_a_core	epsa:2;
	#endif	 /* 2 bits @ offs 0:30 */
	/* Operation */
	#if defined(__arm__) /* enum psif_epsc_csr_epsa_command */
		u32	command:32;
	#else /* !__arm__ */
		enum psif_epsc_csr_epsa_command	command:32;
	#endif	 /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/* Offset within flash */
	u64	flash_addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Address in EPS-A memory */
	u64	epsa_addr; /* 64 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_epsa_cntrl [192 bits] */

/*
 * EPS-A to EPS-A
 */
struct psif_epsc_csr_epsa_cmd {
	/* *** 64 bit group 0 start *** */
	/* MMU context supplied by driver */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Buffer adress in host memory */
	u64	host_addr; /* 64 bits @ offs 1:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_epsa_cmd [128 bits] */

/*
 * EPSC_CLI_ACCESS - buffer size is assumed to be 4K
 */
struct psif_epsc_csr_cli_access {
	/* *** 64 bit group 0 start *** */
	u64	host_addr; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	u8	command[72]; /* 8 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_cli_access [704 bits] */

union psif_epsc_csr_details {
	/* General data to write */
	u64	data[11]; /* 64 bits @ 0 offs 0 */
	/* Descriptor base address */
	struct psif_epsc_csr_base_addr	base_addr; /* 704 bits @ 0 offs 0 */
	/* Modify QP request */
	struct psif_epsc_csr_modify_qp	modify_qp; /* 704 bits @ 0 offs 0 */
	/* Query QP */
	struct psif_epsc_csr_query_qp	query_qp; /* 704 bits @ 0 offs 0 */
	/* Set LID entry */
	struct psif_epsc_csr_set_lid	set_lid; /* 704 bits @ 0 offs 0 */
	/* Set GID entry */
	struct psif_epsc_csr_set_gid	set_gid; /* 704 bits @ 0 offs 0 */
	/* Set vlink state */
	struct psif_epsc_csr_vlink_state	set_vlink; /* 704 bits @ 0 offs 0 */
	/* Query HW state of device port or other */
	struct psif_epsc_csr_query_hw	query_hw; /* 704 bits @ 0 offs 0 */
	/* Query table info pkey or gid */
	struct psif_epsc_csr_query_table	query_table; /* 704 bits @ 0 offs 0 */
	/* MC subscription */
	struct psif_epsc_csr_mc	mc; /* 704 bits @ 0 offs 0 */
	/* Asynchronous event */
	struct psif_epsc_csr_event	event; /* 704 bits @ 0 offs 0 */
	/* EPSC_MODIFY_DEVICE */
	struct psif_epsc_csr_modify_device	device; /* 704 bits @ 0 offs 0 */
	/* EPSC_MODIFY_PORT_{1 2} */
	struct psif_epsc_csr_modify_port	port; /* 128 bits @ 0 offs 0 */
	/* EPSC_TEST_HOST_RD & EPSC_TEST_HOST_WR */
	struct psif_epsc_csr_test_host_wrd	host_wrd; /* 192 bits @ 0 offs 0 */
	/* EPSC_FLASH_START EPSC_FLASH_RD EPSC_FLASH_WR & EPSC_FLASH_STOP */
	struct psif_epsc_csr_flash_access	flash; /* 256 bits @ 0 offs 0 */
	/* EPSC_TRACE_SETUP */
	struct psif_epsc_csr_trace_setup	trace_setup; /* 704 bits @ 0 offs 0 */
	/* EPSC_TRACE_ACQUIRE */
	struct psif_epsc_csr_trace_acquire	trace_acquire; /* 704 bits @ 0 offs 0 */
	/* EPSC_FW_VERSION */
	struct psif_epsc_csr_fw_version	fw_version; /* 192 bits @ 0 offs 0 */
	/* EPSC_LOG_CTRL */
	struct psif_epsc_csr_log_ctrl	log_ctrl; /* 320 bits @ 0 offs 0 */
	/* Control link attributes */
	struct psif_epsc_csr_link_cntrl	link_cntrl; /* 64 bits @ 0 offs 0 */
	/* Control epsa */
	struct psif_epsc_csr_epsa_cntrl	epsa_cntrl; /* 192 bits @ 0 offs 0 */
	struct psif_epsc_csr_epsa_cmd	epsa_cmd; /* 128 bits @ 0 offs 0 */
	/* Exercise mmu from epsc */
	struct psif_epsc_exercise_mmu	epsc_exercise_mmu; /* 256 bits @ 0 offs 0 */
	/* Issue commands to serial console */
	struct psif_epsc_csr_cli_access	cli; /* 704 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_epsc_csr_details [704 bits] */

/*
 * The host sw to eps-c fw csr workrequest
 *
 * The EPSC will post the completion responses for request #seq_num
 * into the completion queue at :
 *    index = #seq_num % epsc_cq.base_addr.num_entries
 * as provided by the initial EPSC_SETUP work request:
 */
struct psif_epsc_csr_req {
	/* *** 64 bit group 0 start *** */
	/* Data integrity */
	u16	crc; /* 16 bits @ offs 0:0 */
	/* UF - only valid for UF 0 - must be 0 otherwise */
	u16	uf; /* 16 bits @ offs 0:16 */
	/* Sequence number - included in response */
	u16	seq_num; /* 16 bits @ offs 0:32 */
	#if defined(__arm__) /* enum psif_epsc_csr_flags */
		u16	flags:8;
	#else /* !__arm__ */
		enum psif_epsc_csr_flags	flags:8;
	#endif	 /* 8 bits @ offs 0:48 */
	#if defined(__arm__) /* enum psif_epsc_csr_opcode */
		u16	opcode:8;
	#else /* !__arm__ */
		enum psif_epsc_csr_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/* Register offset or port number */
	u64	addr; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Operation specific data */
	union psif_epsc_csr_details	u; /* 704 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED32; /* struct psif_epsc_csr_req [1024 bits] */

/* Doorbel/mail-box register layout */
struct psif_epsc_csr_doorbell {
	/* *** 64 bit group 0 start *** */
	/* */
	u16	tail; /* 16 bits @ offs 0:0 */
	/* */
	u64	data:32; /* 32 bits @ offs 0:16 */
	/* */
	u64	head:16; /* 16 bits @ offs 0:48 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_doorbell [64 bits] */

/*
 * Basic configuration data for each UF
 */
struct psif_epsc_csr_config {
	/* *** 64 bit group 0 start *** */
	/* Major protocol version identifier */
	u32	major_ver; /* 32 bits @ offs 0:0 */
	/* Minor protocol version identifier */
	u32	minor_ver; /* 32 bits @ offs 0:32 */
	/* *** 64 bit group 1 start *** */
	/* Request base address */
	u64	request; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* Respose base address */
	u64	response; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/* Size of response entry */
	u16	extent_rsp; /* 16 bits @ offs 3:0 */
	/* Size of request entry */
	u16	extent_req; /* 16 bits @ offs 3:16 */
	/* Number of entries in table */
	u32	entries; /* 32 bits @ offs 3:32 */
	/* *** 64 bit group 4 start *** */
	/* MMU context for mailbox */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 4:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_epsc_csr_config [320 bits] */

/* This is the portion of the descriptor which is updated by software. */
struct psif_cq_sw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u32	space8; /* 32 bits @ offs 0:0 */
	/* Index to completion elements added by SW. */
	u32	head_indx; /* 32 bits @ offs 0:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_cq_sw [64 bits] */

/*
 * Descriptor entry for a completion queue. This entry is used to address
 * into the completion queue and write the correct entries. This structure is
 * the hardware updateable part of the CQ descriptor.
 */
struct psif_cq_hw { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* cq_max_msg(32[0] bits)Maximum message size in bytes. */
	u32	max_size; /* 32 bits @ offs 0:0 */
	/*
	 * Interrupt channel associated with the event queue. In the PSIF design the
	 * event queues are one to one with interrupt channel.
	 */
	u32	int_channel:7; /* 7 bits @ offs 0:32 */
	/*
	 * Set by DSCR when CQ overrun async event is sent for this CQ. Not cleared
	 * before CQ is destroyed.
	 */
	u32	cq_overrun_event_sent:1; /* 1 bits @ offs 0:39 */
	/* Reserved */
	u32	:7; /* 7 bits @ offs 0:40 */
	/*
	 * Pre-fetch threshold (clog2) indicating when to read the software portion
	 * of the descriptor. If there are less entries than indicated by this
	 * threshold, the software portion of the descriptor must be read.
	 */
	u32	prefetch_threshold_log2:5; /* 5 bits @ offs 0:47 */
	/*
	 * EPS-A core number completions are forwarded to if the proxy_enabled bit is
	 * set.
	 */
	#if defined(__arm__) /* enum psif_eps_a_core */
		u32	eps_core:2;
	#else /* !__arm__ */
		enum psif_eps_a_core	eps_core:2;
	#endif	 /* 2 bits @ offs 0:52 */
	/*
	 * If set, this completion queue is proxy enabled and should send completions
	 * to EPS core indicated by the eps_core field.
	 */
	u32	proxy_en:1; /* 1 bits @ offs 0:54 */
	/*
	 * Log2 size of the completion queue. Maximum number of entries in the
	 * completion queue. This is used for calculating when to wrap the head and
	 * tail indexes.
	 */
	u32	size_log2:5; /* 5 bits @ offs 0:55 */
	/* The descriptor is valid. */
	u32	valid:1; /* 1 bits @ offs 0:60 */
	/*
	 * CQ notification states. The use of these are as defined in the description
	 * of the PSIF interrupt coalsecing scheme.
	 */
	#if defined(__arm__) /* enum psif_cq_state */
		u32	cq_not_state:2;
	#else /* !__arm__ */
		enum psif_cq_state	cq_not_state:2;
	#endif	 /* 2 bits @ offs 0:61 */
	/* Do not evict this entry if this bit is set. */
	u32	sticky:1; /* 1 bits @ offs 0:63 */
	/* *** 64 bit group 1 start *** */
	struct psif_mmu_cntx	mmu_cntx; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/*
	 * VA or PA of the base of the completion queue. If PA the MMU context above
	 * will be a bypass context. Updated by software. The head and tail pointers
	 * can be calculated by the following calculations: Address = base_ptr +
	 * (head * ($bits(completion_entry_t)/8 ) Head Pointer and Tail Pointer will
	 * use the same MMU context as the base, and all need to be VA from one
	 * address space, or all need to be PA. In typical use, to allow direct user
	 * access to the head and tail pointer VAs are used.
	 */
	u64	base_addr; /* 64 bits @ offs 2:0 */
	/* *** 64 bit group 3 start *** */
	/*
	 * Completion queue sequence number. This is the sequence number to be used
	 * for this completion. When used by a client, it is incremented and written
	 * back to this descriptor.
	 */
	u32	sequence_number; /* 32 bits @ offs 3:0 */
	/* Index to completion elements to be consumed by HW. */
	u32	tail_indx; /* 32 bits @ offs 3:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_cq_hw [256 bits] */

/*
 * Union between CQ sequence number and immediate date. CQ sequence number is
 * only valid for privileged QP requests.
 */
union psif_seq_num_immdt {
	/*
	 * Completion queue sequence number for arming of completion queues. This is
	 * the CQ sequence number for the completion queue which was armed.
	 */
	u32	cq_sequence_number; /* 32 bits @ 0 offs 0 */
	/* ib_immediate(32[0] bits)Immediate Data */
	u32	imm; /* 32 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_seq_num_immdt [32 bits] */

struct psif_wc_flags {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:62; /* 62 bits @ offs 0:0 */
	u64	with_imm:1; /* 1 bits @ offs 0:62 */
	u64	grh:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_wc_flags [64 bits] */

/* L3/L4 packet classification. */
struct psif_ip_class {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:57; /* 57 bits @ offs 0:0 */
	/* L4 is UDP. */
	u64	udp:1; /* 1 bits @ offs 0:57 */
	/* L4 is TCP. */
	u64	tcp:1; /* 1 bits @ offs 0:58 */
	/* Unsupported IPv6 extension headers detected. */
	u64	ip6_unsupported_exthdr:1; /* 1 bits @ offs 0:59 */
	/* IPv4 options or IPv6 extension headers present. */
	u64	ip_options:1; /* 1 bits @ offs 0:60 */
	/* IP fragment. */
	u64	ip_frag:1; /* 1 bits @ offs 0:61 */
	/* This is set for IPv6 packets only. */
	u64	ipv6:1; /* 1 bits @ offs 0:62 */
	/* This is set for IPv4 packets only. */
	u64	ipv4:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_ip_class [64 bits] */

/* Packet classification structure. */
struct psif_packet_classification {
	/* *** 64 bit group 0 start *** */
	/* L4 is UDP. */
	u8	udp:1; /* 1 bits @ offs 0:0 */
	/* L4 is TCP. */
	u8	tcp:1; /* 1 bits @ offs 0:1 */
	/* Unsupported IPv6 extension headers detected. */
	u8	ip6_unsupported_exthdr:1; /* 1 bits @ offs 0:2 */
	/* IPv4 options or IPv6 extension headers present. */
	u8	ip_options:1; /* 1 bits @ offs 0:3 */
	/* IP fragment. */
	u8	ip_frag:1; /* 1 bits @ offs 0:4 */
	/* This is set for IPv6 packets only. */
	u8	ipv6:1; /* 1 bits @ offs 0:5 */
	/* This is set for IPv4 packets only. */
	u8	ipv4:1; /* 1 bits @ offs 0:6 */
	/* L3/L4 packet classification. */
	/* Inlined ip_class : struct psif_ip_class (64 bits) */ /* 64 bits @ offs 0:7 */
	/*
	 * 0: means LLC_SNAP, 1: means Ethernet type 2. (L2 packet classification.)
	 * This field is applicable for EoIB only.
	 */
	u8	eth2:1; /* 1 bits @ offs 0:7 */
} PSIF_PACKED; /* struct psif_packet_classification [ 8 bits] */

/* Reduced header/data split data structure needed for offloading. */
struct psif_hdr_split_offload {
	/* *** 64 bit group 0 start *** */
	/* Warn: Padding added in alignment check */
	u64	:54; /* 54 bits @ offs 0:0 */
	/*
	 * Header length used for header/data split offloading. The length of this
	 * header is added to one scatter element.
	 */
	u64	hdr_length:9; /* 9 bits @ offs 0:54 */
	/* The header length is valid for header/data split offloading. */
	u64	valid:1; /* 1 bits @ offs 0:63 */
} PSIF_PACKED_ALIGNED; /* struct psif_hdr_split_offload [64 bits] */

/*
 * Completion entry. A completion entry written to host memory, will be
 * padded out to 64 bytes. The last 4 bytes will contain a completion queue
 * sequence number.
 */
struct psif_cq_entry { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * Work queue completion ID. For receive completions this is the entry number
	 * in the receive queue and the receive queue descriptor index. For send
	 * completions this is the sq_sequence number.
	 */
	union psif_completion_wc_id	wc_id; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* ib_bth_qp_number(24[0] bits)Queue Pair */
	u32	qp:24; /* 24 bits @ offs 1:0 */
	#if defined(__arm__) /* enum psif_wc_opcode */
		u32	opcode:8;
	#else /* !__arm__ */
		enum psif_wc_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 1:24 */
	/* Length of message. Only valid if not privileged. */
	u32	byte_len; /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	/* Only valid for UD QPs. */
	u32	src_qp:24; /* 24 bits @ offs 2:0 */
	#if defined(__arm__) /* enum psif_wc_status */
		u32	status:8;
	#else /* !__arm__ */
		enum psif_wc_status	status:8;
	#endif	 /* 8 bits @ offs 2:24 */
	union psif_seq_num_immdt	seq_num_imm; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	/* RSS source. Only valid if not privileged. */
	#if defined(__arm__) /* enum psif_rss_hash_source */
		u32	rss_hash_src:1;
	#else /* !__arm__ */
		enum psif_rss_hash_source	rss_hash_src:1;
	#endif	 /* 1 bits @ offs 3:0 */
	#if defined(__arm__) /* enum psif_tsu_error_types */
		u32	vendor_err:8;
	#else /* !__arm__ */
		enum psif_tsu_error_types	vendor_err:8;
	#endif	 /* 8 bits @ offs 3:1 */
	/*
	 * Checksum with error. This is not inverted for UDP if zero result from
	 * check. It can be either a full or partial checksum. Only valid if not
	 * privileged.
	 */
	u32	error_checksum:16; /* 16 bits @ offs 3:9 */
	/*
	 * Path bits (lower 7 bits) taken from the DLID in the received packet. This
	 * is only valid for UD QPs. Only valid if not privileged.
	 */
	u32	dlid_path_bits:7; /* 7 bits @ offs 3:25 */
	/*
	 * SLID taken from the received packet. This is only valid for UD QPs. Only
	 * valid if not privileged.
	 */
	u16	slid; /* 16 bits @ offs 3:32 */
	/* IB portnumber this packet was received on. Only valid if not privileged. */
	#if defined(__arm__) /* enum psif_port */
		u16	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 3:48 */
	/* Only valid for UD QPs. */
	u16	sl:4; /* 4 bits @ offs 3:49 */
	/* P-Key index from UD packet. */
	u16	pkey_indx:9; /* 9 bits @ offs 3:53 */
	u16	with_imm:1; /* 1 bits @ offs 3:62 */
	u16	grh:1; /* 1 bits @ offs 3:63 */
	/* *** 64 bit group 4 start *** */
	/* Flags indicating GRH and immediate presence.Only valid if not privileged. */
	/* Inlined wc_flags : struct psif_wc_flags (64 bits) */ /* 64 bits @ offs 4:0 */
	/* *** 64 bit group 4 start *** */
	/* Reserved */
	u16	:5; /* 5 bits @ offs 4:0 */
	/*
	 * Header length used for header/data split offloading. The length of this
	 * header is added to one scatter element.
	 */
	u16	hdr_length:9; /* 9 bits @ offs 4:5 */
	/* The header length is valid for header/data split offloading. */
	u16	valid:1; /* 1 bits @ offs 4:14 */
	/*
	 * When valid, header/data split is performed and the header length is given
	 * in hdr_length.
	 */
	/* Inlined hdr_split : struct psif_hdr_split_offload (64 bits) */ /* 64 bits @ offs 4:15 */
	/* This is set if the packet was a DR packet. Only valid if not privileged. */
	u16	is_dr:1; /* 1 bits @ offs 4:15 */
	/*
	 * Original UF for QP0/1 packets going to the EPS-C. Only valid if not
	 * privileged.
	 */
	u16	orig_uf:6; /* 6 bits @ offs 4:16 */
	/*
	 * L4 checksum calculated ok. This is either correct TCP/UDP checksum or UDP
	 * checksum not generated by the transmitter. Only valid if not privileged.
	 */
	u16	l4_checksum_ok:1; /* 1 bits @ offs 4:22 */
	/*
	 * L3 checksum calculated ok. This is either an IPv6 packet or a correctly
	 * checksummed IPv4 header. Only valid if not privileged.
	 */
	u16	l3_checksum_ok:1; /* 1 bits @ offs 4:23 */
	/* L4 is UDP. */
	u16	udp:1; /* 1 bits @ offs 4:24 */
	/* L4 is TCP. */
	u16	tcp:1; /* 1 bits @ offs 4:25 */
	/* Unsupported IPv6 extension headers detected. */
	u16	ip6_unsupported_exthdr:1; /* 1 bits @ offs 4:26 */
	/* IPv4 options or IPv6 extension headers present. */
	u16	ip_options:1; /* 1 bits @ offs 4:27 */
	/* IP fragment. */
	u16	ip_frag:1; /* 1 bits @ offs 4:28 */
	/* This is set for IPv6 packets only. */
	u16	ipv6:1; /* 1 bits @ offs 4:29 */
	/* This is set for IPv4 packets only. */
	u16	ipv4:1; /* 1 bits @ offs 4:30 */
	/* L3/L4 packet classification. */
	/* Inlined ip_class : struct psif_ip_class (64 bits) */ /* 64 bits @ offs 4:31 */
	/*
	 * 0: means LLC_SNAP, 1: means Ethernet type 2. (L2 packet classification.)
	 * This field is applicable for EoIB only.
	 */
	u16	eth2:1; /* 1 bits @ offs 4:31 */
	/*
	 * Packet classification structure for offloading packets. Only valid if not
	 * privileged.
	 */
	/* Inlined packet_classification : struct psif_packet_classification (8 bits) */ /* 8 bits @ offs 4:32 */
	/* RSS hash. Only valid if not privileged. */
	u32	rss_hash; /* 32 bits @ offs 4:32 */
	/* *** 64 bit group 5 start *** */
	/* Padding out struct bulk */
	u64	reserved[2]; /* 64 bits @ offs 5:0 */
	/* *** 64 bit group 7 start *** */
	/* sequence number for sanity checking */
	u32	seq_num; /* 32 bits @ offs 7:0 */
	/* Padding out struct last */
	u32	:32; /* 32 bits @ offs 7:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_cq_entry [512 bits] */

/* Generic CSR */
struct psif_csr_generic {
	/* *** 64 bit group 0 start *** */
	u64	data; /* 64 bits @ offs 0:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_csr_generic [64 bits] */

/* Asynchronous event queue entry. */
struct psif_async_eq_entry {
	/* *** 64 bit group 0 start *** */
	/* Reserved */
	u32	:21; /* 21 bits @ offs 0:0 */
	/*
	 * Valid bit for this event entry. It is here as a help for SW/FW. If this
	 * register is read, and this bit is not set, the FIFO this register is fed
	 * from is empty.
	 */
	u32	valid:1; /* 1 bits @ offs 0:21 */
	/* Type of event. */
	#if defined(__arm__) /* enum psif_event_type */
		u32	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:22 */
	/* UF - valid for affiliated events. */
	u32	uf:6; /* 6 bits @ offs 0:26 */
	#if defined(__arm__) /* enum psif_event_status */
		u32	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:32 */
	/* QP number - valid for affiliated events. */
	u32	qp:24; /* 24 bits @ offs 0:40 */
	/* *** 64 bit group 1 start *** */
	/* Async event data. */
	/* Inlined data : struct psif_async_eq_entry_status_fifo (64 bits) */ /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/* Status and type of this async event. */
	/* Inlined status : struct psif_async_eq_entry_status (64 bits) */ /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	/* Reserved */
	u64	:23; /* 23 bits @ offs 1:0 */
	/* IB port number */
	#if defined(__arm__) /* enum psif_port */
		u64	port_num:1;
	#else /* !__arm__ */
		enum psif_port	port_num:1;
	#endif	 /* 1 bits @ offs 1:23 */
	/* LID. */
	u64	lid:16; /* 16 bits @ offs 1:24 */
	/* Descriptor union. */
	/* Actual data type: union eq_dscr_union */
	u64	dscr_union:24; /* 24 bits @ offs 1:40 */
	/* *** 64 bit group 2 start *** */
	/* Affiliated data. */
	/* Inlined affiliated_data : struct psif_async_eq_entry_affiliated (64 bits) */ /* 64 bits @ offs 2:0 */
} PSIF_PACKED_ALIGNED; /* struct psif_async_eq_entry [128 bits] */

/*
 * Address handle array entry used for sending UD packets. The structure
 * contains information about the destination for a request.
 */
struct psif_ah { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	u64	grh_remote_gid_0; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Inlined grh : struct psif_grh (192 bits) */ /* 192 bits @ offs 1:0 */
	/* *** 64 bit group 1 start *** */
	u64	grh_remote_gid_1; /* 64 bits @ offs 1:0 */
	/* *** 64 bit group 2 start *** */
	/* ib_lrh_lid(16[0] bits)Local ID */
	u16	remote_lid; /* 16 bits @ offs 2:0 */
	/* gid_indx(1[0] bits)GID index indicating which of the UFs two GIDs are used. */
	u64	gid_indx:1; /* 1 bits @ offs 2:16 */
	#if defined(__arm__) /* enum psif_port */
		u64	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 2:17 */
	#if defined(__arm__) /* enum psif_loopback */
		u64	loopback:1;
	#else /* !__arm__ */
		enum psif_loopback	loopback:1;
	#endif	 /* 1 bits @ offs 2:18 */
	#if defined(__arm__) /* enum psif_use_grh */
		u64	use_grh:1;
	#else /* !__arm__ */
		enum psif_use_grh	use_grh:1;
	#endif	 /* 1 bits @ offs 2:19 */
	/* ib_lrh_sl(4[0] bits)Service Level */
	u64	sl:4; /* 4 bits @ offs 2:20 */
	/* Reserved */
	u64	:4; /* 4 bits @ offs 2:24 */
	/* ib_grh_hoplmt(8[0] bits)Hop Limit */
	u64	grh_hoplmt:8; /* 8 bits @ offs 2:28 */
	/* ib_grh_tclass(8[0] bits)Traffic Class */
	u64	grh_tclass:8; /* 8 bits @ offs 2:36 */
	/* ib_grh_flowl(20[0] bits)Flow Label */
	u64	grh_flowlabel:20; /* 20 bits @ offs 2:44 */
	/* *** 64 bit group 3 start *** */
	/* Reserved */
	u64	:8; /* 8 bits @ offs 3:0 */
	/*
	 * The protection domain is checked against the protection domain in the QP
	 * state. As long as they are equal, the QP is allowed to use this AHA entry.
	 */
	u64	pd:24; /* 24 bits @ offs 3:8 */
	/* ipd(8[0] bits)Inter packet delay. Encoded as specified in IB spec. */
	u64	ipd:8; /* 8 bits @ offs 3:32 */
	/* Reserved */
	u64	:8; /* 8 bits @ offs 3:40 */
	/* ib_lrh_lid_path_bits(7[0] bits)Path bits for the LID. Used as the least signficant bits in a LID */
	u64	local_lid_path:7; /* 7 bits @ offs 3:48 */
	/* Reserved */
	u64	:9; /* 9 bits @ offs 3:55 */
} PSIF_PACKED_ALIGNED; /* struct psif_ah [256 bits] */

/*
 * This header is used for IB send operations. The header is a union and
 * consists of either a connected mode header or a datagram mode header. The
 * following opcodes are using this header: PSIF_WR_SEND PSIF_WR_SEND_IMM
 * PSIF_WR_SPECIAL_QP_SEND PSIF_WR_QP0_SEND_DR_XMIT
 * PSIF_WR_QP0_SEND_DR_LOOPBACK PSIF_WR_EPS_SPECIAL_QP_SEND
 * PSIF_WR_EPS_QP0_SEND_DR_XMIT PSIF_WR_EPS_QP0_SEND_DR_LOOPBACK PSIF_WR_LSO
 */
union psif_wr_send {
	/* Header used for IB send commands using UD mode. */
	struct psif_wr_ud_send	ud; /* 224 bits @ 0 offs 0 */
	/* Header used with IB send commands using connected mode. */
	struct psif_wr_cm	uc_rc_xrc; /* 224 bits @ 0 offs 0 */
} PSIF_PACKED; /* union psif_wr_send [224 bits] */

/* Event queue entry. */
struct psif_eq_entry_base {
	/* *** 64 bit group 0 start *** */
	/* Receive queue descriptor ID. */
	u64	rqd_id:24; /* 24 bits @ offs 0:0 */
	/* Completion queue descriptor ID. */
	u64	cqd_id:24; /* 24 bits @ offs 0:24 */
	#if defined(__arm__) /* enum psif_port_flags */
		u64	port_flags:4;
	#else /* !__arm__ */
		enum psif_port_flags	port_flags:4;
	#endif	 /* 4 bits @ offs 0:48 */
	/* Type of event this is. */
	#if defined(__arm__) /* enum psif_event_type */
		u64	event_type:4;
	#else /* !__arm__ */
		enum psif_event_type	event_type:4;
	#endif	 /* 4 bits @ offs 0:52 */
	#if defined(__arm__) /* enum psif_event_status */
		u64	event_status:8;
	#else /* !__arm__ */
		enum psif_event_status	event_status:8;
	#endif	 /* 8 bits @ offs 0:56 */
	/* *** 64 bit group 1 start *** */
	/* QP number. */
	u64	qp:24; /* 24 bits @ offs 1:0 */
	/* Ring buffer descriptor ID. */
	u64	rbd_id:24; /* 24 bits @ offs 1:24 */
	/* IB port number */
	#if defined(__arm__) /* enum psif_port */
		u64	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 1:48 */
	/* Reserved */
	u64	:7; /* 7 bits @ offs 1:49 */
	#if defined(__arm__) /* enum psif_eps_core_id */
		u64	eps_core_id:4;
	#else /* !__arm__ */
		enum psif_eps_core_id	eps_core_id:4;
	#endif	 /* 4 bits @ offs 1:56 */
	/* vendor_fields(4[0] bits)Should this be an enum? */
	u64	vendor_fields:4; /* 4 bits @ offs 1:60 */
	/* *** 64 bit group 2 start *** */
	/* Warn: Padding added in alignment check */
	u32	space16; /* 32 bits @ offs 2:0 */
	/* Completion queue sequence number causing the event to be sent. */
	u32	cq_sequence_number; /* 32 bits @ offs 2:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_eq_entry_base [192 bits] */

/*
 * Ring buffer header. A ring buffer header is preceding payload data when
 * written to host memory. The full message with RB header and payload data
 * is padded out to become a multiple of 64 bytes. The last 4 bytes of every
 * 64B data written, will contain the ring buffer sequence number.
 */
struct psif_rb_entry_base { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/* Length of data associated with this ring buffer header. */
	u32	byte_len; /* 32 bits @ offs 0:0 */
	/* ib_bth_qp_number(24[0] bits)Queue Pair */
	u32	qp_num:24; /* 24 bits @ offs 0:32 */
	/* Applicable only if this is for EPS-A. */
	#if defined(__arm__) /* enum psif_eps_a_core */
		u32	eps_a_core:2;
	#else /* !__arm__ */
		enum psif_eps_a_core	eps_a_core:2;
	#endif	 /* 2 bits @ offs 0:56 */
	/*
	 * MTU used when writing in this packet. This is used to calculate padding
	 * for multi packet messages, since full 64B chunks are always padded if data
	 * is not aligned to the 64B. Since RB sequence numbers are added, there will
	 * always be padding at the end.
	 */
	#if defined(__arm__) /* enum psif_path_mtu */
		u32	mtu:3;
	#else /* !__arm__ */
		enum psif_path_mtu	mtu:3;
	#endif	 /* 3 bits @ offs 0:58 */
	/*
	 * Defining the packet type the headers valid for this ring buffer.
	 * PSIF_RB_TYPE_INVALID PSIF_RB_TYPE_DM_PUT PSIF_RB_TYPE_DM_GET_RESP
	 * PSIF_RB_TYPE_RCV_PROXY_COMPLETION
	 * PSIF_RB_TYPE_RCV_PROXY_COMPLETION_AND_DATA
	 * PSIF_RB_TYPE_SEND_PROXY_COMPLETION PSIF_RB_TYPE_SEND_COMPLETION
	 */
	#if defined(__arm__) /* enum psif_rb_type */
		u32	pkt_type:3;
	#else /* !__arm__ */
		enum psif_rb_type	pkt_type:3;
	#endif	 /* 3 bits @ offs 0:61 */
} PSIF_PACKED_ALIGNED; /* struct psif_rb_entry_base [64 bits] */

/*
 * Completion entry. A completion entry written to host memory, will be
 * padded out to 64 bytes. The last 4 bytes will contain a completion queue
 * sequence number.
 */
struct psif_cq_entry_base { /* Subjected to copy and convert */
	/* *** 64 bit group 0 start *** */
	/*
	 * Work queue completion ID. For receive completions this is the entry number
	 * in the receive queue and the receive queue descriptor index. For send
	 * completions this is the sq_sequence number.
	 */
	union psif_completion_wc_id	wc_id; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* ib_bth_qp_number(24[0] bits)Queue Pair */
	u32	qp:24; /* 24 bits @ offs 1:0 */
	#if defined(__arm__) /* enum psif_wc_opcode */
		u32	opcode:8;
	#else /* !__arm__ */
		enum psif_wc_opcode	opcode:8;
	#endif	 /* 8 bits @ offs 1:24 */
	/* Length of message. Only valid if not privileged. */
	u32	byte_len; /* 32 bits @ offs 1:32 */
	/* *** 64 bit group 2 start *** */
	/* Only valid for UD QPs. */
	u32	src_qp:24; /* 24 bits @ offs 2:0 */
	#if defined(__arm__) /* enum psif_wc_status */
		u32	status:8;
	#else /* !__arm__ */
		enum psif_wc_status	status:8;
	#endif	 /* 8 bits @ offs 2:24 */
	union psif_seq_num_immdt	seq_num_imm; /* 32 bits @ offs 2:32 */
	/* *** 64 bit group 3 start *** */
	/* RSS source. Only valid if not privileged. */
	#if defined(__arm__) /* enum psif_rss_hash_source */
		u32	rss_hash_src:1;
	#else /* !__arm__ */
		enum psif_rss_hash_source	rss_hash_src:1;
	#endif	 /* 1 bits @ offs 3:0 */
	#if defined(__arm__) /* enum psif_tsu_error_types */
		u32	vendor_err:8;
	#else /* !__arm__ */
		enum psif_tsu_error_types	vendor_err:8;
	#endif	 /* 8 bits @ offs 3:1 */
	/*
	 * Checksum with error. This is not inverted for UDP if zero result from
	 * check. It can be either a full or partial checksum. Only valid if not
	 * privileged.
	 */
	u32	error_checksum:16; /* 16 bits @ offs 3:9 */
	/*
	 * Path bits (lower 7 bits) taken from the DLID in the received packet. This
	 * is only valid for UD QPs. Only valid if not privileged.
	 */
	u32	dlid_path_bits:7; /* 7 bits @ offs 3:25 */
	/*
	 * SLID taken from the received packet. This is only valid for UD QPs. Only
	 * valid if not privileged.
	 */
	u16	slid; /* 16 bits @ offs 3:32 */
	/* IB portnumber this packet was received on. Only valid if not privileged. */
	#if defined(__arm__) /* enum psif_port */
		u16	port:1;
	#else /* !__arm__ */
		enum psif_port	port:1;
	#endif	 /* 1 bits @ offs 3:48 */
	/* Only valid for UD QPs. */
	u16	sl:4; /* 4 bits @ offs 3:49 */
	/* P-Key index from UD packet. */
	u16	pkey_indx:9; /* 9 bits @ offs 3:53 */
	u16	with_imm:1; /* 1 bits @ offs 3:62 */
	u16	grh:1; /* 1 bits @ offs 3:63 */
	/* *** 64 bit group 4 start *** */
	/* Flags indicating GRH and immediate presence.Only valid if not privileged. */
	/* Inlined wc_flags : struct psif_wc_flags (64 bits) */ /* 64 bits @ offs 4:0 */
	/* *** 64 bit group 4 start *** */
	/* Reserved */
	u16	:5; /* 5 bits @ offs 4:0 */
	/*
	 * Header length used for header/data split offloading. The length of this
	 * header is added to one scatter element.
	 */
	u16	hdr_length:9; /* 9 bits @ offs 4:5 */
	/* The header length is valid for header/data split offloading. */
	u16	valid:1; /* 1 bits @ offs 4:14 */
	/*
	 * When valid, header/data split is performed and the header length is given
	 * in hdr_length.
	 */
	/* Inlined hdr_split : struct psif_hdr_split_offload (64 bits) */ /* 64 bits @ offs 4:15 */
	/* This is set if the packet was a DR packet. Only valid if not privileged. */
	u16	is_dr:1; /* 1 bits @ offs 4:15 */
	/*
	 * Original UF for QP0/1 packets going to the EPS-C. Only valid if not
	 * privileged.
	 */
	u16	orig_uf:6; /* 6 bits @ offs 4:16 */
	/*
	 * L4 checksum calculated ok. This is either correct TCP/UDP checksum or UDP
	 * checksum not generated by the transmitter. Only valid if not privileged.
	 */
	u16	l4_checksum_ok:1; /* 1 bits @ offs 4:22 */
	/*
	 * L3 checksum calculated ok. This is either an IPv6 packet or a correctly
	 * checksummed IPv4 header. Only valid if not privileged.
	 */
	u16	l3_checksum_ok:1; /* 1 bits @ offs 4:23 */
	/* L4 is UDP. */
	u16	udp:1; /* 1 bits @ offs 4:24 */
	/* L4 is TCP. */
	u16	tcp:1; /* 1 bits @ offs 4:25 */
	/* Unsupported IPv6 extension headers detected. */
	u16	ip6_unsupported_exthdr:1; /* 1 bits @ offs 4:26 */
	/* IPv4 options or IPv6 extension headers present. */
	u16	ip_options:1; /* 1 bits @ offs 4:27 */
	/* IP fragment. */
	u16	ip_frag:1; /* 1 bits @ offs 4:28 */
	/* This is set for IPv6 packets only. */
	u16	ipv6:1; /* 1 bits @ offs 4:29 */
	/* This is set for IPv4 packets only. */
	u16	ipv4:1; /* 1 bits @ offs 4:30 */
	/* L3/L4 packet classification. */
	/* Inlined ip_class : struct psif_ip_class (64 bits) */ /* 64 bits @ offs 4:31 */
	/*
	 * 0: means LLC_SNAP, 1: means Ethernet type 2. (L2 packet classification.)
	 * This field is applicable for EoIB only.
	 */
	u16	eth2:1; /* 1 bits @ offs 4:31 */
	/*
	 * Packet classification structure for offloading packets. Only valid if not
	 * privileged.
	 */
	/* Inlined packet_classification : struct psif_packet_classification (8 bits) */ /* 8 bits @ offs 4:32 */
	/* RSS hash. Only valid if not privileged. */
	u32	rss_hash; /* 32 bits @ offs 4:32 */
} PSIF_PACKED_ALIGNED; /* struct psif_cq_entry_base [320 bits] */

/* Retry data for one atomic request. */
struct psif_atomic_retry {
	/* *** 64 bit group 0 start *** */
	/* ib_atomic_data(64[0] bits)Compare Swap or Add Data */
	u64	orig_data; /* 64 bits @ offs 0:0 */
	/* *** 64 bit group 1 start *** */
	/* Warn: Padding added in alignment check */
	u64	:40; /* 40 bits @ offs 1:0 */
	/* ib_bth_psn(24[0] bits)Packet Sequence Number */
	u64	psn:24; /* 24 bits @ offs 1:40 */
} PSIF_PACKED_ALIGNED; /* struct psif_atomic_retry [128 bits] */


#ifdef __cplusplus
}
#endif


#endif	/* _PSIF_HW_DATA_H */
